\chapter{Модульность, объекты и состояние}
\label{MODULARITY-OBJECTS-AND-STATE}
%\markboth{Глава 3 \qquad Модульность, объекты и состояние}{}
\thispagestyle{empty}
\epigraph{
\textgreek{Metab'allon >anapa'uetai}

(Изменяясь, оно остается неподвижным)}{Гераклит}\index{ru}{Гераклит||||n|}

\epigraph{
Plus \c{c}a change, plus c'est la m\^eme chose\index{ru}{Карр, Альфонс||Alphonse Karr||n|}\index{en}{Alphonse Karr||Карр, Альфонс||n|}}{Альфонс Карр}

В предыдущих главах мы ввели основные элементы, из которых
строятся программы.  Мы видели, как элементарные процедуры и
элементарные данные, сочетаясь, образуют составные сущности; мы
стали понимать, что без абстракции нельзя
справиться со сложностью больших систем.  Однако этих инструментов
недостаточно для разработки программ.  Для эффективного синтеза программ
требуются также организационные принципы, которые помогали бы нам
сформулировать общий проект программы.  В частности, нам нужны
стратегии для построения больших программ по принципу
\index{ru}{модульность||modularity|||}\index{en}{modularity||модульность|||}{\em модульности} (modularity): чтобы программы
<<естественным>> образом делились на логически цельные куски, которые
можно разрабатывать и поддерживать независимо друг от друга.

\index{ru}{моделирование|как стратегия
  разработки||||}\index{ru}{модульность|||||}Существует мощная
стратегия разработки, которая особенно хорошо
подходит для построения программ, моделирующих физические системы:
воспроизводить в структуре программы структуру
моделируемой системы.  Для каждого объекта в системе мы строим
соответствующий ему вычислительный объект.  Для каждого действия в
системе определяем в рамках нашей
вычислительной модели символьную операцию.  Используя эту стратегию, мы надеемся, что
расширение нашей модели на новые объекты или действия не потребует
стратегических изменений в программе, а позволит обойтись только добавлением новых
символьных аналогов этих объектов или действий.  Если наша организация
системы окажется удачной, то для добавления новых возможностей или
отладки старых нам придется работать только с ограниченной частью
системы.

Таким образом, способ, которым мы
организуем большую программу, в значительной степени диктуется нашим восприятием моделируемой
системы.  В этой главе мы исследуем две важных организационных
стратегии, которые соответствуют двум достаточно различным взглядам
на мир и структуру систем.  Первая из них сосредотачивается на
\index{ru}{объект(ы)||object(s)|||}\index{en}{object(s)||объект(ы)|||}{\em объектах} (objects), и большая система
рассматривается как собрание индивидуальных
объектов, поведение которых может меняться со временем.
Альтернативная стратегия строится вокруг
\index{ru}{поток(и)||stream(s)|||}\index{en}{stream(s)||поток(и)|||}{\em потоков} (streams) информации в системе, во многом
подобно тому, как в электронике рассматриваются системы обработки
сигналов.

Как подход, основанный на объектах, так и подход, основанный на
потоках, высвечивают важные вопросы, касающиеся языков
программирования.  При работе с объектами нам приходится думать о том,
как вычислительный объект может изменяться и при этом сохранять свою
индивидуальность. Из-за этого нам придется отказаться от подстановочной модели
вычислений (раздел~\ref{SUBST-MODEL-FOR-PROC-APPL}) в
пользу более механистичной и в то же время менее привлекательной
теоретически \index{ru}{модель вычисления с окружениями||environment     model of evaluation|||}\index{en}{environment     model of evaluation||модель вычисления с окружениями|||}{\em модели с окружениями} (environment model).
Сложности, связанные с объектами, их изменением и индивидуальностью
являются фундаментальным следствием из потребности ввести понятие времени в вычислительные
модели.  Эти сложности только увеличиваются, когда мы добавляем
возможность параллельного выполнения программ.  Получить наибольшую
отдачу от потокового подхода удается тогда, когда
моделируемое время отделяется от порядка событий, происходящих в компьютере
в процессе вычисления.  Мы достигнем этого при помощи метода,
называемого \index{ru}{задержанные вычисления||delayed evaluation|||}\index{en}{delayed evaluation||задержанные вычисления|||}{\em задержанными
вычислениями} (delayed evaluation).

\section{Присваивание и внутреннее состояние объектов}
\label{ASSIGNMENT-AND-LOCAL-STATE}


\index{ru}{присваивание||assignment|||}\index{en}{assignment||присваивание|||}
\index{ru}{внутреннее состояние||local state|||}\index{en}{local state||внутреннее состояние|||}
Обычно мы считаем, что мир состоит из отдельных объектов, и у
каждого из них есть состояние, которое изменяется со временем.  Мы
говорим, что объект <<обладает состоянием>>, если на поведение объекта
влияет его история.  Например, банковский счет обладает состоянием
потому, что ответ на вопрос <<Могу ли я снять 100 долларов?>> зависит от
истории занесения и снятия с него денег.  Состояние объекта можно
описать набором из одной или более
\index{ru}{переменная состояния||state variable|||}\index{en}{state variable||переменная состояния|||}{\em переменных состояния} (state variables),
которые вместе содержат достаточно информации, чтобы определить
текущее поведение объекта.  В простой банковской системе состояние счета можно
охарактеризовать его текущим балансом, вместо того,
чтобы запоминать всю историю транзакций с этим счетом.

Если система состоит из многих объектов, они редко совершенно
независимы друг от друга.  Каждый из них может влиять на состояние
других при помощи актов взаимодействия,
связывающих переменные состояния одного объекта с переменными других
объектов.  На самом деле, взгляд, согласно которому система состоит
из отдельных объектов, полезнее всего в том случае, когда ее
можно разделить на несколько подсистем, в каждой из которых внутренние
связи сильнее, чем связи с другими подсистемами.

Такая точка зрения на систему может служить мощной парадигмой для
организации вычислительных моделей системы.  Чтобы такая
модель была модульной, ее требуется разделить на вычислительные
объекты, моделирующие реальные объекты системы.  Каждый вычислительный
объект должен содержать собственные
\index{ru}{внутренняя переменная состояния||local state variable|||}\index{en}{local state variable||внутренняя переменная состояния|||}{\em внутренние переменные
состояния} (local state variables), описывающие состояние реального объекта.  Поскольку
объекты в моделируемой системе меняются со временем, переменные
состояния соответствующих вычислительных объектов также должны
изменяться.  Если мы решаем, что поток времени в системе будет
моделироваться временем, проходящим в компьютере, то нам требуется
способ строить вычислительные объекты, поведение которых меняется
по мере выполнения программы.  В частности, если нам хочется
моделировать переменные состояния обыкновенными символическими именами
в языке программирования, в языке должен иметься
\index{ru}{оператор присваивания||assignment operator|||}\index{en}{assignment operator||оператор присваивания|||}{\em оператор присваивания} (assignment operator),
который позволял бы изменять значение, связанное с именем.

\subsection{Внутренние переменные состояния}
\label{LOCAL-STATE-VARIABLES}


\index{ru}{внутренняя переменная состояния|||||}
\index{ru}{переменная состояния|внутренняя||||}
Чтобы показать, что мы имеем в виду, говоря о
\index{ru}{объект(ы)|с состоянием, меняющимся во времени||||}
вычислительном объекте, состояние которого меняется со временем,
давайте промоделируем ситуацию снятия денег
с \index{ru}{банковский счет||bank account|||}\index{en}{bank account||банковский счет|||} банковского счета.
Воспользуемся для этого процедурой {\tt withdraw}, которая в
качестве аргумента принимает сумму, которую требуется снять.
Если на счету имеется достаточно средств, чтобы осуществить операцию, то
{\tt withdraw} возвращает баланс, остающийся после
снятия.  В противном случае {\tt withdraw} возвращает
сообщение <<Недостаточно денег на счете>>.  Например, если вначале на
счету содержится 100 долларов, мы получим следующую
последовательность результатов:

\begin{Verbatim}[fontsize=\small]
(withdraw 25)
\textit{75}

(withdraw 25)
\textit{50}

(withdraw 60)
\textit{"Недостаточно денег на счете"}

(withdraw 15)
\textit{35}
\end{Verbatim}

Обратите внимание, что выражение {\tt (withdraw 25)}, будучи
вычислено дважды, дает различные результаты.  Это новый тип поведения для
процедуры.  До сих пор все наши процедуры можно было рассматривать как
описания способов вычисления математических функций.  Вызов процедуры
вычислял значение функции для данных аргументов, и два
вызова одной и той же процедуры с одинаковыми аргументами всегда
приводили к одинаковому результату\footnote{На самом деле это не совсем правда.  Одно исключение~--- \index{ru}{random (элементарная процедура)|необходимость присваивания|||p|п}%
 \index{ru}{генератор  случайных чисел|||||п}генератор случайных чисел из
раздела~\ref{EXAMPLE-TESTING-FOR-PRIMALITY}. Второе связано с
\index{ru}{таблица операций и типов|необходимость     присваивания||||п}таблицами
операций и типов, которые мы ввели в
разделе~\ref{DATA-DIRECTED-PROGRAMMING-AND-ADDITIVITY}, где
значения двух вызовов {\tt get} с одними и теми же аргументами
зависели от того, какие были в промежутке между ними вызовы
{\tt put}.  С другой стороны, пока мы не ввели присваивание,
мы лишены возможности самим создавать такие процедуры.}.

При реализации {\tt withdraw} мы используем
переменную {\tt balance}, которая показывает остаток денег на
счете, и определяем {\tt withdraw} в виде процедуры, которая
обращается к этой переменной.  Процедура {\tt withdraw}
проверяет, что значение {\tt balance} не меньше, чем значение
аргумента {\tt amount}.  Если это так, {\tt withdraw}
уменьшает значение {\tt balance} на {\tt amount} и
возвращает новое значение {\tt balance}.  В противном случае
она возвращает сообщение <<Недостаточно денег на счете>>.  Вот
определения {\tt balance} и {\tt withdraw}:


\begin{Verbatim}[fontsize=\small]
(define balance 100)

(define (withdraw amount) \index{ru}{withdraw||||pd|}
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Недостаточно денег на счете"))
\end{Verbatim}

Значение переменной {\tt balance} уменьшается, когда мы
выполняем выражение


\begin{Verbatim}[fontsize=\small]
(set! balance (- balance amount))
\end{Verbatim}
Здесь используется особая форма  \index{ru}{set! (особая
  форма)||||p|}\index{ru}{особые формы|\texttt{set!}||||}{\tt set!},
синтаксис которой выглядит так:

\begin{Verbatim}[fontsize=\small]
(set! \textit{$\langle$имя$\rangle$} \textit{$\langle$новое-значение$\rangle$})
\end{Verbatim}
Здесь
\textit{$\langle$имя$\rangle$} ~--- символ, а   \textit{$\langle$новое-значение$\rangle$} --
произвольное выражение. {\tt Set!} заменяет значение
\textit{$\langle$имени$\rangle$} на результат,
полученный при вычислении \textit{$\langle$нового-значения$\rangle$}.  В данном
случае, мы изменяем {\tt balance} так, что его новое значение
будет результатом вычитания {\tt amount} из предыдущего
значения {\tt balance}\footnote{\index{ru}{set! (особая
    форма)|значение|||p|п}\index{ru}{неопределенные
    значения|\texttt{set!}||||п}Значение выражения {\tt set!} зависит
  от реализации. {\tt Set!} нужно использовать только ради
  эффекта, который оно оказывает, а  не ради значения, которое оно
  возвращает.

  \index{ru}{соглашение об именах|\texttt{!} для присваиваний и
    изменений|naming conventions|||п}\index{en}{naming
    conventions||соглашение об именах|\texttt{!} для присваиваний и
    изменений||п}Имя {\tt set!} отражает соглашение, принятое в
  Scheme: операциям, которые изменяют значения переменных (или структуры
  данных, как мы увидим в разделе~\ref{MODELING-WITH-MUTABLE-DATA})
  даются имена с восклицательным знаком на конце.  Это напоминает
  соглашение называть предикаты именами, которые оканчиваются на
  вопросительный знак.\index{ru}{!, в именах
    процедур||||p|п}\index{ru}{восклицательный знак, в именах
    процедур||exclamation
    point|||п}\index{en}{exclamation point||восклицательный знак, в
    именах процедур|||п}}.

Кроме того, {\tt withdraw} использует особую форму
\index{ru}{особые формы|\texttt{begin}||||}{\tt begin},
когда проверка {\tt if} выдает истину, и требуется вычислить два
выражения: сначала уменьшить
{\tt balance}, а затем вернуть его значение.  В общем случае
вычисление выражения

\begin{Verbatim}[fontsize=\small]
(begin \textit{$\langle$выражение${}_{\mbox{1}}$$\rangle$} \textit{$\langle$выражение${}_{\mbox{2}}$$\rangle$} ... \textit{$\langle$выражение${}_{\mbox{k}}$$\rangle$})
\end{Verbatim}
приводит к последовательному вычислению выражений от
\textit{$\langle$выражения${}_{\mbox{1}}$$\rangle$} до
\textit{$\langle$выражения${}_{\mbox{k}}$$\rangle$}, и значение
последнего выражения
\textit{$\langle$выражение${}_{\mbox{k}}$$\rangle$} возвращается в
качестве значения всей формы
{\tt begin}\footnote{Неявно мы уже использовали в своих программах
{\tt begin}, поскольку в Scheme тело процедуры может быть
последовательностью выражений.  Кроме того, в каждом подвыражении
{\tt cond} следствие может состоять не
\index{ru}{cond (особая форма)|неявный \texttt{begin} в следствиях|||p|п}
\index{ru}{процедура|неявный \texttt{begin} в теле||||п}
из одного выражения, а из нескольких.}.

Хотя процедура {\tt withdraw} и работает так, как мы
того хотели, переменная {\tt balance} представляет собой
проблему.  {\tt Balance}, как она описана выше, является
переменной, определенной в глобальном окружении, и любая процедура может
прочитать или изменить ее значение.  Намного лучше было бы,
если бы {\tt balance} можно было сделать внутренней
переменной для {\tt withdraw}, так, чтобы только
{\tt withdraw} имела доступ к ней напрямую, а любая
другая процедура~--- только посредством вызовов {\tt withdraw}.
Так можно будет более точно смоделировать представление о
{\tt balance} как о внутренней переменной состояния, с помощью
которой {\tt withdraw} следит за состоянием
счета.

Сделать {\tt balance} внутренней по отношению к
{\tt withdraw} мы можем, переписав определение следующим
образом:

\begin{Verbatim}[fontsize=\small]
(define new-withdraw\index{ru}{new-withdraw||||pd|}
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))))
\end{Verbatim}
Здесь мы, используя {\tt let}, создаем окружение с внутренней
переменной {\tt ba\-lance}, которой вначале присваивается
значение 100.  Внутри этого локального окружения мы при помощи
{\tt lambda} определяем процедуру, которая берет в
качестве аргумента {\tt amount} и действует так же, как наша
старая процедура {\tt withdraw}.  Эта процедура ---
возвращаемая как результат выражения
{\tt let}, --- и есть {\tt new-withdraw}. Она ведет
себя в точности так же, как, как {\tt withdraw}, но ее
переменная {\tt balance} недоступна для всех остальных
процедур\footnote{По терминологии, принятой при описании языков программирования,
переменная {\tt balance}
\index{ru}{инкапсулированное имя||encapsulated     name|||п}%
\index{en}{encapsulated     name||инкапсулированное имя|||п}%
\index{ru}{имя|инкапсулированное||||п}%
\index{ru}{инкапсуляция||encapsulation|||п}%
\index{en}{encapsulation||инкапсуляция|||п}%
{\em инкапсулируется} (is encapsulated) внутри процедуры
{\tt new-withdraw}.  Инкапсуляция отражает общий принцип
проектирования систем, известный как
\index{ru}{модульность|принцип сокрытия||||п}%
\index{ru}{сокрытия принцип||hiding principle|||п}%
\index{en}{hiding principle||сокрытия принцип|||п}{\em принцип сокрытия} (the hiding principle): систему можно
сделать более модульной и надежной, если защищать ее части друг
от друга; то есть, разрешать доступ к информации только тем частям
системы, которым <<необходимо это знать>>.}.

{\tt Set!} в сочетании с локальными
переменными --- общая стратегия программирования, которую мы будем
использовать для построения вычислительных объектов, обладающих
внутренним состоянием.  К сожалению, при использовании этой стратегии
возникает серьезная проблема: когда мы только вводили понятие процедуры, мы
ввели также подстановочную модель вычислений
(раздел~\ref{SUBST-MODEL-FOR-PROC-APPL}) для того, чтобы
объяснить, что означает применение процедуры к аргументам.  Мы
сказали, что оно должно интерпретироваться как вычисление тела
процедуры, в котором формальные параметры заменяются на свои
значения.  К сожалению, как только мы вводим в язык присваивание,
подстановка перестает быть адекватной моделью применения
процедуры. (Почему это так, мы поймем в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}.)  В
результате,
с технической точки зрения мы сейчас не умеем объяснить, почему
процедура {\tt new-withdraw} ведет себя именно так, как описано
выше.  Чтобы действительно понять процедуры, подобные
{\tt new-withdraw}, нам придется разработать новую модель
применения процедуры.  В
разделе~\ref{THE-ENVIRONMENT-MODEL-OF-EVALUATION} мы введем такую
модель, попутно объяснив {\tt set!} и локальные
переменные.  Однако сначала мы рассмотрим некоторые вариации на тему,
заданную {\tt new-withdraw}.

Следующая процедура, {\tt make-withdraw}, создает
<<обработчики снятия денег со счетов>>.  Формальный параметр
{\tt balance}, передаваемый в {\tt make-withdraw},
указывает начальную сумму денег на счету\footnote{В отличие от предыдущей процедуры
{\tt new-withdraw}, здесь нам необязательно использовать
{\tt let},
чтобы сделать {\tt balance} локальной переменной, поскольку
формальные параметры и так локальны.  Это станет яснее после
обсуждения модели вычисления с окружениями в
разделе~\ref{THE-ENVIRONMENT-MODEL-OF-EVALUATION}. (См.
также упражнение~\ref{EX3.10}.)}.
{\sloppy

}

\begin{Verbatim}[fontsize=\small]
(define (make-withdraw balance)\index{ru}{make-withdraw||||pd|}
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете")))
\end{Verbatim}
При помощи {\tt make-withdraw} можно следующим образом создать
два объекта {\tt W1} и {\tt W2}:

\begin{Verbatim}[fontsize=\small]
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
\textit{50}

(W2 70)
\textit{30}

(W2 40)
\textit{"Недостаточно денег на счете" }

(W1 40)
\textit{10}
\end{Verbatim}
Обратите внимание, что
{\tt W1} и {\tt W2}~--- полностью независимые объекты,
каждый со своей локальной переменной {\tt balance}.  Снятие
денег с одного счета не влияет на другой.

Мы можем создавать объекты, которые будут разрешать не только
снятие денег, но и их занесение на счет, и таким образом можно
смоделировать простые банковские счета.  Вот процедура, которая
возвращает объект-<<банковский счет>> с указанным начальным балансом:

\begin{Verbatim}[fontsize=\small]
(define (make-account balance)\index{ru}{make-account||||pd|}
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)\index{ru}{deposit (сообщение для банковского счета)||||pd|}
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                       m))))
  dispatch)
\end{Verbatim}
Каждый вызов
{\tt make-account} создает окружение с локальной переменной
состояния {\tt balance}.  Внутри этого окружения
{\tt make-account} определяет процедуры {\tt deposit} и
{\tt withdraw}, которые обращаются к {\tt balance}, а
также дополнительную процедуру {\tt dispatch}, которая
принимает <<сообщение>> в качестве ввода, и возвращает одну из двух
локальных процедур.  Сама процедура {\tt dispatch} возвращается
как значение, которое представляет объект-банковский счет.  Это не что
иное, как стиль программирования с
\index{ru}{передача сообщений|в банковском счете||||}
\index{ru}{передача сообщений||message passing|||}\index{en}{message passing||передача сообщений|||}{\em передачей сообщений} (message passing), который мы видели в
разделе~\ref{DATA-DIRECTED-PROGRAMMING-AND-ADDITIVITY}, но только
здесь мы его используем в сочетании с возможностью изменять локальные
переменные.

{\tt Make-account} можно использовать следующим
образом:

\begin{Verbatim}[fontsize=\small]
(define acc (make-account 100))

((acc 'withdraw) 50)
\textit{50}

((acc 'withdraw) 60)
\textit{"Недостаточно денег на счете" }

((acc 'deposit) 40)
\textit{90}

((acc 'withdraw) 60)
\textit{30}
\end{Verbatim}
Каждый вызов {\tt acc} возвращает локально определенную процедуру
{\tt deposit} или {\tt withdraw}, которая затем
применяется к указанной сумме.  Точно так же, как это было с
{\tt make-withdraw}, второй вызов {\tt make-account}

\begin{Verbatim}[fontsize=\small]
(define acc2 (make-account 100))
\end{Verbatim}
создает совершенно отдельный объект-счет, который поддерживает свою
собственную переменную {\tt balance}.
\begin{exercise}{3.1}\label{EX3.1}%
\index{ru}{накопитель||accumulator|||(упр.~3.1)}%
\index{en}{accumulator||накопитель|||(упр.~3.1)}%
{\em Накопитель} (accumulator)~--- это
процедура, которая вызывается с одним численным аргументом и собирает
свои аргументы в сумму.  При каждом вызове накопитель возвращает
сумму, которую успел накопить.  Напишите процедуру
{\tt make-accumulator},
\index{ru}{make-accumulator||||p|(упр.~3.1)}
порождающую накопители, каждый
из которых поддерживает свою отдельную сумму.  Входной параметр
{\tt make-accumulator} должен указывать начальное значение
суммы; например,

\begin{Verbatim}[fontsize=\small]
(define A (make-accumulator 5))

(A 10)
\textit{15}

(A 10)
\textit{25}
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.2}\label{EX3.2}%
При тестировании программ удобно иметь
возможность подсчитывать, сколько раз за время вычислений была вызвана
та или иная процедура.\index{ru}{отслеживаемая процедура||monitored procedure|||(упр.~3.2)}%
\index{en}{monitored procedure||отслеживаемая процедура|||(упр.~3.2)}%
\index{ru}{процедура|отслеживаемая||||(упр.~3.2)} Напишите процедуру {\tt make-monitored},\index{ru}{make-monitored||||p|(упр.~3.2)} принимающую в качестве параметра процедуру {\tt f}, которая сама
по себе принимает один входной параметр.  Результат, возвращаемый
{\tt make-monitored}~--- третья процедура, назовем ее
{\tt mf}, которая подсчитывает, сколько раз она была вызвана,
при помощи внутреннего счетчика.  Если на входе {\tt mf}
получает специальный символ {\tt how-many-calls?}, она
возвращает значение счетчика.  Если же на вход подается специальный
символ {\tt reset-count}, {\tt mf} обнуляет счетчик.
Для любого другого параметра {\tt mf} возвращает результат
вызова {\tt f} с этим параметром и увеличивает счетчик.
Например, можно было бы сделать отслеживаемую версию процедуры
{\tt sqrt}:

\begin{Verbatim}[fontsize=\small]
(define s (make-monitored sqrt))

(s 100)
\textit{10}

(s 'how-many-calls?)
\textit{1}
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.3}\label{EX3.3}%
Измените процедуру {\tt make-account} так,
чтобы она создавала
\index{ru}{банковский счет|защищенный паролем||||(упр.~3.3)}%
\index{ru}{защищенный паролем банковский счет||password-protected bank account|||(упр.~3.3)}%
\index{en}{password-protected bank account||защищенный паролем банковский счет|||(упр.~3.3)}%
счета, защищенные паролем.  А именно,
{\tt make-account} должна
в качестве дополнительного аргумента принимать символ, например\-

\begin{Verbatim}[fontsize=\small]
(define acc (make-account 100 'secret-password))
\end{Verbatim}
Получившийся объект-счет должен обрабатывать запросы, только если они
сопровождаются паролем, с которым счет был создан, а в противном
случае он должен жаловаться:

\begin{Verbatim}[fontsize=\small]
((acc 'secret-password 'withdraw) 40)
\textit{60}

((acc 'some-other-password 'deposit) 50)
\textit{"Неверный пароль" }
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.4}\label{EX3.4}%
Модифицируйте процедуру {\tt make-account} из
упражнения~\ref{EX3.3}, добавив еще одну локальную
переменную, так, чтобы, если происходит более семи попыток доступа подряд
с неверным паролем, вызывалась процедура {\tt call-the-cops}
(вызвать полицию).
\end{exercise}

\subsection{Преимущества
присваивания}
\label{THE-BENEFITS-OF-INTRODUCING-ASSIGNMENT}

\index{ru}{присваивание|преимущества||||}
Как нам предстоит увидеть, введение присваивания в наш язык
программирования ведет  к множеству сложных концептуальных проблем.
\index{ru}{модульность|через моделирование объектов||||}
\index{ru}{объект(ы)|преимущества введения в  моделирование||||}Тем не менее, представление о системе как о наборе объектов, имеющих
внутреннее состояние,~--- мощное средство для обеспечения модульности
проекта.  В качестве примера рассмотрим строение процедуры
{\tt rand}, которая, будучи вызванной, каждый раз возвращает
случайное целое число.

Вовсе не так просто определить, что значит <<случайное>>.
Вероятно, имеется в виду, что последовательные обращения к
{\tt rand} должны  \index{ru}{генератор случайных чисел|||||}порождать последовательность чисел, которая
обладает статистическими свойствами равномерного распределения.  Здесь
мы не будем обсуждать способы порождения подобных последовательностей.
Вместо этого предположим, что у нас есть процедура
{\tt rand-update}, которая обладает следующим свойством: если мы
начинаем с некоторого данного числа
$x_1$ и строим
последовательность
$$
\begin{array}{l}
x_2 = \mbox{\tt(rand-update $x_1$)}\\
x_3 = \mbox{\tt(rand-update $x_2$)}
\end{array}
$$
то последовательность величин
$x_1, x_2, x_3\ldots$
будет обладать требуемыми математическими свойствами\footnote{Один из распространенных способов реализации
  {\tt rand-update} состоит в том, чтобы положить новое значение
  $x$ равным $ax+b \mathop{\rm mod}
  m$, где $a$, $b$ и
  $m$~--- соответствующим образом подобранные целые
  числа.  Глава~3 книги Knuth 1981\index{ru}{Кнут,
    Дональд~Э.||Donald~E. Knuth||n|п}\index{en}{Donald~E. Knuth||Кнут,
    Дональд~Э.||n|п}
  содержит подробное обсуждение методов порождения последовательностей
  случайных чисел и обеспечения их статистических свойств.  Обратите
  внимание, что {\tt rand-update} вычисляет математическую
  функцию: если ей дважды дать один и тот же вход, она вернет одинаковый
  результат.  Таким образом, последовательность чисел, порождаемая
  {\tt rand-update}, никоим образом не <<случайна>>, если мы
  настаиваем на том, что в последовательности <<случайных>> чисел
  следующее число не должно иметь никакого отношения к предыдущему.
  Отношение между <<настоящей>> случайностью и так называемыми
  \index{ru}{псевдослучайная последовательность чисел||pseudo-random
    sequence|||п}\index{en}{pseudo-random
    sequence||псевдослучайная последовательность чисел|||п}{\em
    псевдослучайными} (pseudo-random) последовательностями, которые
  порождаются путем однозначно определенных вычислений и тем не менее
  обладают нужными статистическими свойствами, --- непростой вопрос,
  связанный со сложными проблемами математики и философии.  Для
  прояснения этих вопросов много сделали Колмогоров, Соломонофф и Хайтин;
  обсуждение можно найти в Chaitin
  1975.\index{ru}{Колмогоров,~А.Н.||||n|п}\index{ru}{Хайтин,
    Грегори||Gregory Chaitin||n|п}\index{en}{Gregory Chaitin||Хайтин,
    Грегори||n|п}\index{ru}{Соломонофф, Рэй||Ray
    Solomonoff||n|п}\index{en}{Ray Solomonoff||Соломонофф, Рэй||n|п}}.

Мы можем реализовать {\tt rand} как процедуру с
внутренней переменной состояния {\tt x}, которая
инициализируется некоторым заранее заданным значением
{\tt random-init}.  Каждый вызов {\tt rand} вычисляет
{\tt rand-update} от текущего значения {\tt x},
возвращает это значение как случайное число, и, кроме того, сохраняет
его как новое значение {\tt x}.

\begin{Verbatim}[fontsize=\small]
(define rand \index{ru}{rand||||pd|}
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
\end{Verbatim}

Разумеется, ту же последовательность случайных чисел мы
могли бы получить без использования присваивания, просто напрямую
вызывая {\tt rand-up\-date}.  Однако это означало бы, что всякая
часть программы, которая использует случайные числа, должна явно
запоминать текущее значение {\tt x}, чтобы передать его как
аргумент {\tt rand-update}.  \index{ru}{генератор случайных  чисел|в моделировании методом Монте-Карло||||}
Чтобы понять, насколько это было бы
неприятно, рассмотрим использование случайных чисел для реализации
т.~н.
\index{ru}{моделирование методом Монте-Карло||Monte Carlo simulation|||}\index{en}{Monte Carlo simulation||моделирование методом Монте-Карло|||}{\em моделирования методом
Монте-Карло} (Monte Carlo simulation).

Метод Монте-Карло состоит в том, чтобы случайным образом
выбирать тестовые точки из большого множества и затем делать выводы на
основании вероятностей, оцениваемых по результатам тестов.  Например,
можно получить \index{ru}{пи ($\pi$)|оценка Чезаро||||} приближенное значение $\pi$,
используя тот факт, что для двух случайно выбранных
целых чисел вероятность отсутствия общих множителей (то есть,
вероятность того, что их наибольший
общий делитель будет равен 1) составляет
$6/\pi^2$\footnote{Эта теорема доказана Э. Чезаро.  Обсуждение и
  доказательство можно найти в разделе~4.5.2 книги
  Knuth 1981.\index{ru}{Кнут,
    Дональд~Э.||Donald~E. Knuth||n|п}\index{en}{Donald~E. Knuth||Кнут,
    Дональд~Э.||n|п}\index{ru}{Чезаро, Эрнесто||Ernesto
    Ces\`aro||n|п}\index{en}{Ernesto Ces\`aro||Чезаро, Эрнесто||n|п}}.
Чтобы получить приближенное значение
$\pi$, мы производим большое количество тестов.
В каждом тесте мы случайным образом выбираем два числа и проверяем, не
равен ли их НОД единице.  Доля тестов, которые проходят, дает нам
\index{ru}{наибольший общий делитель|используемый для оценки $\pi$||||}
приближение к $6/\pi^2$, и отсюда мы получаем
приближенное значение $\pi$.

В центре нашей программы находится процедура
{\tt monte-carlo}, которая в качестве аргументов принимает
количество попыток тестирования, а также сам тест~---
процедуру без аргументов, возвращающую при каждом
вызове либо истину, либо ложь.  {\tt Monte-carlo} запускает
тест указанное количество раз и возвращает число, обозначающее долю
попыток, в которых тест вернул истинное значение.

\begin{Verbatim}[fontsize=\small]
(define (estimate-pi trials)\index{ru}{estimate-pi||||pd|}
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))

(define (cesaro-test)\index{ru}{cesaro-test||||pd|}
   (= (gcd (rand) (rand)) 1))

(define (monte-carlo trials experiment)\index{ru}{monte-carlo||||pd|}
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
\end{Verbatim}

Теперь попробуем осуществить то же вычисление, используя
{\tt rand-update} вместо {\tt rand}, как нам
пришлось бы поступить, если бы у нас не было присваивания для
моделирования локального состояния:

\begin{Verbatim}[fontsize=\small]
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))

(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
\end{Verbatim}

Хотя программа по-прежнему проста, в ней обнаруживается несколько
болезненных нарушений принципа модульности.  В первой версии программы
нам удалось, используя {\tt rand}, выразить метод Монте-Карло
напрямую как обобщенную процедуру
{\tt monte-carlo}, которая в качестве аргумента принимает
произвольную процедуру {\tt experiment}.  Во втором варианте
программы, где у генератора случайных чисел нет локального состояния,
{\tt random-gcd-test} приходится непосредственно возиться со случайными
числами {\tt x1} и {\tt x2} и передавать в итеративном
цикле {\tt x2} в качестве нового входа
{\tt rand-update}.  Из-за того, что обработка случайных чисел
происходит явно, структура накопления результатов тестов начинает
зависеть от того, что наш тест использует именно два случайных числа,
тогда как для других тестов Монте-Карло может потребоваться, скажем, одно или три.
Даже процедура верхнего уровня {\tt estimate-pi} вынуждена
заботиться о том, чтобы предоставить начальное значение случайного
числа.  Поскольку внутренности генератора случайных чисел просачиваются
наружу в другие части программы, задача изолировать
идею метода Монте-Карло так, чтобы применять ее затем к другим
задачам, осложняется.  В первом варианте программы присваивание инкапсулирует
состояние генератора случайных чисел внутри
{\tt rand}, так что состояние генератора остается независимым
от остальной программы.

Общее явление, наблюдаемое на примере с методом
Монте-Карло, таково: с точки зрения одной части сложного процесса
кажется, что другие части \mbox{изменяются} со временем.  Они обладают
скрытым локальным состоянием.  Если мы хотим, чтобы структура
программ, которые мы пишем, отражала
такое разделение на части, мы создаем вычислительные объекты
(например, банковские счета или генераторы случайных чисел), поведение
которых изменяется со временем.  Состояние мы моделируем при помощи
локальных переменных, а изменение состояния --- при помощи присваивания
этим переменным.

Здесь возникает соблазн закрыть обсуждение и сказать, что, введя
присваивание и метод сокрытия состояния в локальных переменных, мы
обретаем способность структурировать системы более модульным образом,
чем если бы нам пришлось всем состоянием манипулировать явно,
с передачей дополнительных параметров.  К сожалению, как мы увидим, все
не так просто.

\begin{exercise}{3.5}\label{EX3.5}%
\index{ru}{Монте-Карло, интегрирование методом||Monte Carlo integration|||(упр.~3.5)}%
\index{en}{Monte Carlo integration||Монте-Карло, интегрировани методом|||(упр.~3.5)}%
\index{ru}{пи ($\pi$)|приближенное вычисление через интегрирование методом Монте-Карло||||(упр.~3.5)}%
{\em Интегрирование методом
Монте-Карло} (Monte Carlo integration)~--- способ приближенного
вычисления \index{ru}{определенный интеграл|приближенное вычисление
  методом Монте-Карло||||(упр.~3.5)}определенных интегралов при помощи
моделирования методом Монте-Карло.  Рассмотрим
задачу вычисления площади фигуры, описываемой предикатом
$P(x,y)$, который истинен для точек
$(x,y)$, принадлежащих фигуре, и ложен для
точек вне фигуры.  Например, область, содержащаяся в круге с радиусом
3 и центром в точке $(5,7)$, описывается предикатом, проверяющим
$(x-5)^2 + (y-7)^2 \le 3^2$.  Чтобы оценить
площадь фигуры, описываемой таким предикатом, для начала выберем
прямоугольник, который содержит нашу фигуру.  Например, прямоугольник
с углами $(2,4)$ и $(8,10)$, расположенными по диагонали, содержит
вышеописанный круг.  Нужный нам интеграл~--- площадь той части
прямоугольника, которая лежит внутри фигуры.  Мы можем оценить
интеграл, случайным образом выбирая точки
$(x,y)$, лежащие внутри прямоугольника, и
проверяя для каждой точки $P(x,y)$, чтобы
определить, лежит ли точка внутри фигуры.  Если мы проверим много
точек, доля тех, которые окажутся внутри области, даст нам
приближенное значение отношения площадей фигуры и прямоугольника.
Таким образом, домножив это значение на площадь прямоугольника, мы
получим приближенное значение интеграла.

Реализуйте интегрирование методом Монте-Карло в виде
процедуры {\tt estimate\-integral},\index{ru}{estimate-integral||||p|(упр.~3.5)}
которая в качестве
аргументов принимает предикат {\tt P}, верхнюю и нижнюю границы
прямоугольника {\tt x1}, {\tt x2}, {\tt y1}
и {\tt y2}, а также число
проверок, которые мы должны осуществить, чтобы оценить отношение
площадей.  Ваша процедура должна использовать ту же самую процедуру
{\tt monte-carlo}, которая выше использовалась для оценки
значения $\pi$.  Оцените $\pi$ при помощи
{\tt estimate-integral}, измерив площадь единичного круга.\index{ru}{пи ($\pi$)|аппроксимация через интегрирование методом Монте-Карло||||(упр.~3.5)}

Вам может пригодиться процедура, которая выдает
число, случайно выбранное внутри данного отрезка.  Нижеприведенная
процедура {\tt random-in-range} решает эту задачу, используя
процедуру {\tt random}, введенную в
разделе~\ref{EXAMPLE-TESTING-FOR-PRIMALITY}, которая возвращает
неотрицательное число меньше своего аргумента\footnote{\index{ru}{MIT
    Scheme|\texttt{random}||||п}\index{ru}{элементарные процедуры|{\tt
      random} {\em (нс)}||||п}\index{ru}{random (элементарная
    процедура)|MIT Scheme|||p|п}В MIT Scheme есть такая процедура.
  Если {\tt random} на вход дается точное целое число (как в
  разделе~\ref{EXAMPLE-TESTING-FOR-PRIMALITY}), она возвращает
  точное целое число, но если ей дать десятичную дробь (как в этом
  примере), она и возвращает десятичную дробь.}.

\begin{Verbatim}[fontsize=\small]
(define (random-in-range low high) \index{ru}{random-in-range||||pd|(упр.~3.5)}
  (let ((range (- high low)))
    (+ low (random range))))
\end{Verbatim}
\end{exercise}

\begin{exercise}{3.6}\label{EX3.6}%
\index{ru}{rand|со сбрасыванием|||p|(упр.~3.6)}%
\index{ru}{генератор случайных  чисел|со сбрасыванием||||(упр.~3.6)}%
Полезно иметь
возможность сбросить генератор случайных
чисел, чтобы получить последовательность, которая начинается с некоторого
числа.  Постройте новую процедуру {\tt rand}, которая
вызывается с аргументом.  Этот аргумент должен быть либо символом
{\tt generate}, либо символом {\tt reset}.  Процедура
работает так: {\tt (rand 'generate)} порождает новое случайное
число; {\tt ((rand 'reset) \textit{$\langle$новое-значение$\rangle$})}
сбрасывает внутреннюю переменную состояния в указанное
\textit{$\langle$новое-значение$\rangle$}. Таким образом, сбрасывая значения,
можно получать повторяющиеся последовательности.  Эта возможность
очень полезна при тестировании и отладке программ,
использующих случайные числа.
\end{exercise}


\subsection{Издержки, связанные с введением присваивания}
\label{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}


Как мы только что видели, операция
{\tt set!} позволяет моделировать объекты, обладающие
внутренним состоянием.  Однако за это преимущество приходится
\index{ru}{присваивание|расплата за||||} платить.
Наш язык программирования нельзя больше описывать при помощи
подстановочной модели применения процедур, которую мы ввели в
разделе~\ref{SUBST-MODEL-FOR-PROC-APPL}.  Хуже того, не существует
простой модели с <<приятными>> математическими свойствами, которая бы
адекватно описывала работу с объектами и присваивание в
языках программирования.

Пока мы не применяем присваивание, два вычисления одной и
той же процедуры с одними и теми же аргументами всегда дают одинаковый
результат. Стало быть, можно считать, что процедуры вычисляют
математические функции.  Соответственно, программирование, в котором
присваивание не используется (как у нас в первых
двух главах этой книги), известно как
\index{ru}{функциональное программирование||functional programming|||}\index{en}{functional programming||функциональное программирование|||}{\em функциональное
программирование} (functional programming).

 \index{ru}{подстановочная модель применения процедуры|неадекватность||||} Чтобы понять, как присваивание усложняет ситуацию,
рассмотрим упрощенную версию {\tt make-withdraw} из
раздела~\ref{LOCAL-STATE-VARIABLES}, которая не проверяет,
достаточно ли на счете денег:

\begin{Verbatim}[fontsize=\small]
(define (make-simplified-withdraw balance)\index{ru}{make-simplified-withdraw||||pd|}
  (lambda (amount)
    (set! balance (- balance amount))
    balance))

(define W (make-simplified-withdraw 25))

(W 20)
\textit{5}

(W 10)
\textit{-5}
\end{Verbatim}
Сравним эту процедуру со следующей процедурой
{\tt make-decrementer}, которая не использует
{\tt set!}:

\begin{Verbatim}[fontsize=\small]
(define (make-decrementer balance)\index{ru}{make-decrementer||||pd|}
  (lambda (amount)
    (- balance amount)))
\end{Verbatim}
{\tt make-decrementer} возвращает процедуру, которая вычитает
свой аргумент из определенного числа {\tt balance}, но при
последовательных вызовах ее действие не накапливается, как при
использовании {\tt make\--simpli\-fied\--with\-draw}:

\begin{Verbatim}[fontsize=\small]
(define D (make-decrementer 25))

(D 20)
\textit{5}

(D 10)
\textit{15}
\end{Verbatim}
Мы можем объяснить, как работает {\tt make-decrementer}, при
помощи подстановочной модели.  Например, рассмотрим, как вычисляется
выражение

\begin{Verbatim}[fontsize=\small]
((make-decrementer 25) 20)
\end{Verbatim}
Сначала мы упрощаем операторную часть комбинации, подставляя в теле
{\tt make-decrementer} вместо {\tt balance} 25.
Выражение сводится к

\begin{Verbatim}[fontsize=\small]
((lambda (amount) (- 25 amount)) 20)
\end{Verbatim}
Теперь мы применяем оператор к операнду, подставляя 20 вместо
{\tt amount} в теле {\tt lambda}-выра\-же\-ния:

\begin{Verbatim}[fontsize=\small]
(- 25 20)
\end{Verbatim}
Окончательный результат равен 5.

Посмотрим, однако, что произойдет, если мы попробуем
применить подобный подстановочный анализ к
{\tt make-sim\-pli\-fied-withdraw}:
\sloppy

\begin{Verbatim}[fontsize=\small]
((make-simplified-withdraw 25) 20)
\end{Verbatim}
Сначала мы упрощаем оператор, подставляя вместо {\tt balance}
25 в теле {\tt make\-simplified-withdraw}.  Таким образом, наше
выражение сводится к\footnote{Мы не производим подстановку вхождения
{\tt balance} в выражение {\tt set!}, поскольку
\textit{$\langle$имя$\rangle$} в {\tt set!} не вычисляется.  Если бы мы
провели подстановку, получилось бы {\tt (set! 25 (- 25
amount))}, а это не имеет никакого смысла.}

\begin{Verbatim}[fontsize=\small]
((lambda (amount) (set! balance (- 25 amount)) 25) 20)
\end{Verbatim}
Теперь мы применяем оператор к операнду, подставляя в теле
{\tt lambda}-вы\-ра\-же\-ния 20 вместо {\tt amount}:

\begin{Verbatim}[fontsize=\small]
(set! balance (- 25 20)) 25
\end{Verbatim}
Если бы мы следовали подстановочной модели, нам пришлось бы сказать,
что вычисление процедуры состоит в том, чтобы сначала присвоить
переменной {\tt balance} значение 5, а затем в качестве
значения вернуть 25.  Но это дает неверный ответ.  Чтобы получить
правильный ответ, нам пришлось бы как-то отличить первое вхождение
{\tt balance} (до того, как сработает {\tt set!})
от второго (после выполнения {\tt set!}).
Подстановочная модель на это не способна.

Проблема здесь состоит в том, что подстановка предполагает,
что символы в нашем языке --- просто имена для значений.  Но как только
мы вводим {\tt set!} и представление, что значение переменной
может изменяться, переменная уже не может быть всего лишь именем.
Теперь переменная некоторым образом соответствует месту, в котором
может храниться значение, и значение это может меняться.  В
разделе~\ref{THE-ENVIRONMENT-MODEL-OF-EVALUATION} мы
увидим, как в нашей модели вычислений роль этого <<места>> играют
окружения.

\paragraph{Тождественность и изменение}


\index{ru}{тождественность и изменение|значение|sameness and
  change|||}\index{en}{sameness and    change||тождественность и
  изменение|значение||}\index{ru}{изменение и
  тождественность|значение|change and sameness|||}\index{en}{change
  and sameness||изменение и тождественность|значение||}Проблема,
который здесь встает, глубже, чем просто
поломка определенной модели вычислений.  Как только мы вводим в наши
вычислительные модели понятие изменения, многие другие понятия,
которые до сих пор были ясны, становятся сомнительными.  Рассмотрим
вопрос, что значит, что две вещи суть <<одно и то же>>.

Допустим, мы два раза зовем {\tt make-decrementer}
с одним и тем же аргументом, и получаем две процедуры:

\begin{Verbatim}[fontsize=\small]
(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))
\end{Verbatim}
Являются ли {\tt D1} и {\tt D2} одним и тем же объектом?
Можно сказать, что да, поскольку {\tt D1} и {\tt D2}
обладают одинаковым поведением~--- каждая из этих процедур вычитает
свой аргумент из 25.  В сущности, в любом вычислении можно подставить
{\tt D1} вместо {\tt D2}, и результат не изменится.

Напротив, рассмотрим два вызова
{\tt make-simplified-withdraw}:

\begin{Verbatim}[fontsize=\small]
(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))
\end{Verbatim}
Являются ли {\tt W1} и {\tt W2} одним и тем же?  Нет,
конечно, потому что вызовы {\tt W1} и {\tt W2} приводят
к различным результатам, как показывает следующая последовательность
вычислений:

\begin{Verbatim}[fontsize=\small]
(W1 20)
\textit{5}

(W1 20)
\textit{-15}

(W2 20)
\textit{5}
\end{Verbatim}
Хотя
{\tt W1} и {\tt W2} <<равны друг другу>> в том смысле, что
оба они созданы вычислением одного и того же выражения
{\tt (make-simplified-withdraw 25)}, неверно, что в любом
выражении можно заменить {\tt W1} на {\tt W2}, не
повлияв при этом на результат его вычисления.

Язык, соблюдающий правило, что в любом выражении <<одинаковое
можно подставить вместо одинакового>>, не меняя его значения,
называется \index{ru}{равенство|и референциальная
  прозрачность||||}\index{ru}{референциальная
  прозрачность|||||}\index{ru}{прозрачность
  референциальная|||||}\index{ru}{референциальная
  прозрачность||referential transparency|||}\index{en}{referential
  transparency||референциальная прозрачность|||}{\em референциально
  прозрачным} (referentially transparent).  Если мы
включаем в свой компьютерный язык {\tt set!}, его
референциальная прозрачность нарушается.  Становится сложно
определить, где можно упростить выражение, подставив вместо него
равносильное.  Следовательно, рассуждать о программах, в которых используется
присваивание, оказывается гораздо сложнее.

С потерей референциальной прозрачности
становится сложно формально описать понятие о том, что два объекта --
один и тот же объект.  На самом деле, смысл выражения <<то же самое>> в
реальном мире, который наши программы моделируют, сам по себе
недостаточно ясен.  В общем случае, мы можем проверить, являются ли
два как будто бы одинаковых объекта одним и тем же, только изменяя один из них
и наблюдая, изменился ли таким же образом и другой.  Но как мы можем
узнать, <<изменился>> ли объект? Только рассмотрев один и тот
же объект дважды и проверив, не различается ли некоторое его свойство между
двумя наблюдениями.  Таким образом, мы не можем определить <<изменение>>, не имея
заранее понятия <<идентичности>>, а идентичность мы не можем
определить, не рассмотрев результаты изменений.

В качестве примера того, как эти вопросы возникают в
программировании, рассмотрим ситуацию, где у Петра и у Павла есть по
банковскому счету в 100 долларов.  Здесь не все равно, смоделируем мы это
через

\begin{Verbatim}[fontsize=\small]
(define peter-acc (make-account 100))
(define paul-acc (make-account 100))
\end{Verbatim}
или

\begin{Verbatim}[fontsize=\small]
(define peter-acc (make-account 100))
(define paul-acc peter-acc)
\end{Verbatim}
В первом случае, два счета различны. Действия, которые производит
Петр, не меняют счет Павла, и наоборот.  Однако во втором случае мы
сказали, что {\tt paul-acc} --- это {\em та же самая
вещь}, что и {\tt peter-acc}.  Теперь у Петра и у Павла
есть  \index{ru}{банковский счет|совместный||||}совместный
банковский счет, и если Петр возьмет сколько-то с
{\tt peter-acc}, то у Павла на
{\tt paul-acc} будет меньше денег.  При построении вычислительных моделей сходство
между этими двумя несовпадающими ситуациями может привести к путанице.  В
частности, в случае с совместным счетом может особенно мешать то,
что у одного объекта (банковского счета) есть два имени
({\tt peter-acc} и {\tt paul-acc});  если мы ищем в
программе все места, где может меняться {\tt paul-acc}, надо
смотреть еще и где меняется {\tt peter-acc}\footnote{Когда у вычислительного объекта имеется
  несколько имён, эти имена называются
  \index{ru}{псевдоним||aliasing|||п}\index{en}{aliasing||псевдоним|||п}{\em псевдонимами} (aliasing). Ситуация с совместным
  банковским счетом --- простой пример псевдонимов.  В
  разделе~\ref{MODELING-WITH-MUTABLE-DATA} мы увидим значительно
  более сложные примеры, скажем, <<различные>> составные структуры с
  общими частями.  Если мы забудем, что <<побочным эффектом>> в
  результате изменения одного объекта может  стать изменение <<другого>>
  объекта, поскольку
  <<разные>> объекты~--- на самом деле один и тот же под разными
  псевдонимами, то могут возникнуть
  \index{ru}{присваивание|вызванные ошибки||||п}ошибки.  Эти
  так называемые
  \index{ru}{ошибка|побочного эффекта|side-effect
    bug|||п}\index{en}{side-effect bug||ошибка|побочного
    эффекта||п}{\em ошибки побочных эффектов} (side-effect bugs)
  настолько трудно обнаруживать и анализировать, что некоторые исследователи
  выступали с предложениями не допускать в языках программирования
  побочные эффекты и псевдонимы (Lampson et
  al. 1981;\index{ru}{Лэмпсон, Батлер||Butler
    Lampson||n|п}\index{en}{Butler Lampson||Лэмпсон, Батлер||n|п}
  Morris, Schmidt, and Wadler
  1980).\index{ru}{Моррис,~Дж.~Г.||J.~H.~Morris||n|п}\index{en}{J.~H.~Morris||Моррис,~Дж.~Г.||n|п}\index{ru}{Шмидт, Эрик||Eric Schmidt||n|п}\index{en}{Eric Schmidt||Шмидт, Эрик||n|п}\index{ru}{Уодлер, Филип||Philip Wadler||n|п}\index{en}{Philip Wadler||Уодлер, Филип||n|п}}.

В связи с этими замечаниями обратите внимание на то, что
если бы Петр и Павел могли только проверять свой платежный баланс,
но не менять его, то вопрос <<один ли у них счет?>> не имел бы
смысла.  В общем случае, если мы никогда не меняем объекты данных, то
можно считать, что каждый объект представляет собой в точности
совокупность своих частей.
Например, рациональное число определяется своим числителем и
знаменателем.  Однако при наличии изменений такой взгляд становится
ошибочным, поскольку теперь у каждого объекта есть <<индивидуальность>>,
которая отличается от тех частей, из которых он состоит.  Банковский
счет останется <<тем же самым>> счетом, даже если мы снимем с него часть
денег; и наоборот, можно иметь два разных счета с одинаковым
состоянием.  Такие сложности~--- следствие не нашего языка
программирования, а нашего восприятия банковского счета как объекта.
Скажем, рациональное число мы обычно не рассматриваем как изменяемый
объект со своей индивидуальностью, у которого можно было бы изменить
числитель и по-прежнему иметь дело с <<тем же>> числом.

\paragraph{Ловушки императивного программирования}


В противоположность функциональному программированию,
стиль программирования, при котором активно используется присваивание,
называется
\index{ru}{программирование|императивное|programming|||}\index{en}{programming||программирование|императивное||}
\index{ru}{императивное программирование||imperative programming|||}\index{en}{imperative programming||императивное программирование|||}{\em императивное
программирование} (imperative programming).  Кроме того, что возникают сложности
с вычислительными моделями, программы, написанные в императивном стиле,
подвержены таким ошибкам, которые в функциональных программах не
возникают.  Вспомним, к примеру, итеративную программу для вычисления
факториала из раздела~\ref{LINEAR-RECURSION-AND-ITERATION}:

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{Verbatim}
Вместо того, чтобы передавать аргументы во внутреннем итеративном
цикле, мы могли бы написать процедуру в более императивном стиле с
использованием присваивания для обновления значений переменных
{\tt product} и {\tt counter}:

\begin{Verbatim}[fontsize=\small]
(define (factorial n)\index{ru}{factorial|с присваиванием|||pd|}

  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))
\end{Verbatim}
Результаты, выдаваемые программой, при этом не меняются, но возникает
маленькая ловушка.  Как определить порядок присваиваний?  В имеющемся виде
программа корректна.  Однако если бы мы записали присваивания в
обратном порядке:\index{ru}{присваивание|вызванные
  ошибки||||}\index{ru}{ошибка|порядок присваиваний||||}

\begin{Verbatim}[fontsize=\small]
(set! counter (+ counter 1))
(set! product (* counter product))
\end{Verbatim}
--- получился бы другой, неверный результат.  Вообще, программирование с
использованием присваивания заставляет нас тщательно следить за
порядком присваиваний, так, чтобы в каждом использовалась правильная
версия значения переменных, которые меняются.  В функциональных
программах такие сложности просто не возникают\footnote{Поэтому
  странно и смешно, что вводные курсы
  программирования часто читаются в глубоко императивном стиле.  Может
  быть, сказываются остатки распространенного в 60-е и 70-е
  годы представления, что программы, которые вызывают процедуры, непременно будут
  менее эффективны, чем те, которые производят присваивания.
  (Steele 1977 развенчивает этот аргумент.)\index{ru}{Стил, Гай Льюис
    мл.||Guy Lewis Steele Jr.||n|п}\index{en}{Guy Lewis Steele
    Jr.||Стил, Гай Льюис мл.||n|п}
  С другой стороны, возможно, считается, что новичкам легче представить
  пошаговое присваивание, чем вызов процедуры.  Так или иначе,
  программистам часто приходится заботиться о вопросе
  <<присвоить сначала эту переменную или ту?>>, а это усложняет
  программирование и затемняет важные идеи.}.

Сложность императивных программ еще увеличивается,
если мы начинаем рассматривать приложения, где одновременно
выполняется несколько процессов.  К этому мы еще вернемся в
разделе~\ref{CONCURRENCY-TIME-IS-OF-THE-ESSENCE}.  Однако сначала
мы обратимся к задаче построения вычислительной модели для выражений,
содержащих присваивание, а также изучим, как  использовать объекты с
локальным состоянием при проектировании моделирующих программ.
\begin{exercise}{3.7}\label{EX3.7}%
Рассмотрим объекты-банковские счета, создаваемые
процедурой {\tt make-account}, и снабженные паролями, как это
описано в упражнении~\ref{EX3.3}.  Предположим, что наша
банковская система требует от нас умения порождать
\index{ru}{банковский счет|совместный||||(упр.~3.7)} совместные
счета.  Напишите процедуру {\tt make-joint}, которая это
делает. {\tt Make-joint}
\index{ru}{make-joint||||p|(упр.~3.7)}
должна принимать три аргумента.
Первый из них --- защищенный паролем счет.  Второй обязан совпадать с
паролем, с которым этот счет был создан, иначе {\tt make-joint}
откажется работать.  Третий аргумент~--- новый пароль.  Например, если
банковский счет {\tt peter-account} был создан с паролем
{\tt open-sesame}, то

\begin{Verbatim}[fontsize=\small]
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
\end{Verbatim}
позволит нам проводить операции с {\tt peter-account},
используя имя {\tt paul-acc} и пароль {\tt rosebud}.
Вам может потребоваться переработать решение
упражнения~\ref{EX3.3}, чтобы добавить эту новую возможность.
\end{exercise}
\begin{exercise}{3.8}\label{EX3.8}%
Когда в
разделе~\ref{EVALUATING-COMBINATIONS} мы определяли модель
вычислений, мы сказали, что первым шагом при вычислении выражения
является вычисление его подвыражений.  Однако мы нигде не указали
\index{ru}{порядок вычисления|и присваивания|order of evaluation|||(упр.~3.8)}\index{en}{order of evaluation||порядок вычисления|и присваивания||(упр.~3.8)}
\index{ru}{порядок вычисления|в Scheme||||(упр.~3.8)}
порядок, в котором проходит вычисление подвыражений (слева направо или
справа налево).  Когда мы вводим присваивание, порядок, в котором
вычисляются аргументы процедуры, может повлиять на результат.
Определите простую процедуру {\tt f}, так, чтобы вычисление
{\tt (+ (f 0) (f 1))} возвращало 0, если аргументы
{\tt +} вычисляются слева направо, и 1, если они вычисляются
справа налево.
\end{exercise}

\section{Модель вычислений с окружениями}
\label{THE-ENVIRONMENT-MODEL-OF-EVALUATION}


\index{ru}{модель вычисления с окружениями|||||}
Когда в главе~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES} мы вводили
понятие составной процедуры, то для того, чтобы определить, что значит
применение процедуры к аргументам, мы пользовались
\index{ru}{подстановочная модель применения процедуры|||||}подстановочной
моделью вычислений (раздел~\ref{SUBST-MODEL-FOR-PROC-APPL}):

\begin{itemize}


\item
Чтобы применить составную процедуру к
аргументам, нужно вычислить тело процедуры, подставив вместо каждого
формального параметра соответствующий ему аргумент.
\end{itemize}

Как только мы вводим в язык программирования
присваивание, это определение перестает быть адекватным.  А именно, в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}
указывалось, что в присутствии присваивания переменную уже нельзя
рассматривать просто как имя для значения.  Переменная должна каким-то
образом обозначать <<место>>, где значение может храниться.  В
нашей новой модели вычислений такие места будут находиться в
структурах, которые мы называем
\index{ru}{окружение||environment|||}\index{en}{environment||окружение|||}{\em окружениями} (environments).


\begin{cntrfig}
\input{xfig-mod/3-1.eepic}
\caption{Простой пример структуры окружений}
\label{P3.1}
\end{cntrfig}

Окружение представляет собой последовательность
\index{ru}{интерпретатор языка запросов|кадр||||}\index{ru}{кадр (в
  модели с окружениями)||frame|||}\index{en}{frame||кадр (в модели с
  окружениями)|||}{\em кадров} (frames).  Каждый кадр есть (возможно,
пустая)
таблица \index{ru}{связывание||binding|||}\index{en}{binding||связывание|||}{\em связываний} (bindings), которые
сопоставляют имена переменных соответствующим значениям.  (Каждый кадр
должен содержать не более одного связывания для каждой данной
переменной.)  Кроме того, в каждом кадре имеется указатель на
\index{ru}{окружение|объемлющее|environment|enclosing||}\index{en}{environment|enclosing|окружение|объемлющее||}{\em объемлющее
окружение} (enclosing environment), кроме тех случаев, когда в рамках текущего
обсуждения окружение считается
\index{ru}{глобальный кадр||global frame|||}\index{en}{global
  frame||глобальный кадр|||}\index{ru}{кадр (в модели с
  окружениями)|глобальный||||}\index{ru}{окружение|глобальное|environment|global||}\index{en}{environment|global|окружение|глобальное||}{\em глобальным} (global).
\index{ru}{переменная|значение|variable|value||}\index{en}{variable|value|переменная|значение||}{\em Значение
переменной} (value of a variable) по отношению к данному окружению есть значение,
которое находится в связывании для этой переменной в первом кадре
окружения, содержащем такое связывание.  Если в последовательности
кадров ни один не указывает значения для данной переменной, говорят,
что переменная
\index{ru}{несвязанная переменная||unbound
  variable|||}\index{en}{unbound     variable||несвязанная
  переменная|||}\index{ru}{переменная|несвязанная|variable|unbound||}\index{en}{variable|unbound|переменная|несвязанная||}{\em несвязана} (unbound)
в окружении.

На рисунке~\ref{P3.1} изображена простая
\index{ru}{модель вычисления с окружениями|структура окружений||||}
структура окружений, которая состоит из трех кадров, помеченных
числами I, II и III.  На этой диаграмме A, B, C и D --- указатели на
окружения.  C и D указывают на одно и то же окружение.  В кадре II
связываются переменные {\tt z} и {\tt x}, а в кадре I
переменные {\tt y} и {\tt x}.  В окружении D переменная
{\tt x} имеет значение 3.  В окружении B значение переменной
{\tt x} также равно 3.  Это определяется следующим образом: мы
рассматриваем первый кадр в последовательности (кадр III) и не находим
там связывания для переменной {\tt x}, так что мы переходим к
объемлющему окружению D и находим связывание в кадре I.  С другой
стороны, в окружении A значение переменной {\tt x} равно 7,
поскольку первый кадр окружения (кадр II) содержит связывание
{\tt x} со значением 7.  По отношению к окружению A говорится,
что связывание {\tt x} со значением 7 в кадре II
\index{ru}{сокрытие связывания||shadowing a binding|||}\index{en}{shadowing a binding||сокрытие связывания|||}{\em скрывает} (shadows) связывание
{\tt x} со значением 3 в кадре I.

{
\looseness=2
Окружение играет важную роль в процессе вычисления, поскольку
оно определяет контекст, в котором выражение должно вычисляться.
В самом деле, можно сказать, что выражения языка программирования сами
по себе не имеют значения. Выражение приобретает значение только по
отношению к окружению, в контексте которого оно вычисляется.  Даже
интерпретация столь простого выражения, как {\tt (+ 1 1)},
зависит от нашего понимания, что мы работаем в контексте, где
{\tt +} является символом сложения.  Таким образом, в нашей
модели мы всегда будем говорить о вычислении выражения относительно
некоторого окружения.  При описании взаимодействия с интерпретатором
мы будем предполагать, что существует
\index{ru}{глобальное окружение|||||}
глобальное окружение, состоящее
из одного кадра (без объемлющего окружения), и что глобальное
окружение содержит значения для символов, обозначающих элементарные
процедуры.  Например, информация о том, что {\tt +} служит
символом сложения, выражается как утверждение, что в глобальном
окружении символ {\tt +} связан с элементарной процедурой
сложения.

\looseness=2}

\subsection{Правила вычисления}
\label{THE-RULES-FOR-EVALUATION}


\index{ru}{модель вычисления с окружениями|правила вычисления||||}
Общее описание того, как интерпретатор вычисляет
комбинацию, остается таким же, как оно было введено в
разделе~\ref{EVALUATING-COMBINATIONS}:

\pagebreak

\begin{itemize}%MLR% Разобраться с двухуровневым перечнем.
\samepage
\item
Для того, чтобы вычислить комбинацию,
нужно:
\begin{itemize}
\samepage
\item
\nopagebreak
Вычислить подвыражения комбинации\footnote{Присваивание вносит одну тонкость в шаг 1
правила вычисления.  Как показано в
упражнении~\ref{EX3.8}, присваивание позволяет нам писать выражения,
которые имеют различные значения в зависимости от того, в каком
\index{ru}{зависимость от реализации|порядок вычисления подвыражений||||п}
\index{ru}{порядок вычисления|зависимость от реализации||||п}
порядке вычисляются подвыражения комбинации.  Таким образом, чтобы
быть точными, мы должны были бы указать порядок вычислений на шаге 1
(например, слева направо или справа налево).  Однако этот порядок
всегда должен рассматриваться как деталь реализации, и писать
программы, которые зависят от порядка вычисления аргументов, не
следует.  К примеру, продвинутый компилятор может оптимизировать
программу, изменяя порядок, в котором вычисляются подвыражения.
}.

\item
Применить значение выражения-оператора к
значениям вы\-ра\-же\-ний-операндов.
\end{itemize}
\end{itemize}%MLR%Разобраться с этим двухуровневым перечнем.
Модель вычисления с окружениями заменяет подстановочную модель,
по-своему определяя, что значит применить составную процедуру к
аргументам.

В модели вычисления с окружениями процедура всегда
представляется в виде пары, состоящей из кода и указателя на некое
окружение.  \index{ru}{процедура|создание с помощью {\tt lambda}||||} Процедура создается единственным способом: вычислением
{\tt lambda}-выражения.  Такое вычисление дает в качестве
результата процедуру, код которой берется из тела
{\tt lambda}-выражения, а окружение совпадает с окружением, в
котором было вычислено выражение, чьим значением является
процедура.  Например, рассмотрим определение процедуры

\begin{Verbatim}[fontsize=\small]
(define (square x)  \index{ru}{square|в модели с окружениями|||pd|}
  (* x x))
\end{Verbatim}
которое вычисляется в глобальном окружении.  Синтаксис определения
процедуры --- всего лишь синтаксический сахар для подразумеваемой
{\tt lambda}.  С тем же успехом можно было написать
выражение

\begin{Verbatim}[fontsize=\small]
(define square
  (lambda (x) (* x x)))
\end{Verbatim}
которое вычисляет
{\tt (lambda (x) (* x x))} и связывает символ
{\tt square} с полученным значением, все это в глобальном
окружении.


\begin{figure}
\begin{center}
\input{xfig-mod/3-2.eepic}
\end{center}
\hspace{5cm}параметры: {\tt x}

\hspace{5cm}тело: {\tt (* x x)}

\caption{Структура окружений, порождаемая вычислением
{\tt (define (square x) (* x x))} в глобальном окружении.}
\label{P3.2}
\end{figure}

Рис.~\ref{P3.2} показывает результат вычисления
{\tt lambda}-выражения.  Объект-про\-це\-дура представляет собой пару, код
которой указывает, что процедура принимает один формальный параметр, а
именно {\tt x}, а тело ее {\tt (* x x)}.  Окружение
процедуры~--- это указатель на глобальное окружение, поскольку именно
в нем вычислялось {\tt lambda}-выражение, при помощи которого
процедура была порождена.  К глобальному кадру добавилось новое
связывание, которое сопоставляет процедурный объект символу
{\tt square}.  В общем случае {\tt define} создает
определения, добавляя новые связывания в кадры.

Теперь, когда мы рассмотрели, как процедуры создаются, мы
можем описать, как они применяются.  Модель с окружениями говорит:
чтобы применить процедуру к аргументам, создайте новое окружение,
которое содержит кадр, связывающий параметры со значениями
аргументов.  Объемлющим окружением для нового кадра служит окружение,
на которое указывает процедура.  Теперь требуется выполнить тело
процедуры в этом новом окружении.

Чтобы проиллюстрировать, как работает это новое правило,
на рис.~\ref{P3.3} показана структура окружений, создаваемая
 при вычислении выражения {\tt (square 5)} в
глобальном окружении, если {\tt square} --- процедура,
порожденная на рисунке~\ref{P3.2}.  Применение процедуры
приводит к созданию нового окружения, которое на рисунке обозначено
как E1, и это окружение начинается с кадра, в котором {\tt x},
формальный параметр процедуры, связан с аргументом 5.  Указатель,
который ведет из этого кадра вверх, показывает, что объемлющим для
этого окружения является глобальное.  Глобальное окружение выбирается
потому, что именно на него ссылается процедурный объект
{\tt square}. Внутри E1 мы вычисляем тело процедуры, {\tt (* x
x)}.  Поскольку значение {\tt x} в E1 равно 5,
результатом будет {\tt (* 5 5)}, или 25.


\begin{figure}
\begin{center}
\input{xfig-mod/3-3.eepic}
\end{center}
\hspace{5cm}параметры: {\tt x} \qquad {\tt (* x x)}

\hspace{5cm}тело: {\tt (* x x)}
\caption{Окружение, создаваемое при вычислении
{\tt (square 5)} в глобальном окружении.}
\label{P3.3}

\end{figure}

Модель вычисления с окружениями можно вкратце описать двумя
правилами:

\begin{plainlist}


\item
Процедурный объект применяется к набору аргументов
при помощи создания кадра, связывания формальных параметров процедуры
с аргументами вызова, и, наконец, вычисления тела процедуры в
контексте этого свежесозданного окружения.  В качестве объемлющего
окружения новый кадр имеет окружение, содержащееся в применяемом
процедурном объекте.

\item
\index{ru}{процедура|создание с помощью {\tt lambda}||||}Процедура создается при вычислении
{\tt lambda}-выражения
\index{ru}{lambda-выражение|значение|||p|}
по отношению к некоторому окружению.
Получающийся процедурный объект есть пара, состоящая из текста
{\tt lambda}-выражения и указателя на окружение, в котором
процедура была создана.
\end{plainlist}

Кроме того, мы указываем, что когда символ определяется при
помощи {\tt define},
\index{ru}{define (особая форма)|модель с окружениями|||p|}
в текущем кадре
окружения создается  связывание, и символу присваивается указанное
значение\footnote{Если в текущем кадре уже имелось связывание для указанной
переменной, то это связывание изменяется.  Это правило удобно,
поскольку позволяет переопределять символы; однако оно означает, что
при помощи {\tt define} можно изменять значение символов, а это
влечет за собой все проблемы, связанные с присваиванием, без явного
использования \index{ru}{set! (особая форма)|модель с окружениями|||p|п}
{\tt set!}. По этой причине некоторые
предпочитают, чтобы переопределение существующего символа вызывало
предупреждение или сообщение об ошибке.
}.
Наконец, мы описываем поведение
{\tt set!}, операции, из-за которой нам, собственно, и пришлось
ввести модель с окружениями.  Вычисление выражения {\tt (set!
\textit{$\langle$переменная$\rangle$} \textit{$\langle$значение$\rangle$})} в
некотором окружении заставляет интерпретатор найти связывание
переменной в окружении и изменить это связывание так, чтобы оно
указывало на новое значение.  А именно, нужно найти первый кадр
окружения, в котором содержится связывание для переменной, и изменить
этот кадр.  Если переменная в окружении не связана, {\tt set!}
сигнализирует об ошибке.

Все эти правила вычисления, хотя они значительно сложнее,
чем в подстановочной модели, достаточно просты.  Более того, модель
вычислений, несмотря на свою абстрактность, дает правильное описание
того, как интерпретатор вычисляет выражения.  В
главе~\ref{METALINGUISTIC-ABSTRACTION} мы увидим, как эта модель
может служить основой для реализации работающего интерпретатора.
В последующих разделах анализ нескольких примеров программ
раскрывает некоторые детали этой модели.

\subsection{Применение простых процедур}
\label{APPLYING-SIMPLE-PROCEDURES}


 \index{ru}{sum-of-squares|в модели с окружениями|||p|}
\index{ru}{модель вычисления с окружениями|пример применения процедуры||||}
\index{ru}{применение процедур|модель вычисления с окружениями|procedure application|||}\index{en}{procedure application||применение процедур|модель вычисления с окружениями||}
Когда в разделе~\ref{SUBST-MODEL-FOR-PROC-APPL}
мы описывали подстановочную модель, мы показали, как вычисление
комбинации {\tt (f 5)} дает результат 136, если даны следующие
определения:

\begin{Verbatim}[fontsize=\small]
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
\end{Verbatim}
Теперь мы можем проанализировать тот же самый пример, используя
модель с окружениями.  На рисунке~\ref{P3.4}
изображены три процедурных объекта, созданные
вычислением в глобальном окружении определений {\tt f},
{\tt square}, и {\tt sum-of-squares}.  Каждый
процедурный объект состоит из куска кода и указателя на глобальное
окружение.


\begin{cntrfig}
\input{xfig-mod/3-4.eepic}
\begin{tabular}{lll}
%тело: sum-of-squares \= параметры: а \= параметры: x, y\kill
параметры: {\tt a}   & параметры: {\tt x} & параметры: {\tt x, y} \\
тело: \texttt{(sum-of-squares} & тело:  \texttt{(= x x)} & тело: \texttt{(+ (square x)} \\
\hspace{1cm} \tt{(+ a 1)} & & \hspace{1,55cm}\texttt{(square y))} \\
\hspace{1cm} \texttt{(+ a 2))}
\end{tabular}
\caption{Процедурные объекты в глобальном
кадре окружения.}
\label{P3.4}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-5.eepic}
%{\small глобальное окружение\\}
\begin{tabular}{llll}
{\tt (sum-of-squares} & {\tt (+ (square x)} & {\tt (* x x) } & {\tt (* x x)} \\
\hspace{8pt}{\tt (+ a 1)} & \hspace{14pt} {\tt (square y))}\\
\hspace{8pt}{\tt (+ a 2))}
\end{tabular}
\caption{Окружения, созданные при вычислении {\tt (f 5)} с использованием
процедур, изображенных на рис.~\ref{P3.4}}
\label{P3.5}

\end{cntrfig}

На рисунке~\ref{P3.5} мы видим структуру
окружений, созданную вычислением выражения {\tt (f 5)}. Вызов
{\tt f} создает новое окружение E1, начинающееся с кадра, в
котором {\tt a}, формальный параметр {\tt f},
связывается с аргументом 5.  В окружении E1 мы вычисляем тело
{\tt f}:

\begin{Verbatim}[fontsize=\small]
(sum-of-squares (+ a 1) (* a 2))
\end{Verbatim}

Для вычисления этой комбинации сначала мы вычисляем подвыражения.
Значение первого подвыражения,
{\tt sum-of-squares} --- процедурный объект.
(Обратите внимание, как мы находим этот объект: сначала мы
просматриваем первый кадр E1, который не содержит связывания для
переменной {\tt sum-of-squares}.  Затем мы переходим в
объемлющее окружение, а именно глобальное, и там находим связывание,
которое показано на рис.~\ref{P3.4}.)  В оставшихся двух
подвыражениях элементарные операции {\tt +} и {\tt *}
применяются при вычислении комбинаций {\tt (+ a 1)} и {\tt (*
a 2)}, и дают, соответственно, результаты 6 и 10.

Теперь мы применяем процедурный объект
{\tt sum-of-squares} к аргументам 6 и 10. При этом создается
новое окружение E2, в котором формальные параметры {\tt x} и
{\tt y} связываются со значениями аргументов.  Внутри E2 мы
вычисляем комбинацию {\tt (+ (square x) (square y))}. Для этого
нам требуется вычислить {\tt (square x)}, причем значение
{\tt square} мы находим в глобальном окружении, а
{\tt x} равен 6.  Мы опять создаем новое окружение, E3, где
{\tt x} связан со значением 6, и где мы вычисляем тело
{\tt square}, то есть {\tt (* x x)}. Кроме того, как
часть вычисления {\tt sum-of-squares}, нам нужно вычислить
подвыражение {\tt (square y)}, где {\tt y} равен 10.
Этот второй вызов {\tt square} создает еще одно окружение E4, в
котором {\tt x}, формальный параметр {\tt square},
связан со значением 10.  Внутри E4 нам нужно вычислить {\tt (* x
x)}.

Важно заметить, что каждый вызов {\tt square}
создает новое окружение с новым связыванием для {\tt x}.
Теперь мы видим, как разделение кадров служит для того, чтобы разные
локальные переменные по имени {\tt x} не смешивались.  Заметим,
кроме того, что все кадры, созданные процедурой
{\tt square}, указывают на глобальное окружение, поскольку
указатель именно на это окружение содержится в процедурном
объекте {\tt square}.

После того, как подвыражения вычисляются, они возвращают
значения.  Значения, порожденные двумя вызовами
{\tt square}, складываются в {\tt sum-of\-squares}, и
этот результат возвращается процедурой {\tt f}.  Поскольку
сейчас наше внимание сосредоточено на структурах окружений, мы не
будем здесь разбираться, как значения передаются от вызова к вызову; однако
на самом деле это важная часть процесса вычисления, и мы детально
рассмотрим ее в главе~\ref{COMPUTING-WITH-REGISTER-MACHINES}.
\begin{exercise}{3.9}\label{EX3.9}%
\index{ru}{итеративный процесс|vs. рекурсивный процесс||||(упр.~3.9)}%
\index{ru}{рекурсивный процесс|vs. итеративный процесс||||(упр.~3.9)}%
В разделе~\ref{LINEAR-RECURSION-AND-ITERATION} мы с помощью
подстановочной модели анализировали две процедуры вычисления
факториала, рекурсивную
\index{ru}{factorial|структура окружений при вычислении|||p|(упр.~3.9)}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
\end{Verbatim}
и итеративную

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
\end{Verbatim}
Продемонстрируйте, какие структуры окружений возникнут при вычислении
{\tt (fac\-to\-rial 6)} с каждой из версий процедуры
{\tt factorial}\footnote{Модель с окружениями неспособна проиллюстрировать
утверждение из раздела~\ref{LINEAR-RECURSION-AND-ITERATION}, что
интерпретатор может, используя
\index{ru}{модель вычисления с окружениями|и хвостовая рекурсия||||п}
хвостовую рекурсию, вычислять
процедуры, подобные {\tt fact-iter}, в фиксированном объеме
памяти.  Мы рассмотрим
\index{ru}{хвостовая рекурсия|и модель с окружениями||||п}
хвостовую рекурсию, когда будем изучать
управляющую структуру интерпретатора в
разделе~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}.}.
\end{exercise}

\subsection{Кадры как хранилище внутреннего состояния}
\label{FRAMES-AS-REPOSITORY-OF-LOCAL-STATE}


\index{ru}{кадр (в модели с окружениями)|как хранилище внутреннего состояния||||}
\index{ru}{внутреннее состояние|поддерживаемое в кадрах||||}
Теперь мы можем обратиться к модели с окружениями и
рассмотреть, как можно с помощью процедур и присваивания представлять
объекты, обладающие \index{ru}{модель вычисления с окружениями|внутреннее состояние||||}внутренним состоянием.  В качестве примера возьмем
<<обработчик снятия денег со счета>> из
раздела~\ref{LOCAL-STATE-VARIABLES}, который создается вызовом
процедуры\index{ru}{make-withdraw|в модели с окружениями|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете")))
\end{Verbatim}
Опишем вычисление

\begin{Verbatim}[fontsize=\small]
(define W1 (make-withdraw 100))
\end{Verbatim}
за которым следует

\begin{Verbatim}[fontsize=\small]
(W1 50)
\end{Verbatim}
На рисунке~\ref{P3.6} показан результат определения
{\tt make-withdraw} в глобальном окружении.  Получается
процедурный объект, который содержит ссылку на глобальное окружение.
До сих пор мы не видим особых отличий от тех примеров, которые мы уже
рассмотрели, кроме того, что тело процедуры само по себе является
лямбда-выражением.


\begin{figure}
\begin{center}
\input{xfig-mod/3-6.eepic}
\end{center}
\begin{Verbatim}
\qquad {\rm параметры:} balance
\qquad {\rm тело:} (lambda (amount)
\qquad	      (if (>= balance amount)
\qquad                  (begin (set! balance (- balance amount))
\qquad	          balance)
\qquad	      "Недостаточно денег на счете"))
\end{Verbatim}

\caption{Результат определения {\tt make-withdraw} в глобальном окружении.}
\label{P3.6}

\end{figure}
Интересная часть вычисления начинается тогда, когда мы
применяем процедуру {\tt make-withdraw} к аргументу:

\begin{Verbatim}[fontsize=\small]
(define W1 (make-withdraw 100))
\end{Verbatim}
Сначала, как обычно, мы создаем окружение E1, где формальный
параметр {\tt balance} связан с аргументом 100. Внутри этого
окружения мы вычисляем тело {\tt make-withdraw}, а именно
{\tt lambda}-выражение. При этом создается новый процедурный
объект, код которого определяется {\tt lambda}-выражением, а
окружение равно E1, окружению, в котором вычисляется {\tt lambda} при
создании процедуры.  Полученный процедурный объект возвращается в
качестве значения процедуры {\tt make-withdraw}.  Это значение
присваивается переменной {\tt W1} в глобальном окружении,
поскольку выражение {\tt define} вычисляется именно в нем.
Получившаяся структура окружений изображена на
рисунке~\ref{P3.7}.


\begin{figure}
\input{xfig-mod/3-7.eepic}
\begin{Verbatim}
{\rm параметры:} amount
{\rm тело:} (if (>= balance amount)
                (begin (set! balance (-balance amount))
	        balance)
             "Недостаточно денег на счете"))
\end{Verbatim}
\caption{Результат вычисления {\tt (define W1 (make-withdraw 100))}.}
\label{P3.7}
\end{figure}

Теперь можно проанализировать, что происходит, когда
{\tt W1} применяется к аргументу:

\begin{Verbatim}[fontsize=\small]
(W1 50)
\textit{50}
\end{Verbatim}
Для начала мы конструируем кадр, в котором
{\tt amount}, формальный параметр {\tt W1}, связывается
со значением 50.  Здесь крайне важно заметить, что у этого кадра в
качестве объемлющего окружения выступает не глобальное окружение, а
E1, поскольку именно на него указывает процедурный объект
{\tt W1}.  В этом новом окружении мы вычисляем тело процедуры:

\begin{Verbatim}[fontsize=\small]
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Недостаточно денег на счете")
\end{Verbatim}
Получается структура окружений, изображенная на
рисунке~\ref{P3.8}.  Вычисляемое выражение обращается к переменным
{\tt amount} и {\tt balance}. {\tt Amount}
находится в первом кадре окружения, а {\tt balance} мы найдем,
проследовав по указателю на объемлющее окружение~E1.


\begin{cntrfig}
\input{xfig-mod/3-8.eepic}
\begin{Verbatim}
{\rm параметры:} amount   (if (>= balance amount)
                       (begin
                           (set! (balance
                                 (- balance amount))
                           balance
                           "Недостаточно денег на счете"))
\end{Verbatim}
\caption{Окружения, создаваемые при применении
процедурного объекта {\tt W1}.}
\label{P3.8}

\end{cntrfig}

Когда выполняется {\tt set!}, связывание
переменной {\tt balance} в E1 изменяется. После завершения
вызова {\tt W1} значение {\tt balance} равно 50, а {\tt W1}
по-прежнему указывает на кадр, который содержит переменную
{\tt balance}.  Кадр, содержащий {\tt amount} (тот, в
котором мы выполняли код, изменяющий {\tt balance}), больше не
нужен, поскольку создавший его вызов процедуры закончен, и никаких указателей
на этот кадр из других частей окружения нет.  В следующий раз, когда
мы позовем {\tt W1}, создастся новый кадр, в котором будет
связана переменная {\tt amount}, и для которого объемлющим
окружением снова будет E1.  Мы видим, что E1 служит <<местом>>,
в котором хранится локальная переменная окружения для процедурного
объекта {\tt W1}.  На рисунке~\ref{P3.9} изображена
ситуация после вызова {\tt W1}.


\begin{cntrfig}
\input{xfig-mod/3-9.eepic}
\begin{Verbatim}
\hspace{2cm} {\rm параметры:} amount
\hspace{2cm} {\rm тело:} ...
\end{Verbatim}
\caption{Окружения после вызова {\tt W1}.}
\label{P3.9}
\end{cntrfig}

Рассмотрим, что произойдет, когда мы создадим другой объект
для <<снятия денег>>, вызвав {\tt make-withdraw} второй раз:

\begin{Verbatim}[fontsize=\small]
(define W2 (make-withdraw 100))
\end{Verbatim}
При этом получается структура окружений, изображенная на
рисунке~\ref{P3.10}.  Мы видим, что {\tt W2} ---
процедурный объект, то есть пара, содержащая код и окружение.
Окружение E2 для {\tt W2} было создано во время вызова
{\tt make-with\-draw}.  Оно содержит кадр со своим собственным
связыванием переменной {\tt balance}.  С другой стороны, код у
{\tt W1} и {\tt W2} один и тот же: это код, определяемый
{\tt lambda}-выражением в теле
{\tt make-withdraw}\footnote{Разделяют ли {\tt W1} и {\tt W2} общий
физический код, хранимый в компьютере, или каждый из них хранит
собственную копию кода --- это деталь реализации.  В интерпретаторе,
который мы создадим в
главе~\ref{METALINGUISTIC-ABSTRACTION}, код будет общим.}.
Отсюда мы видим, почему {\tt W1} и {\tt W2} ведут себя как
независимые объекты.  Вызовы {\tt W1} работают с переменной
состояния {\tt balance}, которая хранится в E1, а вызовы
{\tt W2} с переменной {\tt balance}, хранящейся в E2.
Таким образом, изменения внутреннего состояния одного объекта не
действуют на другой.


\begin{cntrfig}
\input{xfig-mod/3-10.eepic}
\begin{Verbatim}
\hspace{2cm} {\rm параметры:} amount
\hspace{2cm} {\rm тело:} ...
\end{Verbatim}
\caption{Создание второго объекта при помощи {\tt (define W2 (make-withdraw 100))}}
\label{P3.10}
\end{cntrfig}

\begin{exercise}{3.10}\label{EX3.10}%
В процедуре {\tt make-withdraw} локальная
переменная {\tt balance} создается в виде параметра
{\tt make-withdraw}.  Можно было бы создать локальную
переменную и явно, используя {\tt let}, а именно:

\begin{Verbatim}[fontsize=\small]
(define (make-withdraw initial-amount)\index{ru}{make-withdraw|с использованием \texttt{let}|||pd|(упр.~3.10)}
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))))
\end{Verbatim}
Напомним, что в
разделе~\ref{CONSTRUCTING-PROCEDURES-USING-LAMBDA} говорится, что
{\tt let} всего лишь синтаксический сахар для вызова процедуры:
\index{ru}{let (особая форма)|как синтаксический сахар|||p|(упр.~3.10)}
\index{ru}{let (особая форма)|модель вычисления|||p|(упр.~3.10)}

\begin{Verbatim}[fontsize=\small]
(let ((\textit{$\langle$пер$\rangle$} \textit{$\langle$выр$\rangle$}))
   \textit{$\langle$тело$\rangle$})
\end{Verbatim}
интерпретируется как альтернативный синтаксис для

\begin{Verbatim}[fontsize=\small]
((lambda (\textit{$\langle$пер$\rangle$}) \textit{$\langle$тело$\rangle$}) \textit{$\langle$выр$\rangle$})
\end{Verbatim}
С помощью модели с окружениями проанализируйте альтернативную версию
{\tt make\-withraw}.  Нарисуйте картинки, подобные приведенным
в этом разделе, для выражений

\begin{Verbatim}[fontsize=\small]
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
\end{Verbatim}
Покажите, что две версии {\tt make-withdraw} создают объекты с
одинаковым поведением.  Как различаются структуры окружений в двух
версиях?
\end{exercise}

\subsection{Внутренние определения}
\label{INTERNAL-DEFINITIONS-CH3}



\begin{cntrfig}
\input{xfig-mod/3-11.eepic}
%{\small глобальное окружение\\
%параметры: (2 раза)\\
%тело: (2 раза)\\
%вызов sqrt-iter\\
%вызов good-enough?}
\caption{Процедура {\tt sqrt} с внутренними определениями.}
\label{P3.11}

\end{cntrfig}

\index{ru}{модель вычисления с окружениями|внутренние определения||||}
\index{ru}{внутренние определения|в модели с окружениями||||}
В разделе~\ref{PROCEDURES-AS-BLACK-BOX-ABSTRACTIONS} мы
познакомились с идеей, что процедуры могут содержать внутренние
определения, в результате чего возникает блочная структура, как, например, в
\index{ru}{блочная структура|в модели окружения||||}
следующей процедуре вычисления квадратного корня:

\begin{Verbatim}[fontsize=\small]
(define (sqrt x)\index{ru}{sqrt|в модели с окружениями|||pd|}
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{Verbatim}
Теперь с помощью модели с окружениями мы можем увидеть, почему эти
внутренние определения работают так, как должны.  На
рисунке~\ref{P3.11} изображен момент во время вычисления выражения
{\tt (sqrt 2)}, когда внутренняя процедура
{\tt good-enough?} вызвана в первый раз со значением
{\tt guess}, равным 1.

Рассмотрим структуру окружения. Символ {\tt sqrt} в
глобальном окружении связан с процедурным объектом, ассоциированное
окружение которого --- глобальное окружение.  Когда мы вызвали
процедуру {\tt sqrt}, появилось окружение E1, зависимое от
глобального, в котором параметр {\tt x} связан со значением 2.
Затем мы вычислили тело {\tt sqrt} внутри E1.  Поскольку
первое выражение в теле {\tt sqrt} есть

\begin{Verbatim}[fontsize=\small]
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
\end{Verbatim}
вычисление этого выражения привело к определению процедуры
{\tt good-enough?} в окружении E1.  Выражаясь более точно, к
первому кадру E1 был добавлен символ {\tt good-enough?},
связанный с процедурным объектом, ассоциированным окружением которого
является E1.  Подобным образом в качестве процедур внутри E1 были
определены {\tt improve} и {\tt sqrt-iter}.  Краткости
ради на рис.~\ref{P3.11} показан только процедурный
объект, соответствующий {\tt good-enough?}.
{\sloppy

}
После того, как были определены внутренние процедуры, мы
вычислили выражение {\tt (sqrt-iter 1.0)}, по-прежнему в
окружении E1.  То есть, процедурный объект, связанный в E1 с именем
{\tt sqrt-iter}, был вызван с аргументом 1.  При этом появилось
окружение E2, в котором {\tt guess}, параметр
{\tt sqrt-iter}, связан со значением 1.  В свою очередь,
{\tt sqrt-iter} вызвала {\tt good-enough?} со значением
{\tt guess} (из E2) в качестве аргумента.  Получилось еще одно
окружение, E3, в котором {\tt guess} (параметр
{\tt good-enough?}) связан со значением 1.  Несмотря на то, что
и {\tt sqrt-iter}, и {\tt good-enough?} имеют по
параметру с одинаковым именем {\tt guess}, это две различные переменные,
расположенные в разных кадрах.  Кроме того, и E2, и E3 в качестве
объемлющего окружения имеют E1, поскольку как {\tt sqrt-iter},
так и {\tt good-enough?} в качестве
окружения содержат указатель на E1.  Одним из следствий этого является
то, что символ {\tt x} в теле
{\tt good-enough?} обозначает связывание  {\tt x},
в окружении E1, а точнее, то значение {\tt x}, с которым
была вызвана исходная процедура {\tt sqrt}.

Таким образом, модель вычислений с окружениями объясняет
две ключевых особенности, которые делают внутренние определения
процедур полезным способом модуляризации программ:

\begin{plainlist}


\item
Имена внутренних процедур не путаются с именами,
внешними по отношению к охватывающей процедуре, поскольку локальные
имена процедур будут связываться в кадре, который процедура создает
при своем запуске, а не в глобальном окружении.

\item
Внутренние процедуры могут обращаться к аргументам
охватывающих процедур, просто используя имена параметров как свободные
переменные.  Это происходит потому, что тело внутренней процедуры
выполняется в окружении, подчиненном окружению, где вычисляется
объемлющая процедура.
\end{plainlist}
\begin{exercise}{3.11}\label{EX3.11}%
В
разделе~\ref{FRAMES-AS-REPOSITORY-OF-LOCAL-STATE} мы видели, как
модель с окружениями описывает поведение процедур, обладающих
внутренним состоянием.  Теперь мы рассмотрели, как работают локальные
определения.  \index{ru}{модель вычисления с окружениями|передача сообщений||||(упр.~3.11)}  \index{ru}{передача сообщений|и модель с окружениями||||(упр.~3.11)} Типичная процедура с передачей сообщений
пользуется и тем, и другим. Рассмотрим процедуру моделирования  \index{ru}{банковский счет|||||(упр.~3.11)} банковского счета из раздела~\ref{LOCAL-STATE-VARIABLES}:
\index{ru}{make-account|в модели с окружениями|||p|(упр.~3.11)}

\begin{Verbatim}[fontsize=\small]
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                       m))))
  dispatch)
\end{Verbatim}
Покажите, какая структура окружений создается последовательностью
действий

\begin{Verbatim}[fontsize=\small]
(define acc (make-account 50))

((acc 'deposit) 40)
\textit{90}

((acc 'withdraw) 60)
\textit{30}
\end{Verbatim}
Где хранится внутреннее состояние {\tt acc}?  Предположим, что
мы определяем еще один счет

\begin{Verbatim}[fontsize=\small]
(define acc2 (make-account 100))
\end{Verbatim}
Каким образом удается не смешивать внутренние состояния двух счетов?
Какие части структуры окружений общие у {\tt acc} и
{\tt acc2}?
\end{exercise}

\section{Моделирование при помощи изменяемых данных}%HERE218
\label{MODELING-WITH-MUTABLE-DATA}


\index{ru}{изменяемые объекты данных|||||}
В главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}
составные данные использовались как средство построения вычислительных
объектов, состоящих из нескольких частей, с целью моделирования
объектов реального мира, обладающих несколькими свойствами. В этой
главе мы ввели дисциплину абстракции данных, согласно которой
структуры данных описываются в терминах конструкторов, которые создают
объекты данных, и селекторов, которые обеспечивают доступ к частям
составных объектов.  Однако теперь мы знаем, что есть еще один аспект
работы с данными, который остался незатронутым в
главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}.  Желание
моделировать системы, которые состоят  из объектов, обладающих
изменяющимся состоянием, вызывает потребность не только создавать составные
объекты данных и иметь доступ к их частям, но и изменять их.
Чтобы моделировать объекты с изменяющимся состоянием, мы будем
проектировать абстракции данных, которые, помимо конструкторов и
селекторов, включают \index{ru}{мутатор||mutator|||}\index{en}{mutator||мутатор|||}{\em мутаторы} (mutators),
модифицирующие объекты данных.  Например, моделирование банковской
системы требует от нас способности изменять балансы счетов.  Таким
образом, структура данных, изображающая банковский счет, может
обладать операцией

\begin{Verbatim}[fontsize=\small]
(set-balance! \textit{$\langle$счет$\rangle$} \textit{$\langle$новое-значение$\rangle$})
\end{Verbatim}
которая присваивает балансу указанного счета указанное значение.
Объекты данных, для которых определены мутаторы, называются
\index{ru}{изменяемые объекты данных||mutable data objects|||}\index{en}{mutable data objects||изменяемые объекты данных|||}{\em изменяемыми объектами
данных} (mutable data objects).

В главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA} в
качестве универсального <<клея>> для построения составных данных мы ввели
пары.  Этот раздел мы начинаем с определения мутаторов для
пар, так, чтобы пары могли служить строительным материалом для
построения изменяемых объектов данных.  Мутаторы значительно
увеличивают выразительную силу пар и позволяют нам строить структуры
данных помимо последовательностей и деревьев, с которыми мы имели дело
в разделе~\ref{HIERARCHICAL-DATA-AND-THE-CLOSURE-PROPERTY}.
Кроме того, мы строим несколько примеров моделей, где сложные
системы представляются в виде множества объектов, обладающих
внутренним состоянием.

\subsection{Изменяемая списковая структура}
\label{MUTABLE-LIST-STRUCTURE}


\index{ru}{списковая структура|изменяемая||||}
\index{ru}{изменяемые объекты данных|списковая структура||||}
\index{ru}{изменяемые объекты данных|пары||||}
\index{ru}{пара (пары)|изменяемые||||}
Базовые операции над парами --- {\tt cons},
{\tt car} и {\tt cdr} --- можно использовать для
построения списковой структуры и для извлечения частей списковой
структуры, однако изменять списковую структуру они не позволяют.  То же
верно и для операций со списками, которые мы до сих пор использовали,
таких, как {\tt append} и {\tt list}, поскольку эти
последние можно определить в терминах {\tt cons},
{\tt car} и {\tt cdr}.  Для модификации списковых
структур нам нужны новые операции.

\index{ru}{элементарные процедуры|{\tt set-car!}||||}%
\index{ru}{элементарные процедуры|{\tt set-cdr!}||||}%
\index{ru}{set-car!||||pd|}%
\index{ru}{set-cdr!||||pd|}%
Элементарные мутаторы для пар называются
{\tt set-car!} и {\tt set-cdr!}.  {\tt Set-car!}
принимает два аргумента, первый из которых обязан быть парой.  Он
модифицирует эту пару, подставляя вместо указателя {\tt car}
указатель на свой второй аргумент\footnote{\index{ru}{неопределенные значения|\texttt{set-car!}||||п}%
\index{ru}{неопределенные значения|\texttt{set-cdr!}||||п}%
Значения, которые возвращают {\tt set-car!} и
{\tt set-cdr!}, зависят от реализации.  Подобно
{\tt set!}, эти операции должны использоваться исключительно
ради своего побочного эффекта.}.

%\sloppy
%HERE{
В качестве примера предположим, что переменная
{\tt x} имеет значением список {\tt ((a b) c
d)}, а переменная {\tt y} список {\tt (e f)}, как
показано на рисунке~\ref{P3.12}.  Вычисление выражения
{\tt (set-car! x y)} изменяет пару, с которой связана
переменная {\tt x}, заменяя ее {\tt car} на значение
{\tt y}.  Результат этой операции показан на
рисунке~\ref{P3.13}.  Структура {\tt x} изменилась, и теперь
ее можно записать как {\tt ((e~f)~c~d)}.  Пары %HERE219
представляющие список {\tt (a b)}, на которые указывал замененный
указатель, теперь отделены от исходной структуры\footnote{ Здесь мы видим, как операции изменения данных могут
создавать <<мусор>>, который не является частью никакой доступной
структуры.  \index{ru}{сборка мусора|и изменения данных||||п}
В разделе~\ref{MAINTAINING-THE-ILLUSION-OF-INFINITE-MEMORY} мы
увидим, что системы управления памятью Лиспа включают
\index{ru}{сборщик мусора||garbage collector|||п}\index{en}{garbage collector||сборщик мусора|||п}{\em сборщик мусора} (garbage collector), который находит и
освобождает память, используемую ненужными парами.}.
%\looseness=2

%}%HERE219

\begin{cntrfig}
\input{xfig-mod/3-12.eepic}
\caption{Списки {\tt x}: {\tt ((a b) c
d)} и {\tt y}: {\tt (e f)}.}
\label{P3.12}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-13.eepic}
\caption{Результат применения {\tt (set-car! x y)} к спискам, изображенным на рис.~\ref{P3.12}.}
\label{P3.13}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-14.eepic}
\caption{Результат применения {\tt (define z (cons
y (cdr x))} к спискам, показанным на рис.~\ref{P3.12}.}
\label{P3.14}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-15.eepic}
\caption{Результат применения {\tt (set-cdr! x
y)} к спискам с рис.~\ref{P3.12}.}
\label{P3.15}

\end{cntrfig}

Сравните рисунок~\ref{P3.13} с
рис.~\ref{P3.14}, на котором представлен результат
выполнения {\tt (define z (cons y (cdr x)))}, где
{\tt x} и {\tt y} имеют исходные значения с
рис.~\ref{P3.12}.  Здесь переменная {\tt z}
оказывается связана с новой парой, созданной операцией
{\tt cons}; список, который является значением {\tt x},
не меняется.

Операция {\tt set-cdr!} подобна {\tt set-car!}.
Единственная разница состоит в том, что заменяется не указатель
{\tt car}, а указатель {\tt cdr}.  Результат применения
{\tt (set-cdr!~x~y)} к спискам, изображенным на
рис.~\ref{P3.12}, показан на рис.~\ref{P3.15}.
Здесь указатель {\tt cdr} в составе {\tt x} заменился
указателем на {\tt (e f)}.  Кроме того, список {\tt (c
d)}, который был {\tt cdr}-ом {\tt x}, оказывается
отделенным от структуры.

{\tt Cons} создает новую списковую структуру,
порождая новые пары, а  {\tt set-car!} и {\tt set-cdr!}
изменяют существующие.  В сущности, мы могли бы реализовать
{\tt cons} при помощи этих двух мутаторов и процедуры
{\tt get-new-pair}, которая возвращает новую пару, не
являющуюся частью никакой существующей списковой структуры.  Мы
порождаем новую пару, присваиваем ее указателям {\tt car} и
{\tt cdr} нужные значения, и возвращаем новую пару в качестве
результата {\tt cons}\footnote{{\tt Get-new-pair} --- одна из операций, которые
требуется предоставить как часть системы управления памятью в рамках
реализации Лиспа.  Мы рассмотрим эти вопросы в
разделе~\ref{MEMORY-AS-VECTORS}.
}:

\begin{Verbatim}[fontsize=\small]
(define (cons x y)\index{ru}{cons (элементарная процедура)|процедурная реализация|||pd|}
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
\end{Verbatim}
\begin{exercise}{3.12}\label{EX3.12}%
В разделе~\ref{REPRESENTING-SEQUENCES} была
введена следующая процедура для добавления одного списка к другому:

\begin{Verbatim}[fontsize=\small]
(define (append x y)\index{ru}{append||||pd|(упр.~3.12)}
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
\end{Verbatim}
{\tt Append} порождает новый список, по очереди наращивая
элементы {\tt x} в начало {\tt y}.  Процедура
{\tt append!} подобна {\tt append}, но только она
\index{ru}{append|vs. \texttt{append!}|||p|(упр.~3.12)}
является не конструктором, а мутатором.  Она склеивает списки вместе,
изменяя последнюю пару {\tt x} так, что ее {\tt cdr}
становится равным {\tt y}. (Вызов {\tt append!} с пустым
{\tt x} является ошибкой.)

\begin{Verbatim}[fontsize=\small]
(define (append! x y)\index{ru}{append!||||pd|(упр.~3.12)}
  (set-cdr! (last-pair x) y)
  x)
\end{Verbatim}
Здесь {\tt last-pair} --- процедура, которая возвращает
последнюю пару своего аргумента:

\begin{Verbatim}[fontsize=\small]
(define (last-pair x)\index{ru}{last-pair||||pd|(упр.~3.12)}
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
\end{Verbatim}
Рассмотрим последовательность действий

\begin{Verbatim}[fontsize=\small]
(define x (list 'a 'b))

(define y (list 'c 'd))

(define z (append  x y))

z
\textit{(a b c d)}

(cdr x)
\textit{$\langle$ответ$\rangle$}

(define w (append! x y))

w
\textit{(a b c d)}

(cdr x)
\textit{$\langle$ответ$\rangle$}
\end{Verbatim}
Каковы будут пропущенные \textit{$\langle$ответы$\rangle$}?
Объясните, нарисовав стрелочные диаграммы.
\end{exercise}
\begin{exercise}{3.13}\label{EX3.13}%
\index{ru}{цикл в списке||cycle in    list|||(упр.~3.13)}%
\index{en}{cycle in    list||цикл в списке|||(упр.~3.13)}%
Рассмотрим следующую процедуру {\tt make-cycle},
которая пользуется {\tt last-pair} из
упражнения~\ref{EX3.12}:

\begin{Verbatim}[fontsize=\small]
(define (make-cycle x)\index{ru}{make-cycle||||pd|(упр.~3.13)}
  (set-cdr! (last-pair x) x)
  x)
\end{Verbatim}
Нарисуйте  стрелочную диаграмму, которая изображает
структуру {\tt z}, созданную таким кодом:

\begin{Verbatim}[fontsize=\small]
(define z (make-cycle (list 'a 'b 'c)))
\end{Verbatim}
Что случится, если мы попробуем вычислить
{\tt (last-pair z)}?
\end{exercise}
\begin{exercise}{3.14}\label{EX3.14}%
Следующая процедура, хотя и сложна для понимания, вполне
может оказаться полезной:

\begin{Verbatim}[fontsize=\small]
(define (mystery x)\index{ru}{mystery||||pd|(упр.~3.14)}
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
\end{Verbatim}
{\tt Loop} пользуется <<временной>> переменной
{\tt temp}, чтобы сохранить старое значение
{\tt cdr} пары {\tt x}, поскольку
{\tt set-cdr!} на следующей строке его разрушает.  Объясните,
что за задачу выполняет {\tt mystery}.  Предположим, что
переменная {\tt v} определена выражением {\tt (define v (list
'a 'b 'c 'd)}.  Нарисуйте диаграмму, которая изображает список,
являющийся значением {\tt v}.  Допустим, что теперь мы
выполняем {\tt (define w (mystery v))}. Нарисуйте стрелочные диаграммы,
которые показывают структуры {\tt v} и
{\tt w} после вычисления этого выражения.  Что будет напечатано
в качестве значений {\tt v} и {\tt w}?
\end{exercise}


\begin{cntrfig}
\input{xfig-mod/3-16.eepic}
\caption{Список {\tt z1}, порождаемый
выражением {\tt (cons x x)}.}
\label{P3.16}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-17.eepic}
\caption{Список z2, порождаемый выражением
{\tt (cons (list 'a 'b) (list 'a 'b))}.}
\label{P3.17}

\end{cntrfig}

\paragraph{Разделение данных и их идентичность}

\index{ru}{разделяемые данные|||||}
В разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT} мы
упоминали теоретические вопросы <<идентичности>> и <<изменения>>,
которые возникают с появлением присваивания.  Эти вопросы начинают
иметь практическое значение тогда, когда отдельные пары
\index{ru}{изменение и тождественность|и разделяемые
  данные||||}\index{ru}{тождественность и изменение|и разделяемые
  данные||||}\index{ru}{разделяемые данные||shared
  data|||}\index{en}{shared data||разделяемые данные|||}{\em
  разделяются} (are shared)\index{ru}{данные|разделенные||||}
между различными объектами данных.  Рассмотрим, например, структуру,
которая создается таким кодом:

\begin{Verbatim}[fontsize=\small]
(define x (list 'a 'b))
(define z1 (cons x x))
\end{Verbatim}
Как показано на рис.~\ref{P3.16}, {\tt z1}
представляет собой пару, в которой {\tt car} и {\tt cdr}
указывают на одну и ту же пару {\tt x}.  Разделение
{\tt x} между {\tt car} и {\tt cdr} пары
{\tt z1} возникает оттого, что {\tt cons}
реализован простейшим способом. В общем случае построение списков с
помощью {\tt cons} приводит к возникновению сложносвязанной
сети пар, в которой многие пары разделяются между многими
различными структурами.

В противоположность рис.~\ref{P3.16},
рис.~\ref{P3.17} показывает структуру, которая порождается
кодом

\begin{Verbatim}[fontsize=\small]
(define z2 (cons (list 'a 'b) (list 'a 'b)))
\end{Verbatim}
В этой структуре пары двух списков {\tt (a b)} различны,
притом, что сами символы разделяются\footnote{Пары различаются потому, что каждый вызов
{\tt cons} порождает новую пару.  Символы разделяются; в Scheme
существует  \index{ru}{символ(ы)|уникальность||||п}только один символ для каждого данного имени.  Поскольку
Scheme не дает возможности изменять символ, это разделение невозможно
заметить.  Заметим, кроме того, что именно разделение позволяет нам
сравнивать символы при помощи {\tt eq?}, который просто
проверяет равенство указателей.
}.

Если мы рассматриваем {\tt z1} и {\tt z2}
как списки, они представляют <<один и тот же>> список
{\tt ((a b) a b)}.  Вообще говоря, разделение данных невозможно
заметить, если мы работаем со списками только при помощи операций
{\tt cons}, {\tt car} и {\tt cdr}.  Однако если
мы вводим мутаторы, работающие со списковой структурой, разделение
данных начинает иметь значение.  Как пример случая, когда разделение
влияет на результат, рассмотрим следующую процедуру, которая изменяет
{\tt car} структуры, к которой она применяется:

\begin{Verbatim}[fontsize=\small]
(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
\end{Verbatim}
Несмотря на то, что {\tt z1} и {\tt z2} имеют
<<одинаковую>>  структуру, применение к ним процедуры
{\tt set-to-wow!} дает различные результаты.  В случае с
{\tt z1} изменение {\tt car} влияет и на
{\tt cdr}, поскольку здесь {\tt car} и {\tt cdr}
--- это одна и та же пара.  В случае с {\tt z2},
{\tt car} и {\tt cdr} различны, так что
{\tt set-to-wow!} изменяет только {\tt car}:

\begin{Verbatim}[fontsize=\small]
z1
\textit{((a b) a b)}

(set-to-wow! z1)
\textit{((wow b) wow b)}

z2
\textit{((a b) a b)}

(set-to-wow! z2)
\textit{((wow b) a b)}
\end{Verbatim}

Один из способов распознать разделение данных в списковых
структурах --- это воспользоваться предикатом {\tt eq?},
который мы ввели в разделе~\ref{QUOTATION} как метод
проверки двух символов на равенство.  В более общем случае
{\tt (eq? x y)}
\index{ru}{eq? (элементарная процедура)|для произвольных объектов|||p|}
\index{ru}{eq? (элементарная процедура)|как равенство указателей|||p|}
проверяет, являются ли {\tt x} и
{\tt y} одним объектом (то есть, равны ли {\tt x} и
{\tt y} друг другу как указатели).  Так что, если
{\tt z1} и {\tt z2} определены как на
рисунках~\ref{P3.16} и \ref{P3.17},
{\tt (eq? (car z1) (cdr z1))} будет истинно, а
{\tt (eq? (car z2) (cdr z2))} ложно.

\index{ru}{изменяемые объекты данных|разделяемые данные||||}
Как будет видно в последующих разделах, с помощью
разделения данных мы значительно расширим репертуар структур данных,
которые могут быть представлены через пары.  С другой стороны,
разделение сопряжено с риском, поскольку изменения в одних
структурах могут затрагивать и другие структуры, разделяющие те части,
которые подвергаются изменению.  Операции изменения
{\tt set-car!} и {\tt set-cdr!} нужно использовать
осторожно; если у нас нет точного понимания, какие из наших объектов
разделяют данные, изменение может привести к неожиданным
результатам\footnote{Тонкости работы с разделением изменяемых данных
отражают сложности с понятием <<идентичности>> и <<изменения>>, о
которых мы говорили в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}.  Там мы
отметили, что введение в наш язык понятия изменения требует,
чтобы у составного объекта была <<индивидуальность>>, которая
представляет собой нечто отличное от частей, из которых он состоит.  В
Лиспе мы считаем, что именно эта <<индивидуальность>> проверяется
предикатом {\tt eq?}, то есть сравнением указателей.  Поскольку
в большинстве реализаций Лиспа указатель~--- это, в сущности, адрес в
памяти, мы <<решаем проблему>> определения индивидуальности объектов,
постановив, что <<сам>> объект данных есть информация, хранимая в
некотором наборе ячеек памяти компьютера.  Для простых лисповских программ
этого достаточно, но такой метод не способен разрешить общий вопрос
<<идентичности>> в вычислительных моделях.
}.
\begin{exercise}{3.15}\label{EX3.15}%
Нарисуйте стрелочные диаграммы, объясняющие, как
{\tt set-to-wow!} действует на структуры {\tt z1} и
{\tt z2} из этого раздела.
\end{exercise}
\begin{exercise}{3.16}\label{EX3.16}%
Бен Битобор решил написать процедуру для подсчета
числа пар в любой списковой структуре. <<Это легко, --- думает он.
--- Число пар в любой структуре есть число пар в {\tt car} плюс
число пар в {\tt cdr} плюс один на текущую пару>>. И  он
пишет следующую процедуру:

\begin{Verbatim}[fontsize=\small]
(define (count-pairs x)\index{ru}{count-pairs||||pd|(упр.~3.16)}
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
\end{Verbatim}
Покажите, что эта процедура ошибочна.  В частности, нарисуйте
диаграммы, представляющие списковые структуры
ровно из трех пар, для которых Бенова процедура вернет 3; вернет 4;
вернет 7; вообще никогда не завершится.
\end{exercise}
\begin{exercise}{3.17}\label{EX3.17}%
Напишите правильную версию процедуры
{\tt count-pairs} из упражнения~\ref{EX3.16},
которая возвращает число различных пар в любой структуре.  (Подсказка:
просматривайте структуру, поддерживая при этом вспомогательную
структуру, следящую за тем, какие пары уже были посчитаны.)
\end{exercise}
\begin{exercise}{3.18}\label{EX3.18}%
\index{ru}{цикл в списке|обнаружение||||(упр.~3.18)}Напишите процедуру, которая рассматривает список и
определяет, содержится ли в нем цикл, то есть, не войдет ли программа,
которая попытается добраться до конца списка, продвигаясь по полям
{\tt cdr}, в бесконечный цикл.  Такие списки порождались в
упражнении~\ref{EX3.13}.
\end{exercise}
\begin{exercise}{3.19}\label{EX3.19}%
Переделайте упражнение~\ref{EX3.18},
используя фиксированное количество памяти.  (Тут нужна достаточно
хитрая идея.)
\end{exercise}

\paragraph{Изменение как присваивание}


\index{ru}{изменяемые объекты данных|реализованные с помощью
присваиваний||||}\index{ru}{изменяемые объекты данных|процедурное
представление||||}\index{ru}{процедурное представление данных|изменяемые
данные||||}\index{ru}{пара (пары)|процедурное
представление||||}Когда мы вводили понятие составных данных, в
разделе~\ref{WHAT-IS-MEANT-BY-DATA} мы заметили, что пары можно
представить при помощи одних только процедур:

\begin{Verbatim}[fontsize=\small]
(define (cons x y)\index{ru}{cons (элементарная процедура)|реализация с мутаторами|||pd|}
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Неопределенная операция -- CONS" m))))
  dispatch)

(define (car z) (z 'car))\index{ru}{car (элементарная процедура)|реализация с мутаторами|||pd|}

(define (cdr z) (z 'cdr))\index{ru}{cdr (элементарная процедура)|реализация с мутаторами|||pd|}
\end{Verbatim}
То же наблюдение верно и для изменяемых данных.  Изменяемые объекты
данных можно реализовать при помощи процедур и внутреннего состояния.
Например, можно расширить приведенную реализацию пар, так, чтобы
{\tt set-car!} и {\tt set-cdr!} обрабатывались
по аналогии с реализацией банковских счетов через
{\tt make-account} из раздела~\ref{LOCAL-STATE-VARIABLES}:
\looseness=1

\begin{Verbatim}[fontsize=\small]
(define (cons x y)\index{ru}{cons (элементарная процедура)|процедурная реализация|||pd|}
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Неопределенная операция -- CONS" m))))
  dispatch)

(define (car z) (z 'car))\index{ru}{car (элементарная процедура)|процедурная реализация|||pd|}

(define (cdr z) (z 'cdr))\index{ru}{cdr (элементарная процедура)|процедурная реализация|||pd|}

(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)

(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
\end{Verbatim}
\pagebreak

Теоретически, чтобы описать поведение изменяемых данных, не требуется
ничего, кроме присваивания.  Как только мы вводим в наш язык
{\tt set!}, мы сталкиваемся со всеми проблемами, не только
собственно присваивания, но и вообще изменяемых данных\footnote{С другой стороны, с точки зрения реализации,
присваивание требует модификации окружения, которое само по себе
является изменяемой структурой данных.  Таким образом, присваивание и
изменяемость данных обладают равной мощностью: каждое из них можно
реализовать при помощи другого.
}.
\begin{exercise}{3.20}\label{EX3.20}%
Нарисуйте диаграммы окружений, изображающие выполнение
последовательности выражений

\begin{Verbatim}[fontsize=\small]
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)

(car x)
\textit{17}
\end{Verbatim}
с помощью вышеприведенной процедурной реализации пар. (Ср. с
упражнением~\ref{EX3.11}.)
\end{exercise}

\subsection{Представление очередей}
\label{REPRESENTING-QUEUES}

\index{ru}{очередь|||||}
Мутаторы {\tt set-car!} и {\tt set-cdr!}
позволяют нам строить из пар такие структуры, какие мы не смогли бы
создать только при помощи {\tt cons}, {\tt car} и
{\tt cdr}.  В этом разделе будет показано, как представить
структуру данных, которая называется очередь.  В
разделе~\ref{REPRESENTING-TABLES} мы увидим, как реализовать
структуру, называемую таблицей.

\begin{cntrfig}
\begin{tabular}{ll}
Операция                        & Результат \\
{\tt (define q (make-queue)}    & \\
{\tt (insert-queue! q 'a)}      & a \\
{\tt (insert-queue! q 'b)}       & {\tt a b} \\
{\tt (delete-queue! q)}          & {\tt b}\\
{\tt (insert-queue! q 'c)}       & {\tt b c}\\
{\tt (insert-queue! q 'd)}       & {\tt b c d}\\
{\tt (delete-queue! q)}          & {\tt c d}\\
\end{tabular}
\caption{Операции над очередью.\index{ru}{очередь|операции||||} }
\label{P3.18}
\end{cntrfig}

\index{ru}{очередь||queue|||}\index{en}{queue||очередь|||}{\em Очередь} (queue) представляет собой
последовательность, в которую можно добавлять элементы с одного конца
(он называется \index{ru}{очередь|хвост|queue|rear||}\index{en}{queue|rear|очередь|хвост||}{\em хвостом} (rear))
и убирать с другого (он называется
\index{ru}{очередь|голова|queue|front||}\index{en}{queue|front|очередь|голова||}{\em головой} (front)).  На
рисунке~\ref{P3.18} изображено, как в изначально пустую очередь
добавляются элементы  {\tt a} и {\tt b}.  Затем
{\tt a} убирается из очереди, в нее добавляются {\tt c}
и {\tt d}, потом удаляется {\tt b}.  Поскольку элементы
удаляются всегда в том же порядке, в котором они были добавлены,
иногда очередь называют\index{ru}{буфер|FIFO|buffer|||}\index{en}{buffer||буфер|FIFO||} буфером\index{ru}{FIFO|||||} {\em FIFO} (англ. first in, first out
--- первым вошел, первым вышел).


С точки зрения \index{ru}{абстракция данных|для очереди||||}абстракции данных, можно считать, что
очередь определяется следующим набором операций:
\pagebreak
\begin{plainlist}
\samepage
\item
конструктор {\tt (make-queue)}\index{ru}{make-queue||||p|} возвращает пустую очередь (очередь, в которой нет ни одного элемента).

\item
два селектора: {\tt (empty-queue? \textit{$\langle$очередь$\rangle$})}\index{ru}{empty-queue?||||p|} проверяет, пуста ли очередь, {\tt (front-queue \textit{$\langle$очередь$\rangle$})}\index{ru}{front-queue||||p|} возвращает объект, находящийся в голове очереди.  Если очередь пуста,
он сообщает об ошибке. Очередь не модифицируется.

\item
Два мутатора: {\tt (insert-queue! \textit{$\langle$очередь$\rangle$} \textit{$\langle$элемент$\rangle$})}\index{ru}{insert-queue!||||p|}
вставляет элемент в хвост очереди и возвращает в качестве значения
измененную очередь; {\tt (delete-queue! \textit{$\langle$очередь$\rangle$})}\index{ru}{delete-queue!||||p|}
удаляет элемент в голове очереди и возвращает в качестве значения
измененную очередь.  Если перед уничтожением элемента очередь
оказывается пустой, выводится сообщение об ошибке.
\end{plainlist}

Поскольку очередь есть последовательность элементов, ее,
разумеется, можно было бы представить как обыкновенный список;
головой очереди был бы {\tt car} этого списка, вставка
элемента в очередь сводилась бы к добавлению нового элемента в конец
списка, а уничтожение элемента из очереди состояло бы просто во взятии
{\tt cdr} списка.  Однако такая реализация неэффективна,
поскольку для вставки элемента нам пришлось бы просматривать весь
список до конца.   Поскольку единственный доступный нам метод
просмотра списка --- это последовательное применение {\tt cdr},
такой просмотр требует $\Theta (n)$ шагов для очереди с
{\tt n} членами.  Простое видоизменение спискового представления
преодолевает этот недостаток, позволяя нам реализовать операции с
очередью так, чтобы все они требовали $\Theta(1)$ шагов;
то есть, чтобы число шагов алгоритма не зависело от длины очереди.

Сложность со списковым представлением возникает из-за
необходимости искать конец списка.  Искать приходится потому, что,
хотя стандартный способ представления списка в виде цепочки
пар дает нам указатель на начало списка, легкодоступного указателя на
конец он не дает.  Модификация, обходящая этот недостаток, состоит в
том, чтобы представлять очередь в виде списка, и держать еще
дополнительный указатель на его последнюю пару.  В таком случае, когда
требуется вставить элемент, мы можем просто посмотреть на этот
указатель и избежать за счет этого просмотра всего списка.

{Очередь, таким образом, представляется в виде пары
указателей, {\tt front-ptr} и {\tt rear-ptr}, которые
обозначают, соответственно, первую и последнюю пару обыкновенного
списка.  Поскольку нам хочется, чтобы очередь была объектом с
собственной индивидуальностью,  соединить эти два указателя
можно с помощью {\tt cons}, так что собственно очередь будет
результатом {\tt cons} двух указателей.  Такое представление
показано на рис.~\ref{P3.19}.

\sloppy
}%HERE229

\begin{cntrfig}
\input{xfig-mod/3-19.eepic}
\caption{Реализация очереди в виде списка с
указателями на начало и конец.}
\label{P3.19}

\end{cntrfig}

Во время определения операций над очередью мы пользуемся
следующими процедурами, которые позволяют нам читать и записывать
указатели на начало и конец очереди:

\begin{Verbatim}[fontsize=\small]
(define (front-ptr queue) (car queue))\index{ru}{front-ptr||||pd|}

(define (rear-ptr queue) (cdr queue))\index{ru}{rear-ptr||||pd|}

(define (set-front-ptr! queue item) (set-car! queue item))\index{ru}{set-front-ptr!||||pd|}

(define (set-rear-ptr! queue item) (set-cdr! queue item))\index{ru}{set-rear-ptr!||||pd|}
\end{Verbatim}

Теперь можно реализовать сами операции над очередью.
Очередь будет считаться пустой, если ее головной указатель указывает на пустой
список:

\begin{Verbatim}[fontsize=\small]
(define (empty-queue? queue) (null? (front-ptr queue)))\index{ru}{empty-queue?||||pd|}
\end{Verbatim}
Конструктор {\tt make-queue} возвращает в качестве исходно
пустой очереди пару, в которой и {\tt car}, и {\tt cdr}
являются пустыми списками:

\begin{Verbatim}[fontsize=\small]
(define (make-queue) (cons '() '()))\index{ru}{make-queue||||pd|}
\end{Verbatim}
При обращении к элементу в голове очереди мы возвращаем {\tt car}
пары, на которую указывает головной указатель:

\begin{Verbatim}[fontsize=\small]
(define (front-queue queue)\index{ru}{front-queue||||pd|}
  (if (empty-queue? queue)
      (error "FRONT вызвана с пустой очередью" queue)
      (car (front-ptr queue))))
\end{Verbatim}
Чтобы вставить элемент в конец очереди, мы используем метод, результат
которого показан на рисунке~\ref{P3.20}.  Первым делом мы
создаем новую пару, {\tt car} которой содержит вставляемый
элемент, а {\tt cdr} --- пустой список.  Если очередь была
пуста, мы перенаправляем на эту пару и головной, и хвостовой указатели.
В противном случае, мы изменяем последнюю пару очереди так, чтобы
следующей была новая пара, и хвостовой указатель тоже перенаправляем на
нее же.

\begin{Verbatim}[fontsize=\small]
(define (insert-queue! queue item)\index{ru}{insert-queue!||||pd|}
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
\end{Verbatim}


\begin{cntrfig}
\input{xfig-mod/3-20.eepic}
\caption{Результат применения
{\tt (insert-queue! q 'd)} к очереди с
рисунка~\ref{P3.19}}
\label{P3.20}

\end{cntrfig}

Чтобы уничтожить элемент в голове очереди, мы просто
переставляем головной указатель на второй элемент очереди, а его можно
найти в {\tt cdr} первого элемента
(см.~рис.~\ref{P3.21})\footnote{В случае, если первый элемент --- одновременно и последний,
после его уничтожения головной указатель окажется пустым списком, и
это будет означать, что очередь пуста; нам незачем заботиться о хвостовом
указателе, который по-прежнему будет указывать на уничтоженный
элемент, поскольку {\tt empty-queue?} смотрит
только на голову.}:

\begin{Verbatim}[fontsize=\small]
(define (delete-queue! queue)\index{ru}{delete-queue!||||pd|}
  (cond ((empty-queue? queue)
         (error "DELETE! вызвана с пустой очередью" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))
\end{Verbatim}


\begin{cntrfig}
\input{xfig-mod/3-21.eepic}
\caption{ Результат применения {\tt (delete-queue!
q)} к очереди с рис.~\ref{P3.20}.}
\label{P3.21}

\end{cntrfig}
\begin{exercise}{3.21}\label{EX3.21}%
Бен Битобор решает протестировать вышеописанную
реализацию.  Он вводит процедуры в интерпретаторе Лиспа и тестирует их:

\begin{Verbatim}[fontsize=\small]
(define q1 (make-queue))

(insert-queue! q1 'a)
\textit{((a) a)}

(insert-queue! q1 'b)
\textit{((a b) b)}

(delete-queue! q1)
\textit{((b) b)}

(delete-queue! q1)
\textit{(() b)}
\end{Verbatim}
<<Ничего не работает!~--- жалуется он.~--- Ответ интерпретатора показывает,
что последний элемент попадает в очередь два раза.  А когда я оба
элемента уничтожаю, второе {\tt b} по-прежнему там сидит, так
что очередь не становится пустой, хотя должна бы>>. Ева Лу Атор
говорит, что Бен просто не понимает, что происходит. <<Дело не в том,
что элементы два раза оказываются в очереди,~--- объясняет
она.~--- Дело в том, что стандартная лисповская печаталка не знает, как устроено
представление очереди.  Если ты хочешь, чтобы очередь правильно
печаталась, придется написать специальную процедуру распечатки
очередей>>. Объясните, что имеет в виду Ева Лу.  В частности,
объясните, почему в примерах Бена на печать выдается именно такой
результат. Определите процедуру  \index{ru}{print-queue||||p|(упр.~3.21)}
{\tt print-queue}, которая
берет на входе очередь и выводит на печать последовательность ее
элементов.
\end{exercise}
\begin{exercise}{3.22}\label{EX3.22}%
\index{ru}{очередь|реализация в виде процедуры||||(упр.~3.22)}%
Вместо того, чтобы представлять очередь как пару
указателей, можно построить ее в виде процедуры с внутренним
состоянием.  Это состояние будет включать указатели на начало и конец
обыкновенного списка.  Таким образом, {\tt make-queue} будет
иметь вид

\begin{Verbatim}[fontsize=\small]
(define (make-queue)
  (let ((front-ptr ...)
        (rear-ptr ...))
    \textit{$\langle$определения внутренних процедур$\rangle$}
    (define (dispatch m) ...)
    dispatch))
\end{Verbatim}
Закончите определение {\tt make-queue} и реализуйте операции
над очередями с помощью этого представления.
\end{exercise}
\begin{exercise}{3.23}\label{EX3.23}%
\index{ru}{дек||deque|||(упр.~3.23)}\index{en}{deque||дек|||(упр.~3.23)}{\em Дек} (deque, double-ended queue,
<<двусторонняя очередь>>) \index{ru}{очередь|двусторонняя||||(упр.~3.23)}
представляет собой последовательность,
элементы в которой могут добавляться и уничтожаться как с головы, так
и с хвоста.  На деках определены такие операции: конструктор
{\tt make-deque}, предикат {\tt empty-deque?}, селекторы
{\tt front-deque} и {\tt rear-deque}, и мутаторы
{\tt front-insert-deque!}, {\tt rear-insert-deque!},
{\tt front-delete-deque!} и {\tt rear-delete-deque!}.
Покажите, как представить дек при помощи пар, и напишите реализацию
операций\footnote{Осторожно, не заставьте ненароком интерпретатор
печатать циклическую структуру (см.~упр.~\ref{EX3.13}).
}.%HERE232
Все операции должны выполняться за
$\Theta(1)$ шагов.
\end{exercise}

\subsection{Представление таблиц}
\label{REPRESENTING-TABLES}


Когда в главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA} мы изучали различные
способы представления множеств, то в
разделе~\ref{EXAMPLE-REPRESENTING-SETS} была упомянута задача
поддержания \index{ru}{ключ записи|в таблице||||}
\index{ru}{таблица|||||}таблицы с идентифицирующими ключами.  При реализации
программирования, управляемого данными, в
разделе~\ref{DATA-DIRECTED-PROGRAMMING-AND-ADDITIVITY}, активно
использовались двумерные таблицы, в которых информация заносится и
ищется с использованием двух ключей.  Теперь мы увидим, как такие
таблицы можно строить при помощи изменяемых списковых структур.


\begin{cntrfig}
\input{xfig-mod/3-22.eepic}
\caption{Таблица, представленная в виде списка с
заголовком.}
\label{P3.22}

\end{cntrfig}

Сначала рассмотрим \index{ru}{таблица|одномерная||||}одномерную таблицу, где каждый
элемент хранится под отдельным ключом.  Ее мы реализуем как список
записей, каждая из которых представляет собой пару, состоящую из ключа
и связанного с ним значения.  Пары связаны вместе в список при помощи
цепочки пар, в каждой из которых {\tt car} указывают на одну из
записей. Эти связующие пары называются
\index{ru}{таблица|хребет|table|backbone||}\index{en}{table|backbone|таблица|хребет||}{\em хребтом} (backbone) таблицы. Для
того, чтобы у нас было место, которое мы будем изменять при добавлении
новой записи, таблицу мы строим как
\index{ru}{список|с заголовком|list|headed||}\index{en}{list|headed|список|с заголовком||}{\em список с
заголовком} (headed list).  У такого списка есть в начале специальная хребтовая
пара, в которой хранится фиктивная <<запись>>~--- в данном случае
произвольно выбранный символ {\tt *table*}.  На
рисунке~\ref{P3.22} изображена стрелочная диаграмма
для таблицы

\begin{Verbatim}[fontsize=\small]
a: 1
b: 2
c: 3
\end{Verbatim}

Информацию из таблицы можно извлекать при помощи процедуры
{\tt lookup}, которая получает ключ в качестве аргумента, а
возвращает связанное с ним значение (либо ложь, если в таблице с
этим ключом никакого значения не связано). {\tt Lookup} определена
при помощи операции {\tt assoc}, которая требует в виде
аргументов ключ и список записей.  Обратите внимание, что
{\tt assoc} не видит фиктивной записи. {\tt Assoc}
возвращает запись, которая содержит в {\tt car} искомый
ключ\footnote{Поскольку {\tt assoc} пользуется
{\tt equal?}, в качестве ключей она может распознавать символы,
числа и списковые структуры.
}.
Затем {\tt lookup} проверяет, что запись, возвращенная
{\tt assoc}, не есть ложь, и возвращает значение (то есть
{\tt cdr}) записи.

\begin{Verbatim}[fontsize=\small]
(define (lookup key table)\index{ru}{lookup|в одномерной таблице|||pd|}
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))

(define (assoc key records)\index{ru}{assoc||||pd|}
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
\end{Verbatim}

Чтобы вставить в таблицу значение под данным ключом,
сначала мы с помощью {\tt assoc} проверяем, нет ли уже в
таблице записи с этим ключом.  Если нет, мы формируем новую запись,
<<с{\tt cons}ивая>> ключ со значением, и вставляем ее в начало
списка записей таблицы, после фиктивной записи.  Если же в таблице уже
была запись с этим ключом, мы переставляем {\tt cdr} записи на
указанное новое значение.  Заголовок таблицы используется как неподвижное
место, которое мы можем изменять при порождении новой
записи\footnote{Таким образом, первая хребтовая пара является объектом,
который представляет <<саму>> таблицу; то есть, указатель на таблицу
--- это указатель на эту пару.  Таблица всегда начинается с одной и
той же хребтовой пары.  Будь это устроено иначе, пришлось бы
возвращать из {\tt insert!} новое начало таблицы в
том случае, когда создается новая запись.
}.

\begin{Verbatim}[fontsize=\small]
(define (insert! key value table)\index{ru}{insert!|для одномерной таблицы|||pd|}
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
\end{Verbatim}

Для того, чтобы создать таблицу, мы просто порождаем
список, содержащий символ {\tt *table*}:

\begin{Verbatim}[fontsize=\small]
(define (make-table)\index{ru}{make-table|одномерная таблица|||pd|}
  (list '*table*))
\end{Verbatim}

\paragraph{Двумерные таблицы}

\index{ru}{таблица|двумерная||||}
В двумерной таблице каждое значение индексируется двумя
ключами.  Такую таблицу мы можем построить как одномерную таблицу, в
которой каждый ключ определяет подтаблицу.  На
рисунке~\ref{P3.23} изображена стрелочная диаграмма для таблицы

\begin{Verbatim}[fontsize=\small]
math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
\end{Verbatim}
содержащей две подтаблицы (подтаблицам не требуется специального
заголовочного символа, поскольку для этой цели служит ключ,
идентифицирующий подтаблицу).


\begin{cntrfig}
\input{xfig-mod/3-23.eepic}
\caption{Двумерная таблица.}
\label{P3.23}

\end{cntrfig}

Когда мы ищем в таблице элемент, сначала при помощи
первого ключа мы находим нужную подтаблицу. Затем при помощи второго
ключа мы определяем запись внутри подтаблицы.

\begin{Verbatim}[fontsize=\small]
(define (lookup key-1 key-2 table)\index{ru}{lookup|в двумерной таблице|||pd|}
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
\end{Verbatim}

Чтобы вставить в таблицу новый элемент под двумя ключами,
мы при помощи {\tt assoc} проверяем, соответствует ли
какая-нибудь подтаблица первому ключу.  Если нет, строим новую
подтаблицу, содержащую единственную запись
({\tt key-2}, {\tt value}), и заносим
ее в таблицу под первым ключом.  Если для первого ключа уже существует
подтаблица, мы вставляем новую запись в эту подтаблицу, используя
вышеописанный метод вставки для одномерных таблиц:

\begin{Verbatim}[fontsize=\small]
(define (insert! key-1 key-2 value table)\index{ru}{insert!|для двумерной таблицы|||pd|}
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
\end{Verbatim}

\paragraph{Создание локальных таблиц}

\index{ru}{таблица|локальная||||}
Операции {\tt lookup} и {\tt insert!},
которые мы определили, принимают таблицу в качестве аргумента.  Это
позволяет писать программы, которые обращаются более, чем к одной
таблице.  Другой способ работы с множественными таблицами заключается
в том, чтобы иметь для каждой из них свои отдельные процедуры {\tt lookup}
и {\tt insert!}.  Мы можем этого добиться, представив таблицу
в процедурном виде, как объект, который поддерживает внутреннюю
таблицу как часть своего локального состояния.  Когда ему посылают
соответствующее сообщение, этот <<табличный объект>> выдает процедуру,
с помощью которой можно работать с его внутренним состоянием.  Вот
генератор двумерных таблиц, представленных таким способом:

\begin{Verbatim}[fontsize=\small]
(define (make-table)\index{ru}{make-table|реализация через передачу сообщений|||pd|}
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Неизвестная операция -- TABLE" m))))
    dispatch))
\end{Verbatim}

{\tt Make-table} позволяет нам реализовать
операции {\tt get} и {\tt put} из
раздела~\ref{DATA-DIRECTED-PROGRAMMING-AND-ADDITIVITY}, так:

{\small
\begin{Verbatim}[fontsize=\small]
(define operation-table (make-table))\index{ru}{operation-table||||pd|} \index{ru}{таблица операций и типов|реализация||||}
(define get (operation-table 'lookup-proc))\index{ru}{get||||pd|}
(define put (operation-table 'insert-proc!))\index{ru}{put||||pd|}
\end{Verbatim}
}
{\tt Get} в качестве аргументов берет два ключа, а
{\tt put} два ключа и значение.  Обе операции обращаются к
одной и той же локальной таблице, которая инкапсулируется в объекте,
созданном посредством вызова {\tt make-table}.
\begin{exercise}{3.24}\label{EX3.24}%
\index{ru}{ключ записи|проверка на равенство||||(упр.~3.24)}%
\index{ru}{таблица|проверка равенства ключей||||(упр.~3.24)}%
В реализациях таблиц в этом разделе ключи всегда
проверяются на равенство с помощью {\tt equal?} (который, в
свою очередь, зовется из {\tt assoc}).  Это не всегда то, что
нужно.  Например, можно представить себе таблицу с числовыми ключами,
где не требуется точного совпадения с числом, которое мы ищем, а
нужно только совпадение с определенной допустимой ошибкой.  Постройте
конструктор таблиц {\tt make-table}, который в качестве
аргумента принимает процедуру {\tt same-key?} для проверки
равенства ключей.  {\tt Make-table} должна возвращать процедуру
{\tt dispatch}. через которую можно добраться до процедур
{\tt lookup} и {\tt insert!} локальной таблицы.
\end{exercise}
\begin{exercise}{3.25}\label{EX3.25}%
Обобщая случаи
\index{ru}{таблица|$n$-мерная|table|||(упр.~3.25)}\index{en}{table||таблица|$n$-мерная||(упр.~3.25)}
одно- и двумерных таблиц, покажите, как
можно реализовать таблицу, в которой элементы хранятся с произвольным
количеством ключей и различные значения могут храниться с различным
количеством ключей. Процедуры {\tt lookup} и
{\tt insert!} должны принимать на входе список ключей, с
которыми требуется обратиться к таблице.
\end{exercise}
\begin{exercise}{3.26}\label{EX3.26}%
\index{ru}{таблица|представленная в виде бинарного дерева vs. неупорядоченного списка||||(упр.~3.26)}При поиске в таблице, как она реализована выше,
приходится просматривать список записей.  В сущности, это
представление с неупорядоченным списком из
раздела~\ref{EXAMPLE-REPRESENTING-SETS}.  Для больших таблиц может
оказаться эффективнее организовать таблицу иначе.  Опишите реализацию
\index{ru}{бинарное дерево|таблицы||||(упр.~3.26)} таблицы, в которой записи
(ключ, значение) организованы в виде
бинарного дерева, в предположении, что ключи можно каким-то образом
упорядочить (например, численно или по алфавиту). (Ср. с
упражнением~\ref{EX2.66} из
главы~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}.)
\end{exercise}
\begin{exercise}{3.27}\label{EX3.27}%
\index{ru}{мемоизация||memoization|||(упр.~3.27)}%
\index{en}{memoization||мемоизация|||(упр.~3.27)}{\em Мемоизация} (memoization)
\index{ru}{процедура|мемоизированная||||(упр.~3.27)}%
\index{ru}{таблица|используемая для хранения вычисленных значений||||(упр.~3.27)}%
(называемая также \index{ru}{табуляризация||tabulation|||(упр.~3.27)}%
\index{en}{tabulation||табуляризация|||(упр.~3.27)}{\em табуляризация} (tabulation)) ---
%MLR% -- может, поставить внутри квадратные скобки?
прием, который позволяет процедуре записывать в локальной таблице
единожды вычисленные значения.  Такой прием может сильно повысить
производительность программы.  Мемоизированная процедура поддерживает
таблицу, где сохраняются результаты предыдущих вызовов, а в
качестве ключей используются аргументы, относительно которых эти результаты
были получены.  Когда от мемоизированной процедуры требуют вычислить
значение, сначала она проверят в таблице, нет ли там уже нужного
значения, и если да, то она просто возвращает это значение.  Если нет,
то она вычисляет значение обычным способом и заносит его в таблицу.  В
качестве примера мемоизации, вспомним экспоненциальный процесс
вычисления чисел Фибоначчи из
раздела~\ref{TREE-RECURSION}:
\index{ru}{fib|с мемоизацией|||pd|(упр.~3.27)}

\begin{Verbatim}[fontsize=\small]
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
\end{Verbatim}
Мемоизированная версия той же самой процедуры выглядит так:

\begin{Verbatim}[fontsize=\small]
(define memo-fib\index{ru}{memo-fib||||pd|(упр.~3.27)}
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
\end{Verbatim}
а процедура {\tt memoize} определяется так:

\begin{Verbatim}[fontsize=\small]
(define (memoize f)\index{ru}{memoize||||pd|(упр.~3.27)}
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
\end{Verbatim}
Нарисуйте диаграмму окружений, анализирующую вычисление
{\tt (memo-fib 3)}.  Объясните, почему {\tt memo-fib}
вычисляет $n$-е число Фибоначчи за число шагов,
пропорциональное $n$.  Стала бы схема работать, если бы мы
определили {\tt memo-fib} просто как {\tt (memoize fib)}?
\end{exercise}

\subsection{Имитация цифровых схем}
\label{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}


\index{ru}{имитация цифровых схем|||||}
Проектирование сложных цифровых систем, таких, как
компьютеры, является важной отраслью инженерной деятельности.
Цифровые системы строятся путем соединения простых элементов. Хотя
поведение этих составляющих элементов примитивно,
сети, из них собранные, могут обладать весьма сложным поведением.
Компьютерная имитация проектируемых электронных схем служит важным
инструментом для инженеров-специалистов по цифровым системам.  В этом
разделе мы спроектируем систему для имитационного моделирования
цифровых схем.  Система эта будет служить примером программ особого вида,
называемых \index{ru}{имитация|управляемая событиями|simulation|event-driven||}\index{en}{simulation|event-driven|имитация|управляемая событиями||}{\em имитация,
управляемая событиями} (event-driven simulation), в которых действия (<<события>>) вызывают
другие события, которые происходят спустя некоторое время и при этом в
свою очередь вызывают события, и так далее.

Наша вычислительная модель цифровой схемы будет состоять из
объектов, соответствующих элементарным компонентам, из которых
строится схема.  Имеются
\index{ru}{провод, в цифровой схеме||wire|||}\index{en}{wire||провод, в цифровой схеме|||}{\em провода} (wires), несущие
\index{ru}{цифровой сигнал||digital signal|||}\index{en}{digital signal||цифровой сигнал|||}{\em цифровые сигналы} (digital signals).  В каждый
данный момент цифровой сигнал может иметь только одно из двух
возможных значений, 0 или 1.  Кроме того, имеются различные виды
\index{ru}{функциональный элемент в цифровых схемах||function box|||}\index{en}{function box||функциональный элемент в цифровых схемах|||}{\em функциональных элементов} (function boxes),
которые соединяют провода, несущие входные сигналы, с выходными
проводами. Такие элементы порождают выходные сигналы, вычисляя их на
основе входных сигналов.  Выходной сигнал
\index{ru}{задержка, в цифровой схеме||delay, in     digital circuit|||}\index{en}{delay, in     digital circuit||задержка, в цифровой схеме|||}
задерживается на время,
зависящее от типа функционального элемента.  Например,
\index{ru}{инвертор||inverter|||}\index{en}{inverter||инвертор|||}{\em инвертор} (inverter) --- элементарный функциональный
элемент, который обращает свой входной сигнал.  Если входной сигнал
инвертора становится 0, то на одну инверторную задержку позже сигнал на
выходе станет равен 1.  Если входной сигнал станет 1, то на
инверторную задержку позже на выходе появится 0.  Инвертор
символически изображен на рис.~\ref{P3.24}.
\index{ru}{И-элемент||and-gate|||}\index{en}{and-gate||И-элемент|||}{\em
  И-элемент} (and-gate), также показанный на
рис.~\ref{P3.24}, имеет два входа и один выход.
\index{ru}{И-элемент|||||}
Он
обеспечивает на выходе сигнал, равный
\index{ru}{логическое И||logical and|||}\index{en}{logical and||логическое И|||}{\em логическому И} (logical and) от входов.  Это
означает, что если оба входных сигнала становятся равными 1, то одну
И-задержку спустя И-элемент заставит свой выходной сигнал стать 1; в
противном случае на выходе будет 0.

\index{ru}{ИЛИ-элемент||or-gate|||}\index{en}{or-gate||ИЛИ-элемент|||}{\em ИЛИ-элемент} (or-gate) представляет собой
подобный же элементарный функциональный элемент, который обеспечивает
на выходе сигнал, равный \index{ru}{логическое ИЛИ||logical or|||}\index{en}{logical or||логическое ИЛИ|||}{\em логическому
ИЛИ} (logical or) своих входов.  А именно, выходной сигнал станет равен 1, если хотя бы
один из входных сигналов окажется 1; в противном случае на выходе
будет 0.


\begin{cntrfig}
\input{xfig-mod/3-24.eepic}

\begin{tabular}{ccc}
%(инвертор)\quad \= (И-элемент)\quad \= (ИЛИ-элемент)\kill
Inverter   & And-gate  &Or-gate \\
(инвертор) &(И-элемент) &  (ИЛИ-элемент)
\end{tabular}
%{\small Inverter (инвертор)\\
%And-gate (И-элемент)\\
%Or-gate (ИЛИ-элемент)}
\caption{Элементарные функциональные элементы в
имитаторе цифровых схем.}
\label{P3.24}

\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/3-25.eepic}
\caption{Полусумматор.}
\label{P3.25}

\end{cntrfig}

Соединяя элементарные функции, можно получать более
сложные.  Для этого надо подсоединять выходы одних функциональных
элементов ко входам других. Например, схема
\index{ru}{полусумматор||half-adder|||}\index{en}{half-adder||полусумматор|||}{\em полусумматора} (half-adder) на
\index{ru}{сумматор|полу-||||}
рис.~\ref{P3.25} состоит из ИЛИ-элемента, двух И-элементов
и инвертора.  Полусумматор получает два входа,  A и B, и имеет два
выхода, S и C.  S становится 1, когда ровно один из сигналов A и B
равен 1, а C тогда, когда и A, и B  равны 1.  Из схемы можно видеть,
что по причине задержек выходные сигналы могут генерироваться в разное
время.  Отсюда происходят многие сложности в проектировании
цифровых схем.
\pagebreak

Теперь мы построим программу для имитации цифровых
логических схем, которые мы хотим изучать.  Программа будет строить
вычислительные объекты, моделирующие провода, которые <<содержат>>
сигналы.  Функциональные элементы будут моделироваться процедурами,
которые обеспечивают нужное отношение между сигналами.

Одним из базовых элементов нашей имитации будет процедура
{\tt make-wire},
\index{ru}{make-wire||||p|}
которая порождает провода.  Например, мы можем
создать шесть проводов так:

\begin{Verbatim}[fontsize=\small]
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
\end{Verbatim}
Мы подсоединяем функциональный элемент к проводу во время вызова
процедуры, которая создает данный вид элемента.  Аргументами
порождающей процедуры служат провода, подсоединяемые к
элементу.  Например, если мы умеем создавать И-элементы, ИЛИ-элементы
и инверторы, мы можем собрать полусумматор, изображенный на
рисунке~\ref{P3.25}:

\begin{Verbatim}[fontsize=\small]
(or-gate a b d)
\textit{ok}

(and-gate a b c)
\textit{ok}

(inverter c e)
\textit{ok}

(and-gate d e s)
\textit{ok}
\end{Verbatim}

Даже лучше того, можно присвоить этой операции имя,
определив процедуру {\tt half-adder},
конструирующую схему, используя четыре внешних провода, которые нужно
подсоединить к полусумматору:
\index{ru}{полусумматор|\texttt{half-adder}||||}

\begin{Verbatim}[fontsize=\small]
(define (half-adder a b s c)\index{ru}{half-adder||||pd|}
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
\end{Verbatim}
Преимущество этого определения в том, что теперь мы можем использовать
{\tt half-adder} как строительный блок при создании более
сложных схем.  Например, на
рисунке~\ref{P3.26} изображен
\index{ru}{сумматор||full-adder|||}\index{en}{full-adder||сумматор|||}{\em сумматор} (full-adder), состоящий из двух
полусумматоров и ИЛИ-элемента\footnote{Сумматор --- основной элемент схем, используемых
для сложения двоичных чисел.  Здесь A и B --- биты на соответствующих
позициях двух складываемых чисел, а С${}_{\mbox{in}}$ --- бит
переноса из позиции на одну правее.  Схема генерирует SUM, бит суммы
для соответствующей позиции, и C${}_{\mbox{out}}$, бит
переноса для распространения налево.
}.
Сумматор можно сконструировать так:
\index{ru}{сумматор|\texttt{full-adder}||||}

\begin{Verbatim}[fontsize=\small]
(define (full-adder a b c-in sum c-out)\index{ru}{full-adder||||pd|}
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
\end{Verbatim}
Определив {\tt full-adder} как процедуру, мы можем ее
использовать как строительный блок для еще более сложных
схем. (См., например, упражнение~\ref{EX3.30}.)


\begin{cntrfig}
\input{xfig-mod/3-26.eepic}
\caption{Сумматор.}
\label{P3.26}

\end{cntrfig}

В сущности, наша имитация дает инструмент, с помощью которого
строится язык описания схем.  Принимая общую точку зрения на
языки, с которой мы приступили к изучению Лиспа в
разделе~\ref{THE-ELEMENTS-OF-PROGRAMMING}, можно сказать, что
элементарные функциональные элементы являются примитивами языка,
связывание их проводами представляет собой средство комбинирования, а
определение шаблонных схем в виде процедур служит средством
абстракции.

\paragraph{Элементарные функциональные элементы.}


\index{ru}{имитация цифровых схем|элементарные функциональные
  элементы|digital-circuit    simulation|||}\index{en}{digital-circuit
  simulation||имитация цифровых схем|элементарные функциональные
  элементы||}Элементарные функциональные элементы изображают <<силы>>,
через посредство которых изменение сигнала в одном проводе влечет
изменение сигнала в других проводах.  Для построения функциональных
элементов мы будем пользоваться следующими операциями над проводами:

\begin{plainlist}
\item
{\tt (get-signal \textit{$\langle$провод$\rangle$})}%
\index{ru}{get-signal||||p|} возвращает текущее значение сигнала в проводе.

\item
{\tt (set-signal! \textit{$\langle$провод$\rangle$} \textit{$\langle$новое-значение$\rangle$})}%
\index{ru}{set-signal!||||p|} заменяет значение сигнала в проводе на указанное.

\item
{\tt (add-action! \textit{$\langle$провод$\rangle$} \textit{$\langle$процедура без аргументов$\rangle$})}%
\index{ru}{add-action!||||p|} указывает, чтобы процедура-аргумент вызывалась каждый раз, когда
сигнальный провод изменяет значение. Такие процедуры служат
передаточным механизмом, с помощью которого изменение значения сигнала
в одном проводе передается другим проводам.  В дополнение, мы будем
пользоваться процедурой {\tt after-delay}, которая принимает
\index{ru}{after-delay||||p|}
значение задержки и процедуру.  Она выполняет процедуру после
истечения задержки.
\end{plainlist}

При помощи этих процедур можно определить
элементарные функции цифровой логики.  Чтобы соединить вход с выходом
через инвертор, мы используем {\tt add-action!} и
ассоциируем со входным проводом процедуру, которая будет вызываться
всякий раз, когда сигнал на входе элемента изменит значение.
Процедура вычисляет {\tt logical-not} (логическое отрицание)
входного сигнала, а затем, переждав {\tt inverter-delay},
устанавливает выходной сигнал в новое значение:

\begin{Verbatim}[fontsize=\small]
(define (inverter input output)\index{ru}{inverter||||pd|}
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)

(define (logical-not s)\index{ru}{logical-not||||pd|}
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Неправильный сигнал" s))))
\end{Verbatim}

И-элемент устроен немного сложнее.  Процедура-действие
должна вызываться, когда меняется любое из значений на входе.  Она при
этом через процедуру, подобную {\tt logical-not},
вычисляет {\tt logical-and} (логическое И) значений сигналов
на входных проводах, и затем требует, чтобы изменение значения
выходного провода произошло спустя задержку длиной в
{\tt and-gate-delay}.

\begin{Verbatim}[fontsize=\small]
(define (and-gate a1 a2 output)\index{ru}{and-gate||||pd|}
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
\end{Verbatim}
\begin{exercise}{3.28}\label{EX3.28}%
 Определите ИЛИ-элемент как элементарный функциональный
блок.  Ваш конструктор {\tt or-gate}
\index{ru}{or-gate||||p|(упр.~3.28)}
должен быть подобен {\tt and-gate}.
\end{exercise}


\begin{cntrfig}
\input{xfig-mod/3-27.eepic}
\caption{Каскадный сумматор для
$n$-битных чисел.}
\label{P3.27}

\end{cntrfig}

\begin{exercise}{3.29}\label{EX3.29}%
 Еще один способ создать ИЛИ-элемент --- это собрать его
как составной блок из И-элементов и инверторов.  Определите процедуру
{\tt or-gate},
\index{ru}{or-gate||||p|(упр.~3.29)}
которая это осуществляет.  Как время
задержки ИЛИ-элемента выражается через {\tt and-gate-delay}
и {\tt inverter-delay}?
\end{exercise}
\begin{exercise}{3.30}\label{EX3.30}%
На рисунке~\ref{EX3.27} изображен
\index{ru}{каскадный сумматор||ripple-carry
  adder|||(упр.~3.30)}\index{en}{ripple-carry adder||каскадный
  сумматор|||(упр.~3.30)}\index{ru}{сумматор|каскадный|adder|ripple-carry||(упр.~3.30)}\index{en}{adder|ripple-carry|сумматор|каскадный||(упр.~3.30)}{\em каскадный сумматор} (ripple-carry adder),
полученный выстраиванием в ряд
$n$ сумматоров.  Это простейшая форма параллельного
сумматора для сложения двух $n$-битных двоичных чисел.  На
входе мы имеем A${}_{\mbox{1}}$,
A${}_{\mbox{2}}$, A${}_{\mbox{3}}$,\ldots
A${}_{\mbox{n}}$ и B${}_{\mbox{1}}$,
B${}_{\mbox{2}}$, B${}_{\mbox{3}}$, \ldots
B${}_{\mbox{n}}$~--- два двоичных числа, подлежащих сложению
(каждый из A${}_{\mbox{k}}$ и B${}_{\mbox{k}}$ имеет
значение либо 0, либо 1).  Схема порождает S${}_{\mbox{1}}$,
S${}_{\mbox{2}}$, S${}_{\mbox{3}}$, \ldots
S${}_{\mbox{n}}$ --- первые $n$ бит суммы, и C
-- бит переноса после суммы.  Напишите процедуру
{\tt riple-carry-adder}, которая бы моделировала эту схему.
Процедура должна в качестве аргументов принимать три списка по
$n$ проводов в каждом (A${}_{\mbox{k}}$,
B${}_{\mbox{k}}$ и S${}_{\mbox{k}}$), а также
дополнительный провод C.  Главный недостаток каскадных сумматоров в
том, что приходится ждать, пока сигнал распространится.
Какова задержка, требуемая для получения полного вывода
$n$-битного каскадного сумматора, выраженная
в зависимости от задержек И-, ИЛИ-элементов и инверторов?
\end{exercise}

\paragraph{Представление проводов}


\index{ru}{имитация цифровых схем|представление проводов||||}
Провод в нашей имитации будет вычислительным объектом с
двумя внутренними переменными состояния: значение сигнала
{\tt signal-value} (вначале равное 0) и набор процедур-действий
{\tt action-procedures}, подлежащих исполнению, когда сигнал
изменяется.  Мы реализуем провод в стиле с
\index{ru}{передача сообщений|в имитаторе цифровых схем||||}
передачей сообщений, как
набор локальных процедур плюс процедура диспетчеризации,
которая выбирает требуемую внутреннюю операцию.  Точно так же мы
строили  объект-банковский счет в
разделе~\ref{LOCAL-STATE-VARIABLES}.

\begin{Verbatim}[fontsize=\small]
(define (make-wire)\index{ru}{make-wire||||pd|}
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Неизвестная операция -- WIRE" m))))
    dispatch))
\end{Verbatim}
Внутренняя процедура {\tt set-my-signal!} проверяет, отличается
ли новое значение сигнала в проводе от старого.  Если да, то она
запускает все процедуры-действия при помощи процедуры
{\tt call-each}, которая по очереди вызывает элементы списка
безаргументных процедур:

\begin{Verbatim}[fontsize=\small]
(define (call-each procedures)\index{ru}{call-each||||pd|}
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
\end{Verbatim}
Внутренняя процедура
{\tt accept-action-procedure!} добавляет про\-це\-ду\-ру-ар\-гу\-мент к
списку действий, а затем один раз запускает новую %HERE243
процедуру. (См.~упражнение~\ref{EX3.31}.)

Располагая вышеописанной процедурой
{\tt dispatch}, мы можем написать следующие процедуры для
доступа к внутренним операциям над
проводами\footnote{\label{FOOT3.27}\index{ru}{синтаксический
    интерфейс||syntax interface|||п}\index{en}{syntax
    interface||синтаксический интерфейс|||п}Эти процедуры~--- всего
  лишь  синтаксический
  сахар, который позволяет нам работать с внутренними процедурами
  объектов, используя обычный синтаксис процедурного вызова. Поразительно,
  что мы так просто можем менять местами роли процедур и данных.
  Например, когда мы пишем {\tt (wire 'get-signal)}, мы
  представляем себе провод {\tt wire} как процедуру, вызываемую с
  сообщением {\tt get-signal} на входе.  С другой стороны, запись
  {\tt (get-signal wire)} поощряет нас думать о {\tt wire}
  как об объекте данных, который поступает на вход процедуре
  {\tt get-signal}.  \index{ru}{синтаксический сахар|процедура vs. данные||||п}
  Истина состоит в том, что в языке, где с
  процедурами можно работать как с объектами, никакого фундаментального
  различия между <<процедурами>> и <<данными>> не существует, и мы имеем
  право выбирать такой синтаксический сахар, который позволит
  программировать в удобном для нас стиле.}:

\begin{Verbatim}[fontsize=\small]
(define (get-signal wire)\index{ru}{get-signal||||pd|}
  (wire 'get-signal))

(define (set-signal! wire new-value)\index{ru}{set-signal!||||pd|}
  ((wire 'set-signal!) new-value))

(define (add-action! wire action-procedure)\index{ru}{add-action!||||pd|}
  ((wire 'add-action!) action-procedure))
\end{Verbatim}

Провода, которые содержат меняющиеся со временем сигналы
и могут подсоединяться к одному объекту за другим, --- типичный
образец изменяющихся объектов.  Мы смоделировали их в виде
процедур с внутренними переменными состояния, которые изменяются
присваиванием.  При создании нового провода создается новый набор
переменных состояния (в выражении {\tt let} внутри
{\tt make-wire}), а также порождается и возвращается новая
процедура {\tt dispatch}, которая захватывает окружение с
новыми переменными состояния.

Провода разделяются между различными устройствами, к ним
подсоединенными.  Таким образом, изменение, произведенное при
взаимодействии с одним устройством, скажется на всех других
устройствах, связанных с этим проводом.  Провод передает изменение
своим соседям, вызывая процедуры-действия, зарегистрированные в нем в
момент установления соединения.

\paragraph{План действий}


\index{ru}{имитация цифровых схем|план действий||||}
Теперь для завершения модели нам остается только написать
{\tt after-delay}.  Здесь идея состоит в том, чтобы
организовать структуру данных под названием
\index{ru}{план действий||agenda|||}\index{en}{agenda||план действий|||}{\em план действий} (agenda), где будет
храниться расписание того, что нам надо сделать.  Для планов действий
определены следующие операции:


\begin{plainlist}
\sloppy
\item {\tt (make-agenda)}\index{ru}{make-agenda||||p|}
возвращает новый пустой план действий.

\item {\tt (empty-agenda? \textit{$\langle$план-действий$\rangle$})}\index{ru}{empty-agenda?||||p|}
истинно, если план пуст.

\item {\tt (first-agenda-item \textit{$\langle$план-действий$\rangle$})}%
\index{ru}{first-agenda-item||||p|}воз\-вра\-ща\-ет первый элемент плана.

\item {\tt (remove-first-agenda-item! \textit{$\langle$план-действий$\rangle$})}
\index{ru}{remove-first-agenda-item!||||p|}%
модифицирует план, уби\-рая из него первый элемент.

\item {\tt (add-to-agenda! \textit{$\langle$время$\rangle$} \textit{$\langle$действие$\rangle$} \textit{$\langle$план-действий$\rangle$})}\index{ru}{add-to-agenda!||||p|}
модифицирует план, добавляя указанную процедуру-действие, которую
нужно запустить в указанное время.

\item {\tt (current-time \textit{$\langle$план-действий$\rangle$})}
\index{ru}{current-time||||p|}возвращает текущее время модели.
\end{plainlist}

Экземпляр плана, которым мы будем пользоваться, будет
обозначаться {\tt the-agenda}.  Процедура
{\tt after-delay} добавляет новый элемент в план
{\tt the-agenda}:

\begin{Verbatim}[fontsize=\small]
(define (after-delay delay action)\index{ru}{after-delay||||pd|}
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
\end{Verbatim}

Имитация управляется процедурой {\tt propagate},
которая работает с {\tt the-agenda}, по очереди выполняя%HERE244
процедуры, содержащиеся в плане.  В общем случае, при работе модели в
план  добавляются новые элементы, а {\tt propagate} продолжает
работу, пока план не становится пустым:

\begin{Verbatim}[fontsize=\small]
(define (propagate) \index{ru}{propagate||||pd|}
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
\end{Verbatim}

\paragraph{Пример работы модели}


\index{ru}{имитация цифровых схем|пример работы модели||||}
Следующая процедура, которая навешивает на провод
<<тестер>>, показывает \index{ru}{полусумматор|имитация||||} имитационную модель в действии.  Тестер говорит
проводу, что, каждый раз, когда сигнал изменяет значение, нужно
напечатать новое значение сигнала, а также текущее время и имя
провода:

\begin{Verbatim}[fontsize=\small]
(define (probe name wire)  \index{ru}{probe|в имитаторе цифровых схем|||pd|}
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
\end{Verbatim}

Сначала мы инициализируем план действий и указываем
задержки для элементарных функциональных элементов:

\begin{Verbatim}[fontsize=\small]
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
\end{Verbatim}
Затем мы создаем четыре провода и к двум из них подсоединяем тестеры:

\begin{Verbatim}[fontsize=\small]
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
\textit{sum 0 New-value = 0}

(probe 'carry carry)
\textit{carry 0 New-value = 0}
\end{Verbatim}
Затем мы связываем провода, образуя схему полусумматора (как на
рис. \ref{P3.25}), устанавливаем сигнал на входе
{\tt input-1} в 1, и запускаем модель:

\begin{Verbatim}[fontsize=\small]
(half-adder input-1 input-2 sum carry)
\textit{ok}

(set-signal! input-1 1)
\textit{done}

(propagate)
\textit{sum 8 New-value = 1}
\textit{done}
\end{Verbatim}
Сигнал {\tt sum} становится 1 в момент времени 8.  Мы находимся
в 8 единицах от начала работы модели.  В этот момент мы можем
установить сигнал на входе {\tt input-2} в 1 и дать изменению
распространиться:

\begin{Verbatim}[fontsize=\small]
(set-signal! input-2 1)
\textit{done}

(propagate)
\textit{carry 11 New-value = 1}
\textit{sum 16 New-value = 0}
\textit{done}
\end{Verbatim}
Сигнал {\tt carry} становится равным 1 в момент 11, а
{\tt sum} становится 0 в момент 16.
\begin{exercise}{3.31}\label{EX3.31}%
Внутренняя процедура
{\tt accept-action-procedure!}, определенная в
{\tt make-wire},
\index{ru}{make-wire||||p|(упр.~3.31)}
требует, чтобы в момент, когда
процедура-действие добавляется к проводу, она немедленно исполнялась.
Объясните, зачем требуется такая инициализация.  В частности,
проследите работу процедуры {\tt half-adder} из этого текста и
скажите, как отличалась бы реакция системы, если бы
{\tt accept-action-procedure!} была определена как

\begin{Verbatim}[fontsize=\small]
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
\end{Verbatim}
\end{exercise}

\paragraph{Реализация плана действий}


\index{ru}{имитация цифровых схем|реализация плана действий||||}
Наконец, мы описываем детали структуры данных плана
действий, которая хранит процедуры, предназначенные для исполнения в
будущем.

План состоит из
\index{ru}{временной отрезок||time segment|||}\index{en}{time segment||временной отрезок|||}{\em временн\'{ы}х отрезков} (time segments). Каждый
временной отрезок является парой, \index{ru}{очередь|в плане действий||||}состоящей из числа (значения
времени) и очереди (см.~упражнение~\ref{EX3.32}), которая
содержит процедуры, предназначенные к исполнению в этот временной
отрезок.

\begin{Verbatim}[fontsize=\small]
(define (make-time-segment time queue)\index{ru}{make-time-segment||||pd|}
  (cons time queue))

(define (segment-time s) (car s))\index{ru}{segment-time||||pd|}

(define (segment-queue s) (cdr s))\index{ru}{segment-queue||||pd|}
\end{Verbatim}
Мы будем работать с очередями временных отрезков при помощи операций,
описанных в разделе~\ref{REPRESENTING-QUEUES}.

Сам по себе план действий является одномерной
\index{ru}{таблица|используемая для моделирования плана действий||||}
таблицей
временных отрезков.  От таблиц, описанных в
разделе~\ref{REPRESENTING-TABLES}, он отличается тем, что сегменты
отсортированы в порядке возрастания времени.  В дополнение к этому мы
храним \index{ru}{текущее время, для имитации плана||current time|||}\index{en}{current time||текущее время, для имитации плана|||}{\em текущее время} (current time) (т.~е. время
последнего исполненного действия) в голове плана.  Свежесозданный план
не содержит временных отрезков, а его текущее время равно 0\footnote{Подобно таблицам из
раздела~\ref{REPRESENTING-TABLES}, план действий~--- это
\index{ru}{список|с заголовком||||п}
список с заголовком, но, поскольку в заголовке хранится время, не нужно
дополнительного заголовка-пустышки (вроде символа
{\tt *table*}, которым мы пользовались в таблицах).
}:

\begin{Verbatim}[fontsize=\small]
(define (make-agenda) (list 0))\index{ru}{make-agenda||||pd|}

(define (current-time agenda) (car agenda))\index{ru}{current-time||||pd|}

(define (set-current-time! agenda time)\index{ru}{set-current-time!||||pd|}
  (set-car! agenda time))

(define (segments agenda) (cdr agenda))\index{ru}{segments||||pd|}

(define (set-segments! agenda segments)\index{ru}{set-segments!||||pd|}
  (set-cdr! agenda segments))

(define (first-segment agenda) (car (segments agenda)))\index{ru}{first-segment||||pd|}

(define (rest-segments agenda) (cdr (segments agenda)))\index{ru}{rest-segments||||pd|}
\end{Verbatim}
План пуст, если в нем нет ни одного временного отрезка:

\begin{Verbatim}[fontsize=\small]
(define (empty-agenda? agenda)\index{ru}{empty-agenda?||||pd|}
  (null? (segments agenda)))
\end{Verbatim}

Для того, чтобы добавить в план новое действие, прежде
всего мы проверяем, не пуст ли он.  Если пуст, мы создаем для действия
новый отрезок и вставляем его в план.  Иначе мы просматриваем
план, глядя на времена отрезков.  Если мы находим отрезок с
назначенным временем, мы добавляем действие к соответствующей
очереди.  Если же мы обнаруживаем время, большее, чем назначенное, мы
вставляем новый отрезок перед текущим. Если мы доходим до конца плана,
мы вставляем новый отрезок в конец.

\begin{Verbatim}[fontsize=\small]
(define (add-to-agenda! time action agenda)\index{ru}{add-to-agenda!||||pd|}
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
\end{Verbatim}

Процедура, которая убирает из плана первый элемент,
уничтожает элемент в начале очереди первого отрезка времени.  Если в
результате отрезок становится пустым, мы изымаем его из списка
отрезков\footnote{Обратите внимание, что в этой процедуре выражение
{\tt if} не имеет \textit{$\langle$альтернативы$\rangle$}.  Такие
<<односторонние предложения {\tt if}>>
\index{ru}{if (особая форма)|одностороннее предложение (без альтернативы)|||p|п}
\index{ru}{неопределенные значения|\texttt{if} без альтернативы||||п}
используются, когда
требуется решить, нужно ли какое-то действие, а не выбрать одно из
двух выражений. Если предикат ложен, а \textit{$\langle$альтернатива$\rangle$}
отсутствует, значение предложения {\tt if} не определено.
}:

\begin{Verbatim}[fontsize=\small]
(define (remove-first-agenda-item! agenda)\index{ru}{first-agenda-item||||pd|}
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
\end{Verbatim}

Первый элемент плана находится в начале очереди в первом
временном отрезке. Каждый раз, когда мы обращаемся к такому элементу,
мы обновляем текущее время\footnote{Таким образом, текущее время всегда будет совпадать с
временем последнего обработанного действия.  Благодаря тому, что это
время хранится в голове плана, оно всегда доступно, даже если
соответствующий отрезок времени был уничтожен.
}.

\begin{Verbatim}[fontsize=\small]
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "План пуст -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
\end{Verbatim}
\begin{exercise}{3.32}\label{EX3.32}%
Процедуры, предназначенные к выполнению в каждом
временном отрезке, хранятся в виде очереди.  Таким образом, процедуры
для каждого отрезка вызываются в том же порядке, в котором они были
добавлены к плану (первый пришел, первый ушел).  Объясните, почему
требуется использовать именно такой порядок.  В частности, проследите
поведение И-элемента, входы которого меняются с 0 на 1 и с 1 на 0
одновременно и скажите, как отличалось бы поведение, если бы мы
хранили процедуры отрезка в обыкновенном списке, добавляя и убирая их
только с головы (последний пришел, первый ушел).
\end{exercise}

\subsection{Распространение ограничений}
\label{PROPAGATION-OF-CONSTRAINTS}


\index{ru}{ограничения|распространение|constraints|||}%
\index{en}{constraints||ограничения|распространение||}%
\index{ru}{распространение ограничений||propagation     of constraints|||}%
\index{en}{propagation     of constraints||распространение ограничений|||}%
Традиционно компьютерные программы организованы как
однонаправленные вычисления, выполняющие вычисления над указанными
аргументами и получающие указанные значения.  С другой стороны, часто
системы приходится моделировать в виде отношений между величинами.
Например, математическая модель механической структуры может включать
информацию, что деформация $d$ металлического стержня
связана уравнением
$dAE = FL$ с приложенной к нему силой $F$, его длиной
$L$, поперечным сечением $A$ и модулем упругости
$E$.
Такое уравнение не является однонаправленным.  Имея любые четыре
величины, мы можем вычислить пятую.  Однако при переводе уравнения на
традиционный компьютерный язык нам придется выбрать величину,
которая вычисляется на основе остальных четырех, так что процедура
для вычисления площади $A$ не может быть использована для
вычисления деформации $d$, хотя вычисление $A$ и
$d$ основаны на одном и том же уравнении\footnote{Распространение ограничений появилось в системе
\index{ru}{SKETCHPAD|||||п}SKETCHPAD Айвена Сазерленда (Sutherland 1963),
\index{ru}{Сазерленд, Айвен||Ivan Sutherland||n|п}\index{en}{Ivan Sutherland||Сазерленд, Айвен||n|п}
невероятно опередившей свое время.  Изящная система распространения
ограничений, основанная на языке \index{ru}{Smalltalk|||||п}Smalltalk, была разработана Аланом
Борнингом (Borning 1977)\index{ru}{Борнинг, Алан||Alan Borning||n|п}\index{en}{Alan Borning||Борнинг, Алан||n|п}
в исследовательском центре
компании Xerox в Пало Альто.  Сассман, Столлман и Стил применили
распространение ограничений к анализу электрических цепей
(Sussman and Stallman 1975;
\index{ru}{Столлман,
  Ричард~М.||Richard~M. Stallman||n|п}\index{en}{Richard~M. Stallman||Столлман, Ричард~М.||n|п}\index{ru}{Сассман, Джеральд Джей||Gerald Jay Sussman||n|п}\index{en}{Gerald Jay Sussman||Сассман, Джеральд Джей||n|п}Sussman and Steele 1980).\index{ru}{Стил, Гай Льюис мл.||Guy Lewis Steele Jr.||n|п}\index{en}{Guy Lewis Steele Jr.||Стил, Гай Льюис мл.||n|п}
\index{ru}{TK!Solver|||||п}TK!Solver (Konopasek and Jayaraman 1984)
представляет собой богатую\index{ru}{Джаяраман, Сундаресан||Sundaresan
  Jayaraman||n|п}\index{en}{Sundaresan Jayaraman||Джаяраман,
  Сундаресан||n|п}\index{ru}{Конопасек, Милош||Milos
  Konopasek||n|п}\index{en}{Milos Konopasek||Конопасек, Милош||n|п}
среду моделирования, основанную на ограничениях.}.

\index{ru}{отношения, вычисления в терминах отношений|||||}В этом
разделе мы набросаем эскиз языка, который позволит
нам работать в терминах самих отношений.  Минимальными составляющими
этого языка будут служить \index{ru}{ограничения|элементарные||||}
\index{ru}{элементарное ограничение||primitive constraint|||}\index{en}{primitive constraint||элементарное ограничение|||}{\em элементарные
ограничения} (primitive constraints), которые говорят, что между величинами существуют
определенные связи.  Например, {\tt (adder a b c)} означает,
что величины $a$, $b$ и $c$ должны
быть связаны уравнением $a + b = c$,
{\tt (multiplier x y z)} выражает ограничение $xy =
z$, а {\tt (constant 3.14 x)} говорит, что значение
$x$ обязано равняться 3.14.

Наш язык предоставляет средства комбинирования элементарных
ограничений, чтобы с их помощью выражать более сложные
отношения.  Сочетания образуют
\index{ru}{сеть ограничений||constraint network|||}\index{en}{constraint network||сеть ограничений|||}{\em сети ограничений} (constraint networks), в которых
ограничения связаны \index{ru}{соединитель (соединители) в системе ограничений||connector(s), in constraint system|||}\index{en}{connector(s), in constraint system||соединитель (соединители) в системе ограничений|||}{\em соединителями} (connectors).
Соединитель --- это объект, который <<содержит>> значение, способное
участвовать в одном или нескольких ограничениях.  К примеру, мы знаем, что
связь между температурами по Цельсию и по Фаренгейту выглядит как
$9 C = 5 (F - 32)$
Такое ограничение можно изобразить в виде сети, состоящей из
элементарных ограничений --- сумматора, умножителей и констант
(рисунок~\ref{P3.28}).  На этом рисунке слева мы видим
блок умножителя с тремя выводами, обозначенными $m1$,
$m2$ и $p$.  Вывод $m1$ присоединен
к соединителю $C$, который будет хранить температуру по
Цельсию. Вывод $m2$ присоединен к соединителю
$w$, который, кроме того, связан с блоком-константой,
содержащим 9.  Вывод $p$, про который блок-умножитель
говорит, что он должен быть произведением $m1$ и
$m2$, связан с выводом $p$ другого
блока-умножителя, чей вывод $m2$ связан с константой 5, а
$m1$ присоединен к одному из слагаемых суммы.


\begin{cntrfig}
\input{xfig-mod/3-28.eepic}
\caption{Уравнение $9C = 5(F - 32)$,
выраженное в виде сети ограничений.}
\label{P3.28}

\end{cntrfig}

Вычисления в такой сети происходят следующим образом: когда соединителю
дается значение (пользователем либо блоком-ограничением, с которым он
связан), соединитель пробуждает все связанные с ним ограничения (кроме
того, которое само его пробудило), и сообщает им, что у него появилось
значение.  Каждый пробужденный блок-ограничение опрашивает свои
выводы, чтобы определить, достаточно ли у него информации, чтобы найти
значение для какого-нибудь еще соединителя. Если да, блок присваивает соединителю
значение, и тогда уже он пробуждает связанные с ним ограничения, и так
далее. Например, при преобразовании между градусами Цельсия и
Фаренгейта, значения $w$, $x$ и $y$
сразу устанавливаются блоками-константами соответственно в 9, 5 и 32.
Соединители пробуждают умножители и сумматор, которые убеждаются, что
у них не хватает информации, чтобы продолжить.  Если пользователь (или
какая-то другая часть сети) установит значение $C$ в 25,
пробудится левый умножитель, и сделает $u$ равным
$25 \cdot 9 = 225$. Затем $u$ разбудит второй
умножитель, который присвоит $v$ значение 45, а
$v$ разбудит сумматор, и тот сделает значение
$F$ равным 77.

\paragraph{Использование системы ограничений}


Чтобы при помощи системы ограничений провести
вышеописанное вычисление, сначала мы порождаем два соединителя,
{\tt C} и {\tt F}, вызовами конструктора
{\tt make-connector}, и связываем {\tt C} и
{\tt F} в требуемую нам сеть:

\begin{Verbatim}[fontsize=\small]
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
\textit{ok}
\end{Verbatim}
Процедура, создающая сеть, определяется так:

\begin{Verbatim}[fontsize=\small]
(define (celsius-fahrenheit-converter c f)\index{ru}{celsius-fahrenheit-converter||||pd|}
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
\end{Verbatim}
Эта процедура порождает внутренние соединители {\tt u},
{\tt v}, {\tt w}, {\tt x} и {\tt y}, а
затем связывает их, как показано на рис.~\ref{P3.28}, при
помощи элементарных ограничений {\tt adder},
{\tt multiplier} и {\tt constant}.  Как и
при моделировании цифровых схем в
разделе~\ref{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}, способность
выражать комбинации базовых элементов в виде процедур автоматически
сообщает нашему языку средство абстракции для составных объектов.

Чтобы наблюдать сеть в действии, мы подсоединим тестеры к
соединителям {\tt C} и {\tt F} при помощи процедуры
{\tt probe}, подобной той, которая следила за сигналами в
проводах в разделе~\ref{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}.
Установка тестера на соединителе ведет к тому, что каждый раз, когда
он получает значение, печатается сообщение:

\begin{Verbatim}[fontsize=\small]
(probe "по Цельсию" C)
(probe "по Фаренгейту" F)
\end{Verbatim}
Затем мы присваиваем значение 25 соединителю
{\tt C}. (Третий аргумент процедуры {\tt set-value!}
сообщает {\tt C}, что директива исходит от пользователя.)

\begin{Verbatim}[fontsize=\small]
(set-value! C 25 'user)
\textit{Тестер: по Цельсию = 25}
\textit{Тестер: по Фаренгейту = 77}
\textit{done}
\end{Verbatim}
Тестер на {\tt C} просыпается и печатает значение.  Кроме того,
{\tt C} распространяет значение по сети, как описано выше.  В
результате {\tt F} становится равным 77, и тестер на
{\tt F} об этом сообщает.

Теперь можно попробовать присвоить {\tt F} новое
значение, скажем, 212:

\begin{Verbatim}[fontsize=\small]
(set-value! F 212 'user)
\textit{Ошибка! Противоречие (77 212)}
\end{Verbatim}
Соединитель жалуется, что обнаружил противоречие: его значение равно
77, а при этом кто-то пытается установить его в 212.  Если мы и
вправду хотим снова воспользоваться сетью с новыми значениями, можно попросить
{\tt C} забыть свое старое значение:

\begin{Verbatim}[fontsize=\small]
(forget-value! C 'user)
\textit{Тестер: по Цельсию = ?}
\textit{Тестер: по Фаренгейту = ?}
\textit{done}
\end{Verbatim}
{\tt С} видит, что {\tt user}, который изначально
присвоил ему значение, отменяет его, так что {\tt C}
соглашается потерять значение, как показывает тестер, и информирует об
этом остальную сеть.  Эта информация в конце концов добирается до
{\tt F}, и у {\tt F} уже не остается причин считать, что
его значение равно 77.  Так что {\tt F} тоже теряет значение, и
тестер это отображает.

Теперь, когда у {\tt F} больше нет значения, мы
можем установить его в 212:

\begin{Verbatim}[fontsize=\small]
(set-value! F 212 'user)
\textit{Тестер: по Фаренгейту = 212}
\textit{Тестер: по Цельсию = 100}
\textit{done}
\end{Verbatim}
Это новое значение, распространяясь по сети, заставляет {\tt C}
получить значение 100, и тестер на {\tt C} это регистрирует.
Заметим, что одна и та же сеть используется и для того, чтобы на основе
{\tt F} получить {\tt C} и для того, чтобы на основе
{\tt C} получить {\tt F}.  Эта ненаправленность
вычислений является отличительной чертой систем, основанных на
ограничениях.

\paragraph{Реализация системы ограничений}


Система ограничений реализована на основе процедурных
объектов с внутренним состоянием, очень похоже на модель цифровых схем
из раздела~\ref{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}.  Хотя
базовые объекты системы с ограничениями несколько более сложны, система в
целом проще за счет того, что незачем заботиться о планах действий и логических
задержках.

Базовые операции над соединителями таковы:\index{ru}{соединитель (соединители) в системе ограничений|операции||||}

\begin{plainlist}
\sloppy

\item

{\tt(has-value?} \textit{$\langle$соединитель$\rangle$})%
\index{ru}{has-value?||||p|}сообщает, есть ли у соединителя значение.

\item
{\tt (get-value} \textit{$\langle$соединитель$\rangle$})%
\index{ru}{get-value||||p|}возвращает текущее значение соединителя.

\item
{\tt(set-value!} \textit{$\langle$соединитель$\rangle$} \textit{$\langle$новое-знач$\rangle$} \textit{$\langle$информант$\rangle$})%
\index{ru}{set-value!||||p|} сообщает соединителю, что
информант требует установить в нем новое значение.

\item
{\tt (forget-value!} \textit{$\langle$соединитель$\rangle$} \textit{$\langle$отказник$\rangle$})%
\index{ru}{forget-value!||||p|} сообщает соединителю, что отказник просит его забыть значение.

\item
{\tt (connect} \textit{$\langle$соединитель$\rangle$} \textit{$\langle$новое-огр$\rangle$})%
\index{ru}{connect||||p|} говорит соединителю, что он участвует в новом ограничении.

\sloppy
\end{plainlist}
Соединители общаются с ограничениями при помощи процедур
{\tt inform-about-value}, которая говорит ограничению, что у
соединителя есть значение, и {\tt inform-about-no-value},
которая сообщает ограничению, что соединитель утратил значение.
{\sloppy

}
{\tt Adder} порождает ограничение-сумматор между
соединителями-сла\-га\-е\-мы\-ми {\tt a1} и {\tt a2} и%HERE252
соединителем-суммой {\tt sum}. Сумматор реализован в виде
процедуры с внутренним состоянием (процедура {\tt me}):

\begin{Verbatim}[fontsize=\small]
(define (adder a1 a2 sum)\index{ru}{adder (элементарное ограничение)||||pd|}
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Неизвестный запрос -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
\end{Verbatim}
{\tt Adder} связывает новый сумматор с указанными соединителями
и возвращает его в качестве значения.  Процедура {\tt me},
которая представляет сумматор, работает как диспетчер для внутренних
процедур.  Для доступа к диспетчеру используются следующие
<<синтаксические интерфейсы>> (см.~примечание~\ref{FOOT3.27} в
разделе~\ref{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}):

\begin{Verbatim}[fontsize=\small]
(define (inform-about-value constraint)\index{ru}{inform-about-value||||pd|}
  (constraint 'I-have-a-value))

(define (inform-about-no-value constraint)\index{ru}{inform-about-no-value||||pd|}
  (constraint 'I-lost-my-value))
\end{Verbatim}
Внутренняя процедура сумматора {\tt process-new-value}
вызывается, когда сумматору сообщают, что один из его соединителей
получил значение. Сумматор проверяет, имеют ли значения одновременно
{\tt a1} и {\tt a2}. Если да, то он говорит
{\tt sum}, чтобы тот установил значение в сумму двух
слагаемых.  Аргумент {\tt informant} процедуры
{\tt set-value!} равен {\tt me}, то есть самому
объекту-сумматору.  Если неверно, что и {\tt a1} и
{\tt a2} имеют
значения, то сумматор проверяет, имеют ли одновременно
значения {\tt a1} и {\tt sum}. Если да, то он
устанавливает {\tt a2} в их разность.  Наконец, если значения
есть у {\tt a2} и {\tt sum}, это дает сумматору
достаточно информации, чтобы установить {\tt a1}.  Если
сумматору сообщают, что один из соединителей потерял значение, то он
просит все свои соединители избавиться от значений.  (На самом деле
будут отброшены только значения, установленные самим сумматором.)  Затем
он зовет {\tt process-new-value}. Смысл этого последнего шага
в том, что один или более соединителей по-прежнему могут обладать
значением (то есть, у соединителя могло быть значение, не установленное
сумматором), и эти значения может быть необходимо распространить через
сумматор.

Умножитель очень похож на сумматор.  Он устанавливает свой
вывод {\tt product} в 0, если хотя бы один множитель равен 0,
даже в том случае, когда второй множитель неизвестен.
{\sloppy

}

\begin{Verbatim}[fontsize=\small]
(define (multiplier m1 m2 product)\index{ru}{multiplier|элементарное ограничение|||pd|}
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Неизвестный запрос -- MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
\end{Verbatim}
Конструктор {\tt constant} просто устанавливает значение
указанного соединителя. Сообщение {\tt I-have-a-value} либо
{\tt I-lost-my-value}, посланные блоку-константе, приводят к
ошибке.

\begin{Verbatim}[fontsize=\small]
(define (constant value connector)\index{ru}{constant (элементарное ограничение)||||pd|}
  (define (me request)
    (error "Неизвестный запрос -- CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
\end{Verbatim}
Наконец, тестер печатает сообщение о присваивании или потере значения
в указанном соединителе:

\begin{Verbatim}[fontsize=\small]
(define (probe name connector)  \index{ru}{probe|в системе ограничений|||pd|}
  (define (print-probe value)
    (newline)
    (display "Тестер: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Неизвестный запрос -- PROBE" request))))
  (connect connector me)
  me)
\end{Verbatim}

\paragraph{Представление соединителей}


\index{ru}{соединитель (соединители) в системе ограничений|представление||||}
Соединитель представляется в виде процедурного объекта с
внутренними  переменными  состояния: {\tt value}, значение
соединителя; {\tt informant}, объект, который установил
значение соединителя; и {\tt constraints}, множество
ограничений, в которых участвует соединитель.

\begin{Verbatim}[fontsize=\small]
(define (make-connector)\index{ru}{make-connector||||pd|}
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Противоречие" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Неизвестная операция -- CONNECTOR"
                         request))))
    me))
\end{Verbatim}
Внутренняя процедура соединителя {\tt set-my-value} зовется,
когда поступает требование установить значение соединителя.  Если у
соединителя нет текущего значения, он его устанавливает и
запоминает ограничение, которое потребовало установки значения, в
переменной {\tt informant}\footnote{{\tt Setter} может и не быть
ограничением.  В примере с температурой мы использовали символ
{\tt user} в качестве значения {\tt setter}.
}.
Затем соединитель оповещает все связанные с ним ограничения, кроме
того, которое потребовало установить значение.  Это проделывается с
помощью следующего итератора, который применяет указанную процедуру ко
всем элементам списка, кроме одного.

\begin{Verbatim}[fontsize=\small]
(define (for-each-except exception procedure list)\index{ru}{for-each-except||||pd|}
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
\end{Verbatim}

Если от соединителя требуют забыть значение, он запускает
внутреннюю процедуру {\tt forget-my-value}, которая первым
делом убеждается, что запрос исходит от того же самого объекта,
который значение установил.  Если это так, соединитель оповещает
связанные с ним ограничения о потере значения.

Внутренняя процедура  {\tt connect} добавляет
указанное ограничение к списку ограничений, если его там еще нет.
Затем, если у соединителя есть значение, он сообщает об этом
ограничению.

Процедура соединителя {\tt me} служит диспетчером
для остальных внутренних процедур, а кроме того, представляет
соединитель как объект.  Следующие процедуры предоставляют синтаксический
интерфейс к диспетчеру:

\begin{Verbatim}[fontsize=\small]
(define (has-value? connector)\index{ru}{has-value?||||pd|}
  (connector 'has-value?))

(define (get-value connector)\index{ru}{get-value||||pd|}
  (connector 'value))

(define (set-value! connector new-value informant)\index{ru}{set-value!||||pd|}
  ((connector 'set-value!) new-value informant))

(define (forget-value! connector retractor)\index{ru}{forget-value!||||pd|}
  ((connector 'forget) retractor))

(define (connect connector new-constraint)\index{ru}{connect||||pd|}
  ((connector 'connect) new-constraint))
\end{Verbatim}
\begin{exercise}{3.33}\label{EX3.33}%
С помощью элементарных ограничений сумматор, умножитель
и константа, определите процедуру {\tt averager} (усреднитель),
\index{ru}{averager (ограничение)||||p|(упр.~3.33)}
которая принимает три соединителя {\tt a}, {\tt b} и
{\tt c}, и обеспечивает условие, что значение
{\tt c} равно среднему арифметическому значений {\tt a}
и {\tt b}.
\end{exercise}
\begin{exercise}{3.34}\label{EX3.34}%
Хьюго Дум хочет построить квадратор,
блок-ограничение с двумя выводами, такое, что значение соединителя
{\tt b} на втором выводе всегда будет равно квадрату значения
соединителя {\tt a} на первом выводе. Он предлагает следующее
простое устройство на основе умножителя:

\begin{Verbatim}[fontsize=\small]
(define (squarer a b) \index{ru}{squarer (ограничение)||||pd|(упр.~3.34)}
  (multiplier a a b))
\end{Verbatim}
В такой идее есть существенная ошибка.  Объясните ее.
\end{exercise}
\begin{exercise}{3.35}\label{EX3.35}%
Бен Битобор объясняет Хьюго, что один из способов
избежать неприятностей в упражнении~\ref{EX3.34} ---
определить квадратор как новое элементарное ограничение.  Заполните
недостающие части в Беновой схеме процедуры, реализующей такое
ограничение:

\begin{Verbatim}[fontsize=\small]
(define (squarer a b) \index{ru}{squarer (ограничение)||||pd|(упр.~3.35)}
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "квадрат меньше 0 -- SQUARER" (get-value b))
            \textit{$\langle$альтернатива1$\rangle$})
        \textit{$\langle$альтернатива2$\rangle$}))
  (define (process-forget-value) \textit{$\langle$тело1$\rangle$})
  (define (me request) \textit{$\langle$тело2$\rangle$})
  \textit{$\langle$остаток определения$\rangle$}
  me)
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.36}\label{EX3.36}%
Допустим, что мы выполняем следующую последовательность
действий в глобальном окружении:

\begin{Verbatim}[fontsize=\small]
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
\end{Verbatim}
В какой-то момент при вычислении {\tt set-value!} будет
выполнено следующее выражение из внутренней процедуры соединителя:

\begin{Verbatim}[fontsize=\small]
(for-each-except setter inform-about-value constraints)
\end{Verbatim}
Нарисуйте диаграмму, изображающую окружение, в котором выполняется
указанное выражение.
\end{exercise}
\begin{exercise}{3.37}\label{EX3.37}%
Процедура {\tt celsius-fahrenheit-converter}
выглядит громоздко по сравнению со стилем определения в формате выражения:

\begin{Verbatim}[fontsize=\small]
(define (celsius-fahrenheit-converter x)\index{ru}{celsius-fahrenheit-converter|в формате выражения|||pd|(упр.~3.37)}
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))

(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
\end{Verbatim}
Здесь {\tt c+}, {\tt c*} и~т.~п. --- <<ограничительные>>
версии арифметических операций.  Например, {\tt c+} берет в
виде аргументов два соединителя, и возвращает соединитель, который
связан с ними ограничением-сумматором:

\begin{Verbatim}[fontsize=\small]
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
\end{Verbatim}
Определите аналогичные процедуры для {\tt c-}, {\tt c*},
{\tt c/} и {\tt cv} (константа), так, чтобы можно было
определять составные ограничения, как в вышеприведенном
примере\footnote{Представление в виде выражений удобно, потому что
при этом отпадает необходимость давать имена промежуточным выражениям в вычислении.
\index{ru}{стиль, ориентированный на выражения, vs. императивный стиль||expression-oriented style     vs. imperative style|||п}%
\index{en}{expression-oriented style     vs. imperative style||стиль, ориентированный на выражения, vs. императивный стиль|||п}%
\index{ru}{императивный стиль vs. стиль,      ориентированный на выражения||imperative     vs. expression-oriented programming style|||п}%
\index{en}{imperative     vs. expression-oriented programming style||императивный стиль vs. стиль,      ориентированный на выражения|||п}%
Наша
исходная формулировка языка ограничений громоздка по той же причине,
по которой многие языки оказываются громоздкими при работе с составными
данными.  Например, если нам нужно вычислить произведение $(a+b)
\cdot (c+d)$, где переменные представляют вектора, мы можем
работать в <<императивном>> стиле, с процедурами, которые присваивают
значения указанным векторным аргументам, но сами не возвращают вектора
как значения:

\begin{Verbatim}[fontsize=\footnotesize]
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
\end{Verbatim}
С другой стороны, мы можем работать с выражениями, используя процедуры,
которые возвращают вектора как значения, и таким образом избежать
прямого упоминания {\tt temp1} и {\tt temp2}:

\begin{Verbatim}[fontsize=\footnotesize]
(define answer (v-prod (v-sum a b) (v-sum c d)))
\end{Verbatim}
Поскольку Лисп позволяет возвращать составные объекты как результаты
процедур, мы можем преобразовать свой императивный язык ограничений в
язык на основе выражений, как показано в этом упражнении.  В
языках, где средства работы с составными объектами бедны, как в
\index{ru}{Algol (Алгол)|бедность средств       работы с составными объектами||||п}Алголе,
\index{ru}{Basic (Бейсик)|бедность средств       работы с составными объектами||||п} Бейсике и
\index{ru}{Pascal (Паскаль)|бедность средств       работы с составными объектами||||п}
Паскале
(если явно не использовать паскалевские
переменные-указатели), обычно при решении таких задач программист
ограничен императивным стилем.  Поскольку формат выражений
предпочтителен, можно спросить, есть ли причина строить систему
императивно, как мы поступили в этом разделе.  Одна из причин состоит в
том, что язык ограничений, не ориентированный на выражения, дает нам
возможность работать не только с объектами-соединителями,
но и с объектами-ограничениями (например, значением,
порождаемым процедурой {\tt adder}). Это будет полезно,
если мы захотим расширить систему новыми операциями, которые
работают с ограничениями напрямую, а  не только косвенным образом через
операции над соединителями.  Хотя реализовать работу с выражениями на
основе императивной реализации просто, сделать обратное значительно
труднее.
}.
\end{exercise}

\section{Параллелизм: время имеет значение}
\label{CONCURRENCY-TIME-IS-OF-THE-ESSENCE}


 \index{ru}{параллелизм|||||}
Мы убедились в мощности вычислительных объектов с внутренним
состоянием в качестве инструмента моделирования. Однако, как было
сказано в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}, за эту мощность
приходится платить потерей референциальной прозрачности, которая ведет
в дебри вопросов об идентичности и изменении, и необходимостью замены
подстановочной модели вычислений на более сложную модель с
окружениями.

Главная проблема, стоящая за сложностями состояния,
идентичности и изменения, состоит в том, что, введя присваивание, мы
вынуждены внести в свои вычислительные модели понятие \index{ru}{время|и присваивание||||}
\index{ru}{время||time|||}\index{en}{time||время|||}{\em времени} (time).  До того, как появилось
присваивание, наши программы от времени не зависели --- в том смысле, что
всякое выражение, обладающее значением, всегда имело одно и то же
значение. Вспомним, однако, пример со снятием денег со счета и
просмотром получившегося баланса из начала
раздела~\ref{LOCAL-STATE-VARIABLES}:

\begin{Verbatim}[fontsize=\small]
(withdraw 25)
\textit{75}

(withdraw 25)
\textit{50}
\end{Verbatim}
Здесь последовательное вычисление одного и того же выражения приводит
к различным результатам.  Такое поведение возникает из-за того, что
выполнение предложений присваивания (в данном случае присваивания
переменной {\tt balance}) отмечает
\index{ru}{момент времени||moment in time|||}\index{en}{moment in time||момент времени|||}{\em моменты времени} (moments in time), когда значения
меняются.  Результат вычисления выражения зависит не только от самого
выражения, но и от того, происходит ли вычисление до
или после таких моментов.  Построение моделей в терминах
вычислительных объектов с внутренним состоянием заставляет нас
рассматривать время как существенное для программирования понятие.

Можно пойти еще дальше в структурировании наших
вычислительных объектов, чтобы точнее отразить наше восприятие
физического мира.  Объекты мира изменяются не последовательно один за
другим.  Мы воспринимаем их как действующие
\index{ru}{параллелизм||concurrency|||}\index{en}{concurrency||параллелизм|||}{\em параллельно} (concurrently) --- все вместе.  Так что
зачастую бывает естественно моделировать системы как сообщества вычислительных
процессов, работающих параллельно.  Точно так же, как можно сделать
программы модульными, организуя их в виде объектов с раздельным
внутренним состоянием, часто имеет смысл разделять вычислительные
модели на части, вычисляющиеся раздельно и одновременно.  Даже если
на самом деле предполагается выполнять программы на последовательном
компьютере, практика написания программ так, как будто вычисление
будет параллельным, заставляет программиста избегать несущественных
временн\'{ы}х ограничений, и таким образом повышает модульность
программ.

Параллельное вычисление не только делает программы модульнее,
оно к тому же может дать выигрыш в скорости перед
последовательным.  Последовательные компьютеры выполняют только одну
операцию за раз, так что время, необходимое для решения задачи,
пропорционально общему количеству выполняемых операций\footnote{На самом деле большинство процессоров выполняют несколько
операций за раз, используя стратегию, называемую
\index{ru}{конвейеризация||pipelining|||п}\index{en}{pipelining||конвейеризация|||п}{\em конвейеризация} (pipelining).  Хотя этот метод
значительно повышает степень использования аппаратных ресурсов, он
используется только для ускорения выполнения последовательного потока
вычислений, сохраняя поведение последовательной программы.
}.
Однако если возможно разбить задачу на части, которые относительно
независимы друг от друга и должны общаться между собой редко, может
оказаться возможным раздать эти куски отдельным вычисляющим
процессорам и получить выигрыш, пропорциональный числу имеющихся
процессоров.

К несчастью, проблемы, связанные с присваиванием, становятся
только тяжелее в присутствии параллелизма.  Связано ли это с тем, что
параллельно работает мир, или компьютер, но явление одновременных
вычислений привносит дополнительную сложность в наше понимание
времени.

\subsection{Природа времени в параллельных системах}
\label{THE-NATURE-OF-TIME-IN-CONCURRENT-SYSTEMS}

\begin{cntrfig}
\input{xfig-mod/3-29.eepic}
%{\small   Петр -- Банк -- Павел
%  Считать balance: \$100     --    Считать balance: \$100
%  новое значение: 100-10=90
%                                   новое значение: 100-25=75
%  установить balance в \$90
%                                   установить balance в \$75
%время}
\caption{Временная диаграмма, показывающая, как
чередование действий при двух операциях со счетом может привести
к неправильному балансу. \index{ru}{временн\'{а}я диаграмма||timing diargam|||}\index{en}{timing diargam||временн\'{а}я диаграмма|||}}
\label{P3.29}

\end{cntrfig}


\index{ru}{время|в параллельных системах||||}
На первый взгляд,  время --- вещь простая.
Это порядок, накладываемый на события\footnote{Граффити на одной стене в Кембридже:  \index{ru}{время|предназначение||||п}<<Время --- это
устройство для того, чтобы случалось не все сразу>>.
}.
Для всяких двух событий $A$ и $B$, либо
$A$ случается раньше $B$, либо $A$ и
$B$ происходят одновременно, либо $A$ случается
позже $B$.  Например, возвращаясь к примеру с банковским
счетом, пусть Петр берет с общего счета 10 долларов, а Павел 25, притом, что
сначала на счету 100 долларов.  На счету останется 65 долларов. В
зависимости от порядка двух событий, последовательность балансов на
счету будет либо $\$100 \to \$90 \to \$65$, либо
$\$100 \to \$75 \to \$65$.  В компьютерной реализации
банковской системы эта изменяющаяся последовательность балансов может
моделироваться через последовательные присваивания переменной
{\tt balance}.

Однако в некоторых ситуациях такой взгляд может вести к
проблемам.  Допустим, что Петр и Павел, и еще другие люди помимо них,
имеют доступ к  \index{ru}{банковский счет|совместный||||}
совместному банковскому счету через сеть банкоматов,
разбросанных по всему миру.  Последовательность значений баланса
будет критическим образом зависеть от точной хронологии доступа и деталей
коммуникации между машинами.

\index{ru}{порядок событий|неопределенность          в параллельных системах|order of events|||}%
\index{en}{order of events||порядок событий|неопределенность          в параллельных системах||}%
Неопределенность порядка событий может приводить к
серьезным проблемам в проектировании компьютерных систем.  Например,
предположим, что действия Петра и Павла реализованы как два отдельных
процесса с общей переменной {\tt ba\-lance}, и что каждый процесс
определяется процедурой из
раздела~\ref{LOCAL-STATE-VARIABLES}:




\begin{Verbatim}[fontsize=\small]
(define (withdraw amount) \index{ru}{withdraw|сложности в параллельных системах|||pd|}
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Недостаточно денег на счете"))
\end{Verbatim}
Если два процесса работают одновременно, то Петр может проверить
баланс и попытаться снять разрешенную сумму.  Однако за промежуток
времени между моментами, когда Петр проверяет баланс, и когда он
завершает снятие денег, Павел может снять какую-то сумму и сделать
результат Петровой проверки несостоятельным.

И это еще не самое худшее.  Рассмотрим выражение
\begin{Verbatim}
(set! balance (- balance amount))
\end{Verbatim}
которое выполняется во время каждого снятия денег.  Выполнение
происходит в три шага: (1) считывание значения переменной
{\tt balance}; (2) вычисление нового значения баланса; (3)
присвоение переменной {\tt balance} этого нового значения.  Если
процессы Петра и Павла выполняют это предложение параллельно, то в двух
процессах снятия денег порядок чтения переменной {\tt balance} и
присваивания могут чередоваться.

Временн\'{а}я диаграмма на рисунке~\ref{P3.29}
показывает порядок событий, при котором {\tt balance} сначала
равен 100.  Петр берет 10, Павел  25, и однако в итоге
{\tt ba\-lance} оказывается равен 75.  Как показано на диаграмме,
причина аномалии состоит в том, что у Павла присваивание переменной
значения 75 основано на предположении, что значение
{\tt balance}, которое надо уменьшить, равно 100.  Однако это
предположение стало неверным, когда Петр сделал {\tt balance}
равным 90.  Для банковской системы это катастрофическая ошибка,
так как не сохраняется общее количество денег в системе.  До
транзакций общая сумма была 100 долларов.  После же у Петра оказывается 10
долларов, у Павла 25, и у банка~75\footnote{Еще худшая ошибка могла бы случиться, если бы две операции
{\tt set!} попытались одновременно изменить баланс. В
результате содержимое памяти могло бы стать случайной комбинацией
данных, записанных двумя процессами.  В большинство компьютеров встроена
блокировка элементарных операций записи в память, которая
предохраняет от такого одновременного доступа.  Однако даже такой,
казалось бы, простой метод защиты придает дополнительную сложность проектированию
многопроцессорных компьютеров, где требуются сложные протоколы
\index{ru}{согласованность кэша||cache coherence|||п}\index{en}{cache coherence||согласованность кэша|||п}{\em согласованности кэша} (cache coherence), чтобы у разных процессоров были
непротиворечивые точки зрения на содержимое памяти, при том,
что данные могут дублироваться (<<кэшироваться>>) в разных процессорах,
чтобы увеличить скорость доступа к памяти.
}.

\index{ru}{разделяемое состояние||shared state|||}\index{en}{shared state||разделяемое состояние|||}%
\index{ru}{состояние|разделяемое||||}%
Общее явление, иллюстрируемое здесь, состоит в том, что
различные процессы могут разделять одну и ту же переменную состояния.
Сложность возникает оттого, что с этой переменной  в одно и то же
время может пытаться работать более одного процесса.  В примере с
банковским счетом во время каждой транзакции клиент должен иметь
возможность действовать так, как будто остальных клиентов не
существует.  Когда клиент изменяет баланс, исходя из
его предыдущего значения, ему надо обеспечить гарантии того,
что прямо перед моментом изменения баланс все еще
соответствует его, клиента, представлениям.

\paragraph{Правильное поведение параллельных программ}


 \index{ru}{параллелизм|правильность параллельных программ||||}%
Вышеприведенный пример демонстрирует типичную неочевидную
ошибку, которая может возникнуть в параллельной программе.  Сложность здесь
восходит к присваиванию переменным, разделяемым между различными
процессами.  Мы уже знаем, что при работе с
{\tt set!} требуется осторожность, потому что результаты вычислений зависят от
порядка, в котором происходят присваивания\footnote{Программа подсчета факториала из
раздела~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT} демонстрирует
это в рамках одного последовательного процесса.}.
При наличии параллелизма нужно быть острожным вдвойне,
поскольку не всегда можно управлять порядком, в
котором присваивания происходят в разных процессах.  Если несколько
таких изменений могут происходить одновременно (как в случае с двумя
вкладчиками, имеющими доступ к общему счету), нам требуется способ
обеспечить правильную работу системы.  Например, в случае со снятием
денег с общего счета, мы должны сделать так, чтобы общее количество
денег оставалось неизменным.  Чтобы заставить параллельные программы
работать корректно, иногда требуется наложить некоторые ограничения
на одновременное исполнение.

Одно из возможных ограничений на параллелизм может
состоять в том, что никакие две операции, способные изменить
разделяемые переменные состояния, не могут исполняться одновременно.
Это очень серьезное ограничение.  Для распределенной банковской
системы это означало бы, что проектировщик системы должен сделать
так, что в каждый момент происходит не более одной транзакции.  Это
требование чрезмерно консервативное и ведет к неэффективности.  На
рисунке~\ref{P3.30} показан случай с совместным счетом
Петра и Павла, причем у Павла есть еще и собственный счет.  Диаграмма
показывает две операции снятия денег с совместного счета (одну
проводит Петр, одну Павел), а также занесение Павлом денег на личный
счет\footnote{По столбцам: содержимое кошелька Петра, общий
счет (в Банке 1), кошелек Павла и ли\-чный счет Павла (в Банке 2), до и
после каждого снятия (W) и занесения денег на счет (D).  Петр берет 10
долларов из Банка 1; Павел кладет 5 долларов в Банк 2, затем берет 25
долларов из Банка 1.
}.
Два снятия денег с одного счета не должны происходить одновременно
(поскольку оба работают с одним счетом), и Павел не может одновременно снять деньги и
занести их в банк (поскольку и та, и другая операция
касаются кошелька Павла).  Однако не должно быть
препятствий, мешающих Павлу заносить деньги на личный счет в то время, как
Петр берет деньги с общего счета.
\looseness=1

\begin{cntrfig}
\input{xfig-mod/3-30.eepic}
%{\small    Петр -- Банк1 -- Банк2 -- Павел\\
%время}
\caption{Одновременные операции при работе с совместным счетом в Банке~1 и личным счетом в Банке~2.}
\label{P3.30}

\end{cntrfig}

Менее драконовское ограничение на параллелизм могло бы
состоять в том, чтобы параллельная система выдавала такие же
результаты, как если бы процессы происходили последовательно.  У этого
ограничения две важных стороны.  Во-первых, от процессов на самом деле
не требуется последовательного исполнения, а только результаты,
совпадающие с теми, которые {\em получались бы}, если бы они работали
один за другим.  В примере на рис.~\ref{P3.30},
проектировщик банковской системы спокойно может разрешить
одновременное занесение денег
Павлом и снятие их Петром, поскольку общий
результат будет таков, как будто бы они шли последовательно. Во-вторых,
у параллельной программы может быть более одного <<правильного>>
результата, потому что мы требуем только, чтобы он совпадал с
результатом при {\em каком-нибудь} последовательном порядке.
Например, предположим, что общий счет Петра и Павла вначале равен 100 долларам,
Петр кладет на него 40 долларов, а Павел снимает половину имеющихся
там денег. При этом последовательное исполнение может привести к
значению на счету либо в 70, либо в 90 долларов
(см.~упражнение~\ref{EX3.38})\footnote{\label{F3.39}Более формально
  это утверждение можно выразить,
  сказав, что \index{ru}{недетерминизм в поведении параллельных
    программ|||||п}поведение параллельных программ ---
  \index{ru}{недетерминизм в поведении параллельных
    программ||nondeterminism in behaviour of concurrent
    programs|||п}\index{en}{nondeterminism in behaviour of concurrent
    programs||недетерминизм в поведении параллельных программ|||п}{\em
    недетерминированное} (nondeterministic). То есть, они
  описываются не функциями с одним значением, а функциями, чьи
  результаты являются множествами возможных значений.  В
  разделе~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}
  мы рассмотрим язык для выражения недетерминистских вычислений.}.

Можно найти и еще более слабые требования для корректного
выполнения параллельных программ.  Программа,
\index{ru}{диффузия, имитация||imitation of
  diffusion|||}\index{en}{imitation of     diffusion||диффузия,
  имитация|||}имитирующая диффузию
(например, поток тепла в объекте), может состоять из большого числа
процессов, каждый из которых изображает маленький участок
пространства, и которые параллельно обновляют свои значения.  Каждый
процесс в цикле изменяет свое значение на среднее между своим
собственным значением и значениями соседей.  Этот алгоритм сходится к
правильному ответу независимо от порядка, в котором выполняются
операции; нет никакой нужды в ограничениях на параллельное
использование разделяемых значений.

\begin{exercise}{3.38}\label{EX3.38}%
Пусть Петр, Павел и Мария имеют общий счет, на котором
вначале лежит 100 долларов.  Петр кладет на
счет 10 долларов, одновременно с этим Павел берет 20, а Мария берет половину денег со
счета.  При этом они выполняют следующие операции:

\begin{Verbatim}[fontsize=\small]
{\rm Петр:}  (set! balance (+ balance 10))
{\rm Павел:} (set! balance (- balance 20))
{\rm Мария:} (set! balance (- balance (/ balance 2)))
\end{Verbatim}

\begin{plainenum}


\item
Перечислите возможные значения
{\tt balance} после завершения операций, предполагая, что
банковская система требует от транзакций исполняться последовательно в
каком-то порядке.

\item
 Назовите какие-нибудь другие значения, которые
могли бы получиться, если бы система разрешала операциям
чередоваться.  Нарисуйте временные диаграммы, подобные
рис.~\ref{P3.29}, чтобы объяснить, как возникают
такие результаты.
\end{plainenum}
\end{exercise}

\subsection{Механизмы управления параллелизмом}
\label{MECHANISMS-FOR-CONTROLLING-CONCURRENCY}


 \index{ru}{параллелизм|механизмы для управления||||}%
Мы убедились, что сложность работы с параллельными
процессами происходит из необходимости учитывать порядок чередования
событий в различных процессах.  Предположим, к примеру, что у нас есть
два процесса, один с упорядоченными событиями $(a, b, c)$, а
другой с упорядоченными событиями $(x, y, z)$.  Если эти
два процесса исполняются параллельно, без каких-либо дополнительных
ограничений на чередование событий, то возможно 20 различных порядков
событий, соблюдающих упорядочение их внутри каждого из процессов:
$$
\begin{array}{cccc}
(a, b, c, x, y, z) & (a, x, b, y, c, z) & (x, a, b, c, y, z) & (x, a, y, z, b, c)\\
(a, b, x, c, y, z) & (a, x, b, y, z, c) & (x, a, b, y, c, z) & (x, y, a, b, c, z)\\
(a, b, x, y, c, z) & (a, x, y, b, c, z) & (x, a, b, y, z, c) & (x, y, a, b, z, c)\\
(a, b, x, y, z, c) & (a, x, y, b, z, c) & (x, a, y, b, c, z) & (x, y, a, x, b, c)\\
(a, x, b, c, y, z) & (a, x, y, z, b, c) & (x, a, y, b, z, c) & (x, y, x, a, b, c)\\
\end{array}
$$
 При разработке этой системы нам как программистам пришлось бы
рассматривать результаты каждого из этих 20 упорядочений и проверять,
что каждое из них допустимо.  С ростом числа процессов и событий такой
подход быстро становится нереалистичным.

Более практичный подход к проектированию параллельных
систем состоит в том, чтобы придумать общие механизмы, которые бы
ограничивали чередование событий в параллельных процессах и тем самым
давали нам уверенность, что поведение программы верно.  Для этой цели
было разработано большое количество механизмов.  В этом разделе мы
опишем один из них --- \index{ru}{сериализатор||serializer|||}\index{en}{serializer||сериализатор|||}{\em сериализатор} (serializer).

\paragraph{Сериализация доступа к разделяемой памяти}


Идея сериализации заключается в следующем: процессы
выполняются параллельно, но при этом существуют определенные группы
процедур, которые не могут выполняться одновременно.  Выражаясь
точнее, сериализация порождает выделенные множества процедур, такие,
что в каждом сериализованном множестве в любой момент может
происходить выполнение только одной процедуры из множества.  Если
какая-то процедура из множества уже выполняется, то процесс, который
пытается выполнить любую процедуру из множества, будет приостановлен до
тех пор, пока не закончится текущее вычисление процедуры.

С помощью сериализации можно управлять доступом к
разделяемым переменным.  Например, если мы хотим присвоить разделяемой
переменной значение, зависящее от ее текущего значения, мы помещаем
доступ к прежнему значению и присваивание нового в одну процедуру.
Затем мы помещаем все такие процедуры в один сериализатор и тем самым
добиваемся того, что никакая другая процедура, которая
присваивает значения этой переменной, не может выполняться
одновременно с нашей.  Это гарантирует нам, что значение переменной не
может измениться в промежутке между доступом к ней и соответствующим
ему присваиванием.

\paragraph{Сериализаторы в Scheme}


Чтобы сделать это описание более конкретным, предположим,
что мы расширили язык Scheme, добавив в него процедуру
{\tt parallel-execute}:

\begin{Verbatim}[fontsize=\small]
 (parallel-execute \textit{$\langle$$p_1$$\rangle$} \textit{$\langle$$p_2$$\rangle$} ... \textit{$\langle$$p_k$$\rangle$})
\end{Verbatim}
\index{ru}{parallel-execute||||p|}
Каждый из \textit{$\langle$$p$$\rangle$} должен быть процедурой без
аргументов. {\tt Parallel-execute} создает для каждого
\textit{$\langle$$p$$\rangle$} отдельный процесс, который выполняет
\textit{$\langle$$p$$\rangle$} (с пустым набором аргументов).  Все
эти процессы выполняются параллельно\footnote{{\tt Parallel-execute} не входит в стандартную
Scheme, но такая процедура может быть реализована в MIT Scheme.  В
нашей реализации новые процессы выполняются параллельно еще и с
исходным Scheme-процессом.  Кроме того, в нашей реализации значение,
которое возвращает {\tt parallel-execute}, представляет собой
специальный управляющий объект, с помощью которого можно остановить
все новосозданные процессы.
}.

Чтобы продемонстрировать, как эта процедура используется,
рассмотрим

\begin{Verbatim}[fontsize=\small]
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (+ x 1))))
\end{Verbatim}
Здесь создаются два параллельных процесса --- $P_1$,
который присваивает {\tt x} значение {\tt x} умножить на
{\tt x}, и $P_2$, который увеличивает {\tt x}
на единицу.  После того, как вычисление закончено,
{\tt x} может иметь одно из пяти значений, в зависимости от
чередования событий в $P_1$ и $P_2$:

\begin{plainlist}


\item
101: $P_1$ делает {\tt x} равным
100, затем $P_2$ его увеличивает.

\item
121: $P_2$ увеличивает {\tt x},
делая его равным 11, затем $P_1$ присваивает ему значение
{\tt x} умножить на {\tt x}.

\item
110: $P_2$ изменяет {\tt x} с 10
на 11 в промежутке между двумя обращениями к {\tt x} из
$P_1$ во время вычисления {\tt (* x x)}.

\item
11: $P_2$ читает {\tt x}, затем
$P_1$ присваивает ему значение 100, затем $P_1$
пишет {\tt x}

\item
100: $P_1$ читает {\tt x}
(дважды), затем $P_2$ присваивает ему значение 11, затем
$P_1$ записывает значение {\tt x}.
\end{plainlist}

Мы можем ограничить параллелизм, используя
сериализованные процедуры, которые создаются
\index{ru}{сериализатор||serializer|||}\index{en}{serializer||сериализатор|||}{\em сериализаторами} (serializers). Сериализаторы
порождаются процедурой {\tt make-serializer}, реализация которой
дана ниже.  Сериализатор принимает в качестве аргумента процедуру, и
возвращает сериализованную процедуру с таким же поведением.  Все
вызовы сериализатора порождают сериализованные процедуры,
принадлежащие одному множеству.

Таким образом, в отличие от предыдущего примера,
выполнение

\begin{Verbatim}[fontsize=\small]
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))
\end{Verbatim}
может иметь только два результата, 101 и 121.  Остальные возможности
отбрасываются, поскольку выполнение $P_1$ и $P_2$
не может чередоваться.

Ниже приведена версия  \index{ru}{банковский             счет|сериализованный||||}
процедуры {\tt make-account} из
раздела~\ref{LOCAL-STATE-VARIABLES}, в которой помещение денег на
счет и снятие их со счета сериализованы:

\begin{Verbatim}[fontsize=\small]
(define (make-account balance)\index{ru}{make-account|с сериализацией|||pd|}
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                         m))))
    dispatch))
\end{Verbatim}
В такой реализации два процесса не могут параллельно помещать деньги
на счет или снимать их.  Таким образом устраняется источник ошибки,
показанной на рис.~\ref{P3.29}, где Петр изменяет баланс
на счете в промежутке между моментами, когда Павел считывает значение
баланса, и когда он производит присваивание.  С другой стороны, у
каждого счета свой собственный сериализатор, так что операции с
различными счетами могут происходить параллельно.
\begin{exercise}{3.39}\label{EX3.39}%
Какие из пяти возможных исходов параллельного
выполнения сохраняются, если мы сериализуем выполнение таким образом:

\begin{Verbatim}[fontsize=\small]
(define x 10)
(define s (make-serializer))
(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                  (s (lambda () (set! x (+ x 1)))))
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.40}\label{EX3.40}%
Укажите все возможные значения {\tt x} при
выполнении

\begin{Verbatim}[fontsize=\small]
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
\end{Verbatim}
Какие из них сохраняются, если вместо этого мы выполняем
сериализованные процедуры:

\begin{Verbatim}[fontsize=\small]
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.41}\label{EX3.41}%
Бен Битобор считает, что лучше было бы реализовать
банковский счет таким образом (измененная строка отмечена
комментарием):

\begin{Verbatim}[fontsize=\small]
(define (make-account balance)\index{ru}{make-account|с сериализацией|||pd|(упр.~3.41)}
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected (lambda () balance)))) {\em ; сериализовано}
            (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                         m))))
    dispatch))
\end{Verbatim}
поскольку несериализованный доступ к банковскому счету может привести
к неправильному поведению.  Вы согласны?  Существует ли сценарий,
который демонстрирует обоснованность беспокойства Бена?
\end{exercise}
\begin{exercise}{3.42}\label{EX3.42}%
Бен Битобор говорит, что слишком расточительно в ответ
на каждое сообщение {\tt with\-draw} и {\tt deposit}
создавать по новой сериализованной процедуре.  Он говорит, что можно
изменить {\tt make-account} так, чтобы все вызовы
{\tt protected} происходили вне процедуры
{\tt dispatch}. Таким образом, счет будет возвращать одну и ту
же сериализованную процедуру (созданную тогда же, когда и сам счет)
каждый раз, когда у него просят процедуру снятия денег:

\begin{Verbatim}[fontsize=\small]
(define (make-account balance)\index{ru}{make-account|с сериализацией|||pd|(упр.~3.42)}
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                           m))))
      dispatch)))
\end{Verbatim}
Безопасно ли такое изменение?  В частности, есть ли разница в том,
в каком порядке может происходить параллельное выполнение в этих двух
версиях {\tt make-account}?
\end{exercise}

\paragraph{Сложности при использовании множественных разделяемых
ресурсов}


 \index{ru}{сериализатор|с множественными разделяемыми ресурсами||||}
\index{ru}{разделяемые ресурсы||shared resources|||}\index{en}{shared resources||разделяемые ресурсы|||}
Сериализаторы предоставляют нам мощную абстракцию,
которая позволяет изолировать сложности выполнения параллельных программ, так
что мы получаем возможность работать с ними аккуратно (и, будем
надеяться, без ошибок).  Однако, хотя при работе только с одним
разделяемым ресурсом (например, с одним банковским счетом)
использовать сериализаторы относительно просто, при наличии
множественных разделяемых ресурсов параллельное программирование может
быть предательски сложным.

Чтобы проиллюстрировать одну из ряда трудностей, которые могут
возникнуть, предположим, что нам требуется
\index{ru}{банковский счет|мена балансов местами||||}
поменять местами балансы на
двух банковских счетах.  Мы читаем каждый счет, чтобы узнать баланс,
вычисляем разницу между балансами, снимаем ее с одного счета и кладем
на другой.  Это можно реализовать следующим образом\footnote{Мы упростили {\tt exchange}, пользуясь тем,
что наше сообщение {\tt deposit} может принимать
отрицательные суммы. (Для банковской системы это серьезная ошибка!)
}:

\begin{Verbatim}[fontsize=\small]
(define (exchange account1 account2)\index{ru}{exchange||||pd|}
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
\end{Verbatim}

Эта процедура работает правильно в том случае,
когда только один процесс пытается осуществить обмен.  Допустим,
однако, что Петр и Павел имеют доступ к совместным счетам
$a1$, $a2$ и $a3$, и что Петр
меняет местами $a1$ и $a2$, а Павел в то же время
обменивает $a1$ и $a3$.  Даже если снятие и
занесение денег на отдельные счета сериализованы (как в процедуре
{\tt make-account} из предыдущего раздела),
{\tt exchange} может привести к неверным результатам.
Например, может оказаться, что Петр посчитает разницу между $a1$ и
$a2$, но Павел изменит баланс на $a1$ прежде, чем Петр
закончит обмен\footnote{Если балансы на счетах вначале равны 10, 20 и 30
долларам, то после любого количества параллельных обменов балансы
должны по прежнему быть 10, 20 и 30, в каком-то порядке.  Сериализации
доступа к отдельным счетам недостаточно, чтобы это
гарантировать. См.~упр.~\ref{EX3.43}.
}.
Чтобы добиться правильного поведения, мы должны устроить так, чтобы
процедура {\tt exchange} блокировала всякий параллельный доступ к
счетам на все время обмена.

Один из способов этого достичь --- сериализовать всю
процедуру {\tt exchange} сериализаторами обоих счетов.  Ради
этого мы откроем доступ к сериализаторам счетов.  Обратите внимание,
что, раскрывая сериализатор, мы намеренно ломаем модульное построение
объекта-банковского счета.  Следующая версия процедуры
{\tt make-account} идентична исходной версии из
раздела~\ref{LOCAL-STATE-VARIABLES}, за исключением того, что
имеется сериализатор для защиты переменной баланса, и он
экспортируется через передачу сообщений:

\begin{Verbatim}[fontsize=\small]
(define (make-account-and-serializer balance)\index{ru}{make-account-and-serializer||||pd|}
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                         m))))
    dispatch))
\end{Verbatim}

С помощью этой версии мы можем выполнять сериализованное
занесение и снятие денег.  Заметим, однако, что, в отличие от
предыдущей версии сериализованного счета, теперь каждый
пользователь объектов-банковских счетов должен явным образом управлять
сериализацией, например, так\footnote{В упражнении~\ref{EX3.45} рассматривается
вопрос, почему занесение и снятие денег теперь не сериализуются счетом
автоматически.}:\index{ru}{deposit, с внешним сериализатором||||pd|}
\begin{Verbatim}[fontsize=\small]
(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
\end{Verbatim}

Экспорт сериализатора дает нам достаточно гибкости,
чтобы реализовать сериализованную программу обмена.  Мы
просто-напросто сериализуем исходную процедуру {\tt exchange}
сериализаторами обоих счетов:

\begin{Verbatim}[fontsize=\small]
(define (serialized-exchange account1 account2) \index{ru}{serialized-exchange||||pd|}
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
\end{Verbatim}

\begin{exercise}{3.43}\label{EX3.43}%
Предположим, что значения баланса на трех счетах
вначале равны  10, 20 и 30 долларам, и что несколько
процессов занимаются обменом значений баланса.  Покажите, что если эти
процессы выполняются последовательно, то после любого количества
обменов значения баланса по-прежнему будут равны 10, 20 и 30 долларам,
в каком-то порядке.  Нарисуйте временную диаграмму вроде той, которая
изображена на рис.~\ref{P3.29}, и покажите, что указанное
условие может нарушаться, если работает первая версия процедуры обмена
из этого раздела.  Покажите, с другой стороны, что даже с первой
программой {\tt exchange} общая сумма балансов на счетах
сохранится. Нарисуйте временную диаграмму, показывающую, что если бы
мы не сериализовали транзакции по отдельным счетам, это условие тоже
могло бы нарушаться.
\end{exercise}
\begin{exercise}{3.44}\label{EX3.44}%
Рассмотрим задачу  \index{ru}{банковский счет|перенос           денег||||(упр.~3.44)} переноса денег с
одного счета на другой.  Бен Битобор утверждает, что ее можно
решить с помощью следующей процедуры, даже в тех случаях, когда много
людей одновременно перемещают деньги между различными счетами, если
использовать при этом какой-то механизм, сериализующий операции
занесения на счет и снятия со счета, например, версию
{\tt make-account} из нашего текста.

\begin{Verbatim}[fontsize=\small]
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
\end{Verbatim}
Хьюго Дум считает, что с этой версией возникнут проблемы и что нужно
использовать более сложный подход, вроде того, который требуется при
решении задачи обмена.  Прав ли он?  Если нет, то в чем состоит
существенная разница между задачей перевода денег и задачей обмена
счетов?  (Нужно предположить, что значение баланса на
{\tt from-account} по крайней мере равно {\tt amount}.)
\end{exercise}
\begin{exercise}{3.45}\label{EX3.45}%
Хьюго Дум полагает, что теперь, когда операции
снятия денег со счета и занесения их на счет перестали
сериализовываться автоматически, система банковских счетов
стала неоправданно сложной и работать с ней правильным образом чересчур
трудно.  Он предлагает сделать так, чтобы
{\tt make-account-and-serializer} экспортировал сериализатор
(для использования в процедурах вроде
{\tt serialized-exchange}), и вдобавок сам использовал его для
сериализации простых операций со счетом, как это делал
{\tt make-account}.  Он предлагает переопределить объект-счет
так:

\begin{Verbatim}[fontsize=\small]
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                         m))))
    dispatch))

(define (deposit account amount)
 ((account 'deposit) amount))
\end{Verbatim}

Объясните, в чем Хьюго ошибается.  В частности, рассмотрите, что
происходит при вызове {\tt serialized-exchange}.
\end{exercise}

\paragraph{Реализация сериализаторов}

\index{ru}{сериализатор|реализация||||}
Мы реализуем сериализаторы на основе более примитивного
механизма  синхронизации, называемого
\index{ru}{мьютекс||mutex|||}\index{en}{mutex||мьютекс|||}{\em мьютекс} (mutex).  Мьютекс ---
это объект, который
поддерживает две операции:
его можно \index{ru}{захват мьютекса||acquiring a mutex|||}\index{en}{acquiring a mutex||захват мьютекса|||}{\em захватить} (acquire), и его можно
\index{ru}{освобождение мьютекса|||||}\index{ru}{освобождение
  мьютекса||releasing a mutex|||}\index{en}{releasing a
  mutex||освобождение мьютекса|||}{\em освободить} (release).
Когда мьютекс
захвачен, никакая другая операция захвата того же самого мьютекса
произойти не может, пока его не освободят\footnote{Название <<мьютекс>> происходит от английского
\index{ru}{взаимное исключение||mutual exclusion|||п}\index{en}{mutual exclusion||взаимное исключение|||п}{\em mutual exclusion} <<взаимное исключение>>.  Общая проблема
построения механизма, который позволил бы параллельным процессам
безопасно разделять ресурсы, называется проблемой взаимного
исключения.  Наши мьютексы являются простым вариантом механизма
\index{ru}{семафор||semaphore|||п}\index{en}{semaphore||семафор|||п}{\em семафоров} (semaphores)
(см.~упражнение~\ref{EX3.47}),
которые впервые появились в
\index{ru}{THE, Система Мультипрограммирования|||||п}Системе
Мультипрограммирования THE, разработанной в
\index{ru}{Эйндховенский технический Университет|||||п}Эйндховенском
Техническом
Университете и названной по первым буквам голландского названия этого
учебного заведения (Dijkstra 1968a).\index{ru}{Дейкстра, Эдсгер
  Вибе||Edsger Wybe Dijkstra||n|п}\index{en}{Edsger Wybe
  Dijkstra||Дейкстра, Эдсгер Вибе||n|п}
Операции захвата и
освобождения изначально назывались \index{ru}{P-операция на
  семафоре|||||п}P и \index{ru}{V-операция на семафоре|||||п}V, от
голландских глаголов
{\em passeren} (пройти) и {\em vrijgeven} (освободить),
употребляемых по отношению к семафорам на железных дорогах.
Классическое описание Дейкстры (Dijkstra 1968b)
было одним из первых ясных изложений вопросов управления
параллелизмом, и там было показано, как решаются  при помощи семафоров
различные задачи.}.
В нашей реализации каждый сериализатор содержит по мьютексу.  Получая
процедуру {\tt p}, сериализатор возвращает процедуру,
которая захватывает мьютекс, выполняет {\tt p}, и затем
освобождает мьютекс.  Благодаря этому, только одна из процедур,
порожденных сериализатором, может исполняться в каждый момент времени.
Именно такого поведения мы и хотели добиться от сериализации.

\begin{Verbatim}[fontsize=\small]
(define (make-serializer)\index{ru}{make-serializer||||pd|}
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
\end{Verbatim}


Мьютекс --- изменяемый объект (здесь мы используем
одноэлементный список, который будем называть
\index{ru}{ячейка, в реализации сериализатора||cell, in serializer implementation|||}\index{en}{cell, in serializer implementation||ячейка, в реализации сериализатора|||}{\em ячейкой} (cell)),
способный хранить значение истина или ложь.  Когда значение ложно,
мьютекс можно захватывать.  Когда значение истинно, мьютекс недоступен,
и процесс, который попытается его захватить, вынужден будет ждать.

Конструктор мьютекса {\tt make-mutex} для начала
присваивает содержимому ячейки значение ложь.  Для захвата мьютекса мы проверяем
значение ячейки.  Если мьютекс доступен, мы делаем значение истинным и
идем дальше.  Если нет, мы входим в цикл ожидания, все время пытаясь
захватить мьютекс, пока он не окажется свободным\footnote{В большинстве систем разделения времени процессы,
  блокированные на мьютексе, не тратят время в
  \index{ru}{занятое ожидание||busy waiting|||п}\index{en}{busy
    waiting||занятое ожидание|||п}<<занятом ожидании>>, как
  это описано здесь.  Вместо этого система назначает на исполнение другой
  процесс, пока первый ждет, а когда мьютекс освобождается, она будит
  \index{ru}{заблокированный процесс||blocked
    process|||п}\index{en}{blocked     process||заблокированный
    процесс|||п}заблокированный процесс.}.
Чтобы освободить мьютекс, мы присваиваем значению ячейки ложь.

\begin{Verbatim}[fontsize=\small]
(define (make-mutex)\index{ru}{make-mutex||||pd|}
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire)))
            ((eq? m 'release) (clear! cell))))
    the-mutex))
\end{Verbatim}


{\tt Test-and-set!} проверяет ячейку и возвращает
результат проверки.  Помимо того, если значение было ложным,
{\tt test-and-set!} устанавливает значение в истину, прежде чем
вернуть ложь.  Мы можем описать это поведение так:

\begin{Verbatim}[fontsize=\small]
(define (test-and-set! cell)\index{ru}{test-and-set!||||pd|}
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))
\end{Verbatim}


Однако эта реализация {\tt test-and-set!}, как она
есть, не годится.  Здесь есть важная тонкость, и именно здесь
управление параллелизмом становится частью системы: операция
{\tt test-and-set!} должна производиться
\index{ru}{атомарность||atomicity|||}\index{en}{atomicity||атомарность|||}{\em атомарно} (atomically).  Это значит, что мы должны
гарантировать, что когда процесс протестировал ячейку и убедился, что
ее значение ложь, значение будет установлено в истину прежде, чем
какой-либо еще процесс успеет проверить ячейку.  Если мы такую  гарантию
не обеспечим, мьютекс может сломаться таким же образом, как банковский
счет на рис.~\ref{P3.29}.
(См.~упражнение~\ref{EX3.46}.)

Реализация {\tt test-and-set!} зависит от того,
как наша система на самом деле управляет параллельными процессами.
Например, мы можем выполнять параллельные процессы на последовательном
процессоре при помощи механизма
\index{ru}{разделение времени||time slicing|||}\index{en}{time slicing||разделение времени|||}%
разделения времени, который перебирает
процессы по очереди, дает каждому из них выполняться в течение
небольшого промежутка времени, а затем прерывает его и переходит к
следующему процессу.  В таком случае {\tt test-and-set!} может
запрещать смену процесса в момент между проверкой и
присваиванием\footnote{В MIT Scheme на однопроцессорной системе можно реализовать
{\tt test-and-set!} следующим образом:

\begin{Verbatim}
(define (test-and-set! cell)\index{ru}{test-and-set!||||pd|п}
  (without-interrupts \index{ru}{MIT Scheme|{\tt without-interrupts}||||п} \index{ru}{without-interrupts||||p|п}
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
\end{Verbatim}
{\tt Without-interrupts} запрещает прерывания по таймеру, пока
выполняется его процедурный аргумент.
}.
С другой стороны, в многопроцессорных компьютерах бывают команды,
которые обеспечивают \index{ru}{атомарные операции, поддерживаемые на уровне     аппаратуры||atomic     operations supported in hardware|||}\index{en}{atomic     operations supported in hardware||атомарные операции, поддерживаемые на уровне     аппаратуры|||}%
атомарные операции прямо на уровне аппаратуры\footnote{Есть много вариантов таких команд~--- включая
проверку-и-установку, проверку-и-сброс, обмен, сравнение-и-обмен,
загрузку с резервированием и условную запись, --- и их форма должна
точно соответствовать интерфейсу между процессором и памятью в данной
машине.  Один из возникающих вопросов состоит в том, что происходит,
когда два процесса пытаются получить один и тот же ресурс в точности
одновременно при помощи такой команды.  Тут требуется какой-то
механизм, принимающий решение, который из процессов получает
управление.  Такой механизм называется
\index{ru}{арбитр||arbiter|||п}\index{en}{arbiter||арбитр|||п}{\em арбитром} (arbiter).  Обычно арбитры представляют
собой аппаратные устройства.  К сожалению, можно доказать, что нельзя
построить справедливого арбитра, работающего в 100\% случаев, если не
позволять арбитру принимать решение неопределенно долгое время.
Сущность этого явления была открыта французским философом XIV века
Жаном Буриданом\index{ru}{Буридан, Жан||Jean Buridan||n|п}\index{en}{Jean Buridan||Буридан, Жан||n|п}
в комментарии к
\index{ru}{Аристотель, {\em De caelo} (комментарий Ж.~Буридана)|||||п}
{\em De caelo} Аристотеля.
Буридан указал, что
\index{ru}{собака идеально разумная, поведение||behavior of a perfectly rational dog|||п}\index{en}{behavior of a perfectly rational dog||собака идеально разумная, поведение|||п}
идеально разумная собака, помещенная между двумя
одинаково привлекательными кусками еды, должна умереть от голода,
поскольку она не сможет решить, к какому куску идти в первую очередь.
}.
\begin{exercise}{3.46}\label{EX3.46}%
Допустим, что мы реализуем {\tt test-and-set} в
виде обыкновенной процедуры, как показано в тексте, не пытаясь сделать
ее атомарной.  Нарисуйте временную диаграмму, подобную диаграмме на
рис.~\ref{P3.29}, и покажите, как реализация мьютекса может
ошибиться и позволить двум процессам одновременно захватить мьютекс.
\end{exercise}
\begin{exercise}{3.47}\label{EX3.47}%
\index{ru}{семафор|размера $n$||||(упр.~3.47)} Семафор (размера $n$) представляет собой
обобщение мьютекса.  Подобно мьютексу, семафор поддерживает операции
захвата и освобождения, но захватить его одновременно могут до
$n$ процессов.  Прочие процессы, которые попытаются
захватить семафор, должны будут ждать освобождения.  Дайте реализацию
семафоров
\begin{plainenum}


\item
в терминах мьютексов.

\item
в терминах атомарных операций {\tt test-and-set!}.
\end{plainenum}
\end{exercise}

\paragraph{Тупик}


\index{ru}{параллелизм|тупик||||}\index{ru}{тупик|||||}Теперь, когда
мы рассмотрели, как реализуются
сериализаторы, мы убеждаемся, что с обменом счетов по-прежнему
связаны проблемы, даже с вышеописанной процедурой
{\tt serialized-exchange}.  Допустим, что Петр хочет обменять
$a1$ и $a2$, а Павел в то же время пытается
обменять $a2$ и $a1$.  Допустим, что процесс
Петра доходит до некоторой точки внутри сериализованной процедуры,
защищающей $a1$, и сразу вслед за этим процесс Павла входит
в сериализованную процедуру, защищающую $a2$.  Теперь Петр
не может двигаться дальше (ему надо войти в сериализованную процедуру
для $a2$), пока Павел не выйдет из сериализованной
процедуры для $a2$.  Точно так же Павел не может двигаться
дальше, пока Петр не выйдет из сериализованной процедуры для
$a1$.  Оба процесса замирают навеки в ожидании друг
друга.  Такая ситуация называется \index{ru}{тупик||deadlock|||}\index{en}{deadlock||тупик|||}{\em тупик} (deadlock).  В
любой системе, которая предоставляет доступ к множественным
разделяемым ресурсам, существует опасность тупика.




В этой ситуации можно \index{ru}{тупик|способ избежания||||}избежать тупика, если присвоить каждому
счету уникальный идентификационный номер, и переписать
{\tt serialized-exchange} так, чтобы процесс всегда пытался
сначала войти в процедуру, которая защищает счет с наименьшим
номером.  Хотя для задачи обмена это решение работает хорошо, бывают и
другие ситуации, в которых требуются более развитые методы избежания
тупиков, или где тупика нельзя избежать в принципе.
(См.~упражнения~\ref{EX3.48} и \ref{EX3.49}.)\footnote{Общий метод избежания тупиков путем нумерации
  разделяемых ресурсов и захвата их по порядку придумал Хейвендер
  (Havender 1968).  В ситуациях, где тупика нельзя
  избежать,\index{ru}{Хейвендер,
    Дж.||J.~Havender||n|п}\index{en}{J.~Havender||Хейвендер, Дж.||n|п}
  нужны меры по
  \index{ru}{тупик|выход||||п}\index{ru}{выход из тупика||deadlock
    recovery|||п}\index{en}{deadlock recovery||выход из тупика|||п}{\em
    выходу из тупика} (deadlock recovery), когда от
  процессов требуется <<откатиться>> из тупикового состояния и повторить
  попытку.  Механизмы выхода из тупика широко используются в
  системах управления базами данных.  Эта тема детально рассматривается
  у Грея и Рейтера (Gray and Reuter 1993).\index{ru}{Грей, Джим||Jim
    Gray||n|п}\index{en}{Jim Gray||Грей, Джим||n|п}\index{ru}{Рейтер,
    Андреас||Andreas Reuter||n|п}\index{en}{Andreas Reuter||Рейтер,
    Андреас||n|п} }
{\sloppy

}
\begin{exercise}{3.48}\label{EX3.48}%
Подробно объясните, почему метод избежания тупиков,
описанный выше (т.~е. счета нумеруются, и каждый процесс сначала
пытается захватить счет с меньшим номером), в самом деле позволяет
избежать тупика в задаче
обмена балансов.  Перепишите
\index{ru}{serialized-exchange|с избежанием тупиков|||p|(упр.~3.48)}
{\tt serialized-exchange}
с использованием этой идеи.  (Придется также изменить
{\tt make-account}, так, чтобы каждый счет создавался вместе с
номером, и чтобы этот номер можно было считать, послав
соответствующее сообщение.)
\end{exercise}
\begin{exercise}{3.49}\label{EX3.49}%
Опишите сценарий, в котором вышеописанный механизм
избежания тупиков не работает.  (Подсказка: в задаче обмена счетов
каждый процесс заранее знает, к каким счетам ему нужен будет доступ.
Рассмотрите ситуацию, в которой процессу нужно сначала получить доступ к каким-то
разделяемым ресурсам, прежде чем он сможет определить, какие ресурсы
ему потребуются дополнительно.)
\end{exercise}

\paragraph{Параллелизм, время и взаимодействие}


Мы видели, что для программирования параллельных систем,
когда различные процессы имеют доступ к разделяемому состоянию,
необходимо управление порядком событий, и мы видели, как можно добиться
нужного порядка с помощью надлежащего использования сериализаторов.
Однако проблемы параллелизма лежат глубже, поскольку, с
фундаментальной точки зрения, не всегда ясно, что имеется в виду под
<<разделяемым состоянием>>.

{Механизмы вроде {\tt test-and-set!} требуют, чтобы
процессы в произвольные моменты времени имели доступ к глобальному разделяемому
флагу.  На современных высокоскоростных процессорах это реализуется сложно и
неэффективно, поскольку, благодаря средствам оптимизации
вроде конвейеров и кэширования памяти,  содержимое памяти
не обязательно должно в каждый момент находиться в непротиворечивом
состоянии.  Из-за этого в современных многопроцессорных системах
идея сериализаторов вытесняется новыми подходами к управлению
параллелизмом\footnote{Один из подходов, альтернативных сериализации,
называется \index{ru}{барьерная синхронизация||barrier synchronization|||п}\index{en}{barrier synchronization||барьерная синхронизация|||п}{\em барьерная
синхронизация} (barrier synchronization).  Программист позволяет параллельным процессам
выполняться как угодно, но устанавливает определенные точки
синхронизации (<<барьеры>>), так что ни один процесс не может
продолжаться, пока все они не достигли барьера.  Современные
процессоры обладают машинными командами, которые позволяют
программистам устанавливать точки синхронизации там, где требуется
иметь непротиворечивое состояние.  Например, в  \index{ru}{PowerPC|||||п} Power PC${}^{\mbox{TM}}$ имеются две
предназначенные для этого
команды:  \index{ru}{SYNC|||||п}SYNC и \index{ru}{EIEIO|||||п} EIEIO (Enforced In-Order Execution of Input-Output,
Гарантированно Последовательное Исполнение Ввода-Вывода).
}.

\looseness=2}

Кроме того, проблемы с разделяемым состоянием возникают в
больших распределенных системах.  Например, рассмотрим распределенную
банковскую систему, в которой отдельные местные банки поддерживают
собственные значения баланса счетов и время от времени сравнивают их
со значениями, хранимыми в других местах.  В такой системе значение
<<баланс счета>> не будет определенным ни в какой момент, кроме как сразу после
синхронизации.  Если Петр вносит деньги на счет, который он делит с
Павлом, когда мы должны считать, что баланс изменился, --- когда
меняется баланс в местном банке или только после синхронизации?  А
если Павел обращается к счету через другую ветвь системы, какие
ограничения нужно наложить на банковскую систему, чтобы ее
поведение считалось <<правильным>>?  Единственное, что может иметь
значение для определения <<правильности>>, --- это поведение, которое
Павел и Петр наблюдают по отдельности, и состояние счета сразу после
синхронизации.  Вопросы о <<настоящем>> значении баланса или порядке
событий между синхронизациями могут не иметь значения или даже
смысла\footnote{Такая точка зрения может казаться странной, но при
этом существуют системы, которые именно так и работают.
\index{ru}{кредитные счета, международные||international credit-card accounts|||п}\index{en}{international credit-card accounts||кредитные счета, международные|||п}Изменения на счетах, связанных с кредитными картами, например, обычно
поддерживаются отдельно в каждой стране, а изменения в различных
странах согласовываются время от времени.  Таким образом, баланс на счете
может быть различным в различных странах.
}.

\index{ru}{время|и взаимодействие процессов||||}
Общее в этих проблемах то, что синхронизация
различных процессов, установление общего состояния и управление
порядком событий требуют взаимодействия процессов.  В сущности, любое
понятие времени при управлении параллельными процессами должно быть
прочно привязано к взаимодействию процессов\footnote{Для распределенных систем эта точка зрения
исследовалась Лэмпортом (Lamport 1978).  Он
\index{ru}{Лэмпорт, Лесли||Leslie Lamport||n|п}\index{en}{Leslie Lamport||Лэмпорт, Лесли||n|п}
показал, как при помощи взаимодействия установить <<глобальные
часы>>, через которые можно управлять порядком событий в
распределенных системах.
}.
Любопытно, что похожая связь между временем и обменом информацией возникает
в \index{ru}{относительности теория||theory of       relativity|||}\index{en}{theory of       relativity||относительности теория|||}теории относительности, где скорость света (самого быстрого сигнала,
который можно использовать для синхронизации событий) служит
универсальной константой, связывающей пространство и время.  Сложности,
с которыми мы сталкиваемся при работе с временем и состоянием в
вычислительных моделях, могут на самом деле отражать фундаментальную
сложность физического мира.
\looseness=-1

\section{Потоки}
\label{STREAMS}

\index{ru}{поток(и)|||||}Теперь у нас есть ясное понимание того, как присваивание
может служить инструментом моделирования, а также понятие о сложности
проблем, связанных с ним.  Пора задать вопрос, нельзя ли
организовать работу иначе и избежать части этих проблем.  В этом
разделе мы исследуем альтернативный подход к моделированию состояния,
основанный на структурах данных, называемых
\index{ru}{поток(и)||stream|||}\index{en}{stream||поток(и)|||}{\em потоками} (streams).
Как нам предстоит убедиться, потоки могут
смягчить некоторые трудности в моделировании состояния.

Давайте сделаем шаг назад и рассмотрим еще раз, откуда
происходят эти сложности.  Пытаясь моделировать явления реального
мира, мы приняли несколько, казалось бы, разумных решений: мы
моделировали объекты внешнего мира, обладающие состоянием, при помощи
вычислительных объектов с внутренними переменными.  Мы
отождествили течение времени в мире с течением времени в
компьютере.  Мы имитировали на компьютере изменение состояния моделируемых объектов
при помощи присваивания внутренним переменным объектов-моделей.

Возможен ли другой подход?  Можно ли избежать отождествления
времени в компьютере с временем в моделируемом мире?  Должны ли мы
заставить модель изменяться во времени, чтобы смоделировать явления
изменяющегося мира?  Давайте подумаем об этом в терминах
математических функций.  Можно описать изменение во времени величины
$x$ с помощью функции $x(t)$, где время
выступает как аргумент.  Если мы сосредотачиваем внимание на
$x$ момент за моментом, мы думаем об изменяющейся
величине.  Однако если мы обращаем внимание на всю хронологию
значений, мы не подчеркиваем изменение --- функция сама по себе не
изменяется\footnote{Физики иногда принимают эту точку зрения, вводя
\index{ru}{мировая линия частицы||world line of a     particle|||п}\index{en}{world line of a     particle||мировая линия частицы|||п}
<<мировые
линии>> частиц в рассуждениях о движении.  Кроме того, мы уже
упоминали (в
разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}), что это
естественный ход мысли при рассужднениях о системах обработки сигналов.  Мы
рассмотрим приложение потоков к обработке сигналов в
разделе~\ref{EXPLOITING-THE-STREAM-PARADIGM}.
}.

Если время измеряется дискретными интервалами, мы можем
смоделировать функцию времени как последовательность  (возможно, бесконечную).
В этом разделе мы увидим, как моделировать
изменение в виде последовательностей, которые представляют
картины изменения во времени систем, подвергаемых моделированию.
С этой целью мы вводим новую структуру данных, называемую
\index{ru}{поток(и)||stream|||}\index{en}{stream||поток(и)|||}{\em поток} (stream).  С абстрактной точки зрения, поток
--- это просто последовательность.  Однако, как мы увидим, прямое
представление потоков в виде списков (как в
разделе~\ref{REPRESENTING-SEQUENCES}) не полностью раскрывает мощь
работы с потоками.  В качестве альтернативы мы введем метод
\index{ru}{задержанные вычисления||delayed evaluation|||}\index{en}{delayed evaluation||задержанные вычисления|||}{\em задержанных вычислений} (delayed evaluation),
который позволит нам представлять очень большие (даже бесконечные)
последовательности в виде потоков.

Работа с потоками позволяет моделировать системы,
обладающие состоянием, совершенно не используя присваивание и
изменяемые данные.  Отсюда есть важные следствия, как теоретические,
так и практические, поскольку мы приобретаем возможность строить модели, лишенные
недостатков, связанных с присваиванием.  С другой стороны, парадигма
потоков вызывает свои собственные трудности, и вопрос, какой из
методов моделирования ведет к построению более модульных и
легко поддерживаемых систем, остается открытым.

\subsection{Потоки как задержанные списки}
\label{STREAMS-ARE-DELAYED-LISTS}

\index{ru}{поток(и)|реализованные в виде задержанных списков||||}
Как мы видели в
разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES},
последовательности можно использовать как стандартные интерфейсы для
комбинирования программных модулей.  Мы сформулировали мощные
абстракции для работы с последовательностями, такие как
{\tt map}, {\tt filter} и {\tt accumulate}, с
помощью которых можно описать широкий класс действий одновременно коротко и
изящно.

К сожалению, если представлять последовательности в виде
списков, за это изящество приходится расплачиваться чрезвычайной
неэффективностью как с точки зрения времени, так и с точки зрения
объема памяти, который требуется нашим вычислениям.  Когда мы
представляем операции над последовательностями в виде трансформаций
списков, программам приходится на каждом шагу строить и копировать
структуры данных (которые могут быть громадными).

Чтобы понять, почему это так, сравним две программы для
вычисления суммы всех простых чисел на интервале.  Первая программа
написана в стандартном итеративном стиле\footnote{Мы предполагаем, что у нас имеется предикат
{\tt prime?} (например, из
раздела~\ref{EXAMPLE-TESTING-FOR-PRIMALITY}), который проверяет,
является ли число простым.}:

\begin{Verbatim}[fontsize=\small]
(define (sum-primes a b)  \index{ru}{sum-primes||||pd|}
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
\end{Verbatim}

Вторая программа производит то же самое вычисление с помощью операций
над последовательностями из
раздела~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}:

\begin{Verbatim}[fontsize=\small]
(define (sum-primes a b) \index{ru}{sum-primes||||pd|}
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
\end{Verbatim}

Во время вычисления первая программа должна хранить только
накапливаемую сумму.  Напротив, фильтр во второй программе не может
начать тестировать, пока {\tt enumerate-interval} не создала
полного списка чисел на интервале.  Фильтр порождает еще один список,
который, в свою очередь, передается {\tt accumulate}, прежде,
чем он сожмется в сумму.  Первой программе не требуется такого
количества промежуточной памяти, ---  мы можем считать, что она
просто проходит интервал снизу вверх, добавляя к сумме каждое
простое число, которое ей встретится.

Неэффективность использования списков становится болезненно
очевидной, если мы воспользуемся парадигмой последовательностей для
вычисления второго простого числа в интервале от 1000 до 1 000 000 при
помощи следующего выражения:

\begin{Verbatim}[fontsize=\small]
(car (cdr (filter prime?
                    (enumerate-interval 10000 1000000))))
\end{Verbatim}

Это выражение находит второе простое число, однако на это затрачивается
возмутительное количество вычислительных ресурсов.  Мы строим список из
почти миллиона целых чисел, фильтруем этот список, проверяя каждый
его элемент на простоту, а затем почти весь результат игнорируем.  При
более традиционном программистском подходе мы бы чередовали
перечисление и фильтрацию, и остановились бы по достижении второго
простого числа.

Потоки представляют собой прием, который дает возможность
работать с последовательностями и при этом ничего не терять на
представлении последовательностей в виде списков.  Потоки
сочетают лучшее из обоих подходов: мы можем изящно формулировать
программы в терминах операций с последовательностями и при этом
сохранять эффективность пошагового вычисления.  Основная идея состоит
в том, чтобы строить список только частично и передавать частично
построенный список программе, потребляющей поток.  Если потребитель
запросит доступ к той части потока, которая еще не сконструирована,
поток автоматически достроит ровно такую часть себя самого, какая
нужна, и сохранит таким образом иллюзию, что он существует
целиком.  Другими словами, хотя программы будут писаться так, как
будто обрабатываются полные последовательности, мы так спроектируем
реализацию потоков, что построение потока будет автоматически и
незаметно для пользователя чередоваться с его использованием.

На первый взгляд, потоки --- это просто списки, у которых
процедуры работы с ними переименованы.  Имеется конструктор,
{\tt cons-stream},\index{ru}{cons-stream (особая форма)||||p|}
и два селектора,  \index{ru}{stream-car||||p|}{\tt stream-car} и  \index{ru}{stream-cdr||||p|}
{\tt stream-cdr}, причем выполняются уравнения

\begin{Verbatim}[fontsize=\small]
(stream-car (cons-stream x y)) = x

(stream-cdr (cons-stream x y)) = y
\end{Verbatim}

Имеется специальный объект,
\index{ru}{пустой поток||empty stream|||}\index{en}{empty stream||пустой поток|||}%
\index{ru}{поток(и)|пустые||||}%
\index{ru}{the-empty-stream||||p|}%
{\tt the-empty-stream}, который не
может быть результатом никакой операции {\tt cons-stream}, и
который можно распознать процедурой \index{ru}{stream-null?||||p|}
{\tt stream-null?}\footnote{\index{ru}{MIT Scheme|пустой
    поток||||п}\index{ru}{stream-null?|в MIT Scheme|||p|п}
  \index{ru}{the-empty-stream|в MIT Scheme|||p|п}В реализации MIT
  {\tt the-empty-stream}
совпадает с пустым списком {\tt '()}, а  процедура
{\tt stream-null?} совпадает с {\tt null?}.}.
Таким образом, можно создавать и использовать потоки, точно так же, как списки,
для представления составных данных, организованных в виде
последовательности.  В частности, можно построить потоковые аналоги
операций со списками из
главы~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}, таких, как
{\tt list-ref}, {\tt map} и
{\tt for-each}\footnote{Здесь у Вас должно возникнуть беспокойство.  То, что мы
определяем столь сходные процедуры для потоков и списков, показывает,
что мы упускаем некую глубинную абстракцию.  К сожалению, чтобы
использовать эту абстракцию, нам нужно более точное управление
процессом вычисления, чем у нас сейчас есть.  Мы подробнее обсудим
этот вопрос в конце
раздела~\ref{STREAMS-AND-DELAYED-EVALUATION}.  В
разделе~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION} мы
разработаем среду, в которой списки и потоки объединяются.}:

\begin{Verbatim}[fontsize=\small]
(define (stream-ref s n) \index{ru}{stream-ref||||pd|}
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s) \index{ru}{stream-map||||pd|}
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s) \index{ru}{stream-for-each||||pd|}
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
\end{Verbatim}

С помощью {\tt stream-for-each} потоки можно печатать:

\begin{Verbatim}[fontsize=\small]
(define (display-stream s)\index{ru}{display-stream||||pd|}
  (stream-for-each display-line s))

(define (display-line x)\index{ru}{display-line||||pd|}
  (newline)
  (display x))
\end{Verbatim}


Чтобы заставить реализацию потоков автоматически и
незаметно чередовать построение потока с его использованием, мы
сделаем так, чтобы {\tt cdr} потока вычислялся тогда, когда к
нему обращается процедура {\tt stream-cdr}, а не тогда, когда
поток создается процедурой {\tt cons-stream}.  Такое проектное
решение заставляет вспомнить обсуждение рациональных чисел в
разделе~\ref{ABSTRACTION-BARRIERS}, где мы увидели, что можно
приводить рациональные числа к наименьшему знаменателю
либо во время создания числа, либо во время обращения к нему.  Две
реализации рациональных чисел предоставляют одну и ту же абстракцию,
однако наш выбор влияет на эффективность работы.  Существует подобная
связь и между потоками и обычными списками.  В качестве абстракции
данных потоки не отличаются от списков.  Разница состоит в том, когда
вычисляются их элементы.  В обычных списках и {\tt car}, и
{\tt cdr} вычисляются во время построения.  У потоков
{\tt cdr} вычисляется при обращении.

Наша реализация потоков основана на особой форме под
названием {\tt delay}.  Выполнение
\index{ru}{delay (особая форма)||||pd|}\index{ru}{особые
  формы|\texttt{delay} {\em (нс)}||||}{\tt (delay
  \textit{$\langle$выражение$\rangle$})} не вычисляет
\textit{$\langle$выражение$\rangle$}, а вместо этого возвращает так называемый
\index{ru}{задержанный объект||delayed object|||}\index{en}{delayed object||задержанный объект|||}{\em задержанный объект} (delayed object).  Мы можем
считать, что это <<обещание>> вычислить {\tt выражение}
когда-нибудь в будущем.  В качестве пары к {\tt delay} имеется
процедура {\tt force},
\index{ru}{force||||p|}
которая берет задержанный объект в
качестве аргумента и вычисляет его --- фактически, заставляя
{\tt delay} выполнить обещание.  Ниже мы увидим, как можно
реализовать {\tt delay} и {\tt force}, но сначала
давайте посмотрим, как с их помощью строить потоки.

{\tt Cons-stream} \index{ru}{особые формы|\texttt{cons-stream} {\em (нс)}||||} --- это особая форма, такая, что
\index{ru}{cons-stream (особая форма)||||pd|}

\begin{Verbatim}[fontsize=\small]
(cons-stream \textit{$\langle$a$\rangle$} \textit{$\langle$b$\rangle$})
\end{Verbatim}
эквивалентно
\begin{Verbatim}[fontsize=\small]
(cons \textit{$\langle$a$\rangle$} (delay \textit{$\langle$b$\rangle$}))
\end{Verbatim}

Это означает, что мы строим потоки при помощи пар.  Однако
вместо того, чтобы поместить значение остатка потока в {\tt cdr}
пары, мы кладем туда обещание вычислить остаток, если нас об этом
попросят.  Теперь можно определить {\tt stream-car} и
{\tt stream-cdr} как процедуры:

\begin{Verbatim}[fontsize=\small]
(define (stream-car stream) (car stream))  \index{ru}{stream-car||||pd|}

(define (stream-cdr stream) (force (cdr stream))) \index{ru}{stream-cdr||||pd|}
\end{Verbatim}

{\tt Streams-car} возвращает {\tt car}
пары. {\tt Stream-cdr} берет {\tt cdr} пары и вычисляет
хранящееся там задержанное выражение, чтобы получить остаток
потока\footnote{В отличие от {\tt stream-car} и
{\tt stream-cdr}, которые можно определить в виде процедур,
{\tt cons-stream} обязан быть особой формой.
\index{ru}{cons-stream (особая форма)|почему особая форма|||p|п}
Если бы он был
процедурой, то, согласно нашей модели вычислений, выполнение
{\tt (cons-stream \textit{$\langle$a$\rangle$} \textit{$\langle$b$\rangle$})}
автоматически приводило бы к вычислению \textit{$\langle$b$\rangle$}, а именно
этого мы и не хотим.  По этой же причине {\tt delay} должен
\index{ru}{delay (особая форма)|почему особая форма|||p|п}
быть особой формой, хотя {\tt force} может оставаться обычной
процедурой.
}.

\paragraph{Реализация потоков в действии}


Чтобы посмотреть, как ведет себя эта реализация, давайте
проанализируем <<возмутительное>> вычисление с простыми числами,
переформулированное через потоки:

\begin{Verbatim}[fontsize=\small]
(stream-car
  (stream-cdr
   (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
\end{Verbatim}

Мы увидим, что теперь вычисления происходят эффективно.

Вначале зовется процедура {\tt stream-enumerate-interval} с
аргументами 1000 и 1000000. {\tt Stream-enumerate-interval} ---
это потоковый аналог процедуры {\tt enumerate\-interval} %HERE279
(раздел~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}):

\begin{Verbatim}[fontsize=\small]
(define (stream-enumerate-interval low high) \index{ru}{stream-enumerate-interval||||pd|}
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
\end{Verbatim}
и, таким образом, результат, возвращаемый
{\tt stream-enumerate-in\-ter\-val}, \linebreak
сфор\-ми\-ро\-ванный {\tt cons-stream} внутри нее, равен\footnote{Показанные здесь числа на самом деле не появляются в
возвращаемом выражении.  Возвращается исходное выражение вместе с
окружением, в котором переменным присвоены соответствующие значения.
Например, там, где напечатано число 10001, стоит {\tt (+ low
1)}, и переменная {\tt low} связана со значением
10000.
}

\begin{Verbatim}[fontsize=\small]
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
\end{Verbatim}

А именно, {\tt stream-enumerate-interval} возвращает поток,
представленный в виде пары, {\tt car} которой равен 10000,
а {\tt cdr} является обещанием вычислить остаток интервала,
когда попросят.  Теперь этот поток отфильтровывается на предмет поиска
простых чисел с помощью потокового аналога процедуры
{\tt filter} (раздел~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}):

\begin{Verbatim}[fontsize=\small]
(define (stream-filter pred stream) \index{ru}{stream-filter||||pd|}
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
\end{Verbatim}

{\tt Stream-filter} проверяет {\tt stream-car} потока
(то есть {\tt car} пары, то есть 10000).  Поскольку это не
простое число, {\tt stream-filter} смотрит на
{\tt stream\-cdr} своего входного потока.  Вызов %HERE278
{\tt stream-cdr} приводит к вычислению задержанного вызова
{\tt stream-enumerate-interval}, возвращающего

\begin{Verbatim}[fontsize=\small]
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
\end{Verbatim}

Теперь {\tt stream-filter} смотрит на {\tt stream-car} этого
потока, 10001, видит, что и это не простое число, снова зовет
{\tt stream-cdr} и так далее, пока
{\tt stream-enumerate-interval} не выдаст простое число 10007.
Тогда {\tt stream\-filter}, в соответствии со своим
определением, вернет

\begin{Verbatim}[fontsize=\small]
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
\end{Verbatim}
что в данном случае равняется
\begin{Verbatim}[fontsize=\small]
(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
\end{Verbatim}

Теперь этот результат передается в {\tt stream-cdr} из нашего
исходного выражения.  При этом вызывается задержанный
{\tt stream-filter}, который, в свою очередь, вынуждает
задержанные вызовы {\tt stream-enumerate-interval}, пока не
доберется до следующего простого числа, а именно 10009.  Наконец,
результат, передаваемый в {\tt stream-car} нашего исходного
выражения, равен

\begin{Verbatim}[fontsize=\small]
(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 10011
                                            1000000))))))
\end{Verbatim}

{\tt Stream-car} возвращает 10009, и вычисление закончено.  На
простоту было проверено ровно столько чисел, сколько было необходимо,
чтобы найти второе простое число на интервале, и сам интервал был
перебран только до того места, которое было нужно фильтру простых
чисел.

В общем, мы можем считать задержанные вычисления
\index{ru}{программирование|управляемое потребностями||||} программированием, <<управляемым потребностями>>, в
котором каждый шаг
вычислений в потоковом процессе активизируется лишь настолько,
насколько это нужно для следующего шага.  Таким образом, нам удалось
отделить реальный \index{ru}{порядок событий|отделение от внешней структуры процедур||||} порядок событий
при вычислении от внешней структуры
процедур.  Мы пишем процедуры так, как будто потоки существуют <<все
целиком>>, а на самом деле вычисление происходит пошагово, как и при
программировании в традиционном стиле.

\paragraph{Реализация {\tt delay} и {\tt force}}


{\tt Delay} и {\tt force}
могут казаться таинственными операциями, но на самом деле их реализация
весьма проста. {\tt Delay} должно упаковать выражение так,
чтобы потом его можно было выполнить по требованию, и мы добиваемся
этого, просто рассматривая выражение как тело процедуры. Можно сделать
{\tt delay} особой формой, такой, чтобы

\begin{Verbatim}[fontsize=\small]
(delay \textit{$\langle$выражение$\rangle$})
\end{Verbatim}

\index{ru}{delay (особая форма)|реализация с помощью \texttt{lambda}|||p|}
было синтаксическим сахаром для

\begin{Verbatim}[fontsize=\small]
(lambda () \textit{$\langle$выражение$\rangle$})
\end{Verbatim}

{\tt Force} просто вызывает (безаргументную) процедуру,
порожденную {\tt delay}, так что она может быть реализована как
процедура

\begin{Verbatim}[fontsize=\small]
(define (force delayed-object)\index{ru}{force||||pd|}
  (delayed-object))
\end{Verbatim}


При такой реализации \index{ru}{мемоизация|через \texttt{delay}||||}{\tt delay} и
{\tt force} работают согласно описанию, однако к ней можно
добавить важную оптимизацию.  Во многих приложениях мы вынуждаем
один и тот же задержанный объект по многу раз.  В рекурсивных
программах с использованием потоков это может привести к существенной
неэффективности (см.~упражнение~\ref{EX3.57}).  Решение
состоит в том, чтобы строить задержанные объекты так, чтобы при первом
вынуждении они сохраняли вычисленное значение.  Последующие
обращения будут просто возвращать сохраненное значение без повторения
вычислений.  Другими словами, мы реализуем {\tt delay} как
особого рода мемоизированную процедуру, подобную описанным в
упражнении~\ref{EX3.27}.  Один из способов этого добиться
--- использовать следующую процедуру, которая принимает процедуру (без
аргументов) и возвращает ее мемоизированную версию.
При первом вызове мемоизированная процедура сохраняет результат.  При
последующих вызовах она просто его возвращает.

\begin{Verbatim}[fontsize=\small]
(define (memo-proc proc)\index{ru}{memo-proc||||pd|}
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
\end{Verbatim}
Теперь можно определить {\tt delay} таким образом, что
\index{ru}{delay (особая форма)|мемоизированная|||p|}
{\tt (delay \textit{$\langle$выражение$\rangle$})} равносильно

\begin{Verbatim}[fontsize=\small]
(memo-proc (lambda () \textit{$\langle$выражение$\rangle$}))
\end{Verbatim}
а определение {\tt force} не меняется\footnote{Есть много возможных реализаций потоков помимо
описанной в этом разделе.  Задержанное вычисление, ключевой элемент,
который делает потоки практически полезными, было частью метода
передачи параметров
\index{ru}{Algol (Алгол)|передача аргументов по имени||call by name||п}%
\index{en}{|call by name|Algol (Алгол)|передача аргументов по имени||п}%
{\em по имени} (by name) в языке
Алгол-60.  Использование этого механизма для реализации потоков
впервые было описано Ландином (Landin 1965).
\index{ru}{Ландин, Питер||Peter Landin||n|п}\index{en}{Peter Landin||Ландин, Питер||n|п}%
Задержанное вычисление для потоков ввели в Лисп Фридман и Уайз
(Friedman and Wise 1976).
\index{ru}{Фридман, Дэниел~П.||Daniel~P. Friedman||n|п}%
\index{en}{Daniel~P. Friedman||Фридман, Дэниел~П.||n|п}%
\index{ru}{Уайз, Дэвид~С.||David~S. Wise||n|п}\index{en}{David~S. Wise||Уайз, Дэвид~С.||n|п}%
В их реализации
{\tt cons} всегда задерживает вычисление своих аргументов, так
что списки автоматически ведут себя как потоки.  Мемоизирующая
оптимизация известна также как
\index{ru}{вызов по необходимости||call by need|||п}\index{en}{call by need||вызов по необходимости|||п}{\em вызов по необходимости} (by need).  В
сообществе программистов на Алголе задержанные объекты из нашей первой
реализации назывались бы
\index{ru}{Algol (Алгол)|санки||||п}%
\index{ru}{санк|вызова по имени||||п}%
\index{ru}{санк|вызова по необходимости||||п}%
\index{ru}{санк|вызова по имени|call-by-name thunks|call-by-name||п}%
\index{en}{call-by-name thunks|call-by-name|санк|вызова по имени||п}{\em санками
вызова по имени} (call-by-name thunks), а оптимизированный вариант
\index{ru}{санк|вызова по необходимости|call-by-need thunks|call-by-need||п}\index{en}{call-by-need thunks|call-by-need|санк|вызова по необходимости||п}{\em санками вызова по
необходимости} (call-by-need thunks).
}.
\begin{exercise}{3.50}\label{EX3.50}%
Закончите следующее определение, которое обобщает
процедуру {\tt stream-map}, чтобы она позволяла использовать
процедуры от нескольких аргументов, подобно {\tt map} из
раздела~\ref{REPRESENTING-SEQUENCES}, сноска
\ref{F2.12}.

\begin{Verbatim}[fontsize=\small]
(define (stream-map proc . argstreams)\index{ru}{stream-map|с несколькими аргументами|||pd|(упр.~3.50)}
  (if (\textit{$\langle$??$\rangle$} (car argstreams))
      the-empty-stream
      (\textit{$\langle$??$\rangle$}
       (apply proc (map \textit{$\langle$??$\rangle$} argstreams))
       (apply stream-map
              (cons proc (map \textit{$\langle$??$\rangle$} argstreams))))))
\end{Verbatim}

\end{exercise}
\begin{exercise}{3.51}\label{EX3.51}%
Чтобы внимательнее изучить задержанные вычисления, мы
воспользуемся следующей процедурой, которая \index{ru}{задержанные вычисления|и печать||||(упр.~3.51)}печатает свой аргумент, а
затем возвращает его:

\begin{Verbatim}[fontsize=\small]
(define (show x)
  (display-line x)
  x)
\end{Verbatim}
Что печатает интерпретатор в ответ на каждое выражение из следующей
последовательности\footnote{Упражнения типа \ref{EX3.51} и
\ref{EX3.52} помогают понять, как работает
{\tt delay}.  С другой стороны, смешение задержанного
вычисления с печатью --- или, хуже того, с присваиванием, ---
ужасно запутывает, и преподаватели, читающие курсы по языкам
программирования, часто пытают студентов экзаменационными вопросами
вроде упражнений из этого раздела.  Незачем и говорить, что
\index{ru}{программирование|чрезвычайно плохой стиль||||п}писать
программы, зависящие от таких тонкостей, --- показатель чрезвычайно
плохого стиля.
Отчасти мощность потокового программирования в том и заключается, что
можно игнорировать порядок, в котором на самом деле происходят события
в программах.  К сожалению, ровно этого мы и не можем себе позволить в
присутствии присваивания, заставляющего нас думать о времени и
изменении.}?

\begin{Verbatim}[fontsize=\small]
(define x (stream-map show (stream-enumerate-interval 0 10)))

(stream-ref x 5)

(stream-ref x 7)
\end{Verbatim}

\end{exercise}
\begin{exercise}{3.52}\label{EX3.52}%
Рассмотрим последовательность выражений
\index{ru}{задержанные вычисления|и присваивание||||(упр.~3.52)}

\begin{Verbatim}[fontsize=\small]
(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))

(stream-ref y 7)

(display-stream z)
\end{Verbatim}
Каково значение {\tt sum} после вычисления каждого из этих
выражений?  Что печатается при вычислении выражений
{\tt stream-ref} и {\tt display-stream}?  Изменился бы
этот результат, если бы мы реализовали
{\tt (delay \textit{$\langle$выражение$\rangle$})} просто как
{\tt (lambda () \textit{$\langle$выражение$\rangle$})}, не применяя
оптимизацию через {\tt memo-proc}? Объясните свой ответ.
\end{exercise}

\subsection{Бесконечные потоки}
\label{INFINITE-STREAMS}


\index{ru}{бесконечные потоки||infinite         streams|||}\index{en}{infinite         streams||бесконечные потоки|||}
Мы видели, как можно поддерживать иллюзию работы с
потоками как с цельными объектами, хотя на самом деле мы вычисляем
только ту часть потока, к которой нам требуется доступ.  Этот метод
можно использовать, чтобы эффективно представлять последовательности в
виде потоков, даже если эти последовательности весьма длинны.  Еще
удивительнее то, что при помощи потоков можно представлять последовательности
бесконечной длины.  Рассмотрим, например, следующее
определение потока положительных целых чисел:

\begin{Verbatim}[fontsize=\small]
(define (integers-starting-from n)\index{ru}{integers-starting-from||||pd|}
  (cons-stream n (integers-starting-from (+ n 1))))

(define integers (integers-starting-from 1))\index{ru}{integers (бесконечный поток)||||pd|}
\end{Verbatim}

Такая запись имеет смысл, потому что описывает
{\tt integers} как пару, у которой {\tt car} равен 1, а
{\tt cdr} является обещанием породить целые числа, начиная с 2.
Такой поток бесконечен, но в любой данный момент мы можем работать
только с конечной его частью.  Таким образом, наши программы никогда
не узнают, что целиком бесконечного потока не существует.

При помощи {\tt integers} можно определять другие
бесконечные потоки, например, поток чисел, не делящихся на 7:

\begin{Verbatim}[fontsize=\small]
(define (divisible? x y) (= (remainder x y) 0))\index{ru}{divisible?||||pd|}

(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
\end{Verbatim}

Теперь мы можем искать числа, не делящиеся на 7, просто обращаясь к
элементам этого потока:

\begin{Verbatim}[fontsize=\small]
(stream-ref no-sevens 100)
\end{Verbatim}


По аналогии с {\tt integers}, можно определить
бесконечный поток чисел Фибоначчи:

\begin{Verbatim}[fontsize=\small]
(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))

(define fibs (fibgen 0 1))\index{ru}{fibs (бесконечный поток)||||pd|}
\end{Verbatim}

{\tt Fibs} представляет собой пару, {\tt car} которой
равен 0, а {\tt cdr} является обещанием вычислить {\tt (fibgen
1 1)}.  Когда мы выполняем это задержанное {\tt (fibgen 1
1)}, оно порождает пару, где {\tt car} равен 1, а в
{\tt cdr} лежит обещание вычислить {\tt (fibgen 1 2)}, и
так далее.

Чтобы продемонстрировать пример более интересного потока,
можно обобщить {\tt no-sevens} и построить бесконечный поток
 \index{ru}{простые числа|решето Эратосфена||||}
простых чисел, используя метод, известный как
\index{ru}{решето Эратосфена||sieve of Eratosthenes|||}\index{en}{sieve of Eratosthenes||решето Эратосфена|||}{\em решето Эратосфена} (sieve of Eratosthenes)\footnote{Эратосфен,
\index{ru}{Эратосфен||||n|п}
греческий философ третьего века до н.~э. из
Александрии, знаменит тем, что он дал первую верную
\index{ru}{Земля, измерение длины окружности||measuring circumference of Earth|||п}\index{en}{measuring circumference of Earth||Земля, измерение длины окружности|||п}оценку длины окружности
Земли, которую он вычислил, наблюдая тени, отбрасываемые в полдень
летнего солнцестояния.  Метод решета Эратосфена, несмотря на свою
древность, лежал в основе специальных аппаратных устройств-<<решет>>,
которые до недавних пор были самыми мощными устройствами для
поиска простых чисел. Однако начиная с 70-х годов такие устройства были
вытеснены развитием \index{ru}{вероятностный алгоритм|||||п}вероятностных методик, обсуждаемых в
разделе~\ref{EXAMPLE-TESTING-FOR-PRIMALITY}.
}.
Сначала мы строим поток чисел, начиная с 2, первого простого числа.
Для того, чтобы найти остальные простые числа, мы фильтруем кратные
двойки из потока остальных чисел.  Получается поток, который
начинается с 3, следующего простого числа.  Теперь из остатка потока
мы фильтруем числа, кратные 3.  Получается поток, начинающийся с 5,
следующего простого, и так далее.  Другими словами, мы строим простые
числа с помощью просеивающего процесса, описываемого так: чтобы
просеять поток $S$, нужно сформировать поток, в котором
первый элемент совпадает с первым элементом $S$, а остаток
получается фильтрацией множителей первого элемента из оставшейся части
$S$ и просеивания того, что получится.  Такой процесс
нетрудно описать в терминах операций над потоками:

\begin{Verbatim}[fontsize=\small]
(define (sieve stream) \index{ru}{решето Эратосфена|\texttt{sieve}||||}
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))

(define primes (sieve (integers-starting-from 2))) \index{ru}{primes (бесконечный поток)||||pd|}
\end{Verbatim}
Теперь, чтобы найти определенное простое число, надо только попросить:

\begin{Verbatim}[fontsize=\small]
(stream-ref primes 50)
\textit{233}
\end{Verbatim}


\begin{cntrfig}
\input{xfig-mod/3-31.eepic}

\caption{Решето для поиска простых чисел в виде
системы обработки сигналов.}
\label{P3.31}

\end{cntrfig}

Интересно представить себе систему обработки сигналов,
соответствующую {\tt sieve}, показанную на
\index{ru}{Хендерсон, Питер|хендерсоновская диаграмма|Peter Henderson|||}\index{en}{Peter Henderson||Хендерсон, Питер|хендерсоновская диаграмма||}
<<хендерсоновской
диаграмме>> на рисунке~\ref{P3.31}\footnote{Мы назвали этот способ изображения потоков в честь
Питера Хендерсона, который первым показал нам диаграммы такого вида
\index{ru}{Хендерсон, Питер||Peter Henderson||n|п}\index{en}{Peter Henderson||Хендерсон, Питер||n|п}
как способ рассуждений об обработке потоков.  Сплошные линии
представляют потоки передаваемых сигналов.  Прерывистая линия от
{\tt car} к {\tt cons} и {\tt filter} указывает,
что здесь передается не поток, а  единичное значение.}.
Входной поток попадает в <<рас{\tt cons}ер>>, который отделяет первый
элемент потока от его хвоста.  При помощи первого элемента строится
фильтр на делимость, и через него пропускается остаток входного
потока, а выход запускается в еще один элемент {\tt sieve}.
Затем исходный первый элемент сочетается при помощи {\tt cons}
с выходом внутреннего {\tt sieve}, и получается выходной
поток.  Таким образом, не только входной поток бесконечен, но и
обработчик сигналов также бесконечен, поскольку одно решето содержит в
себе другое.

\paragraph{Неявное определение потоков}

\index{ru}{поток(и)|неявное определение||||}
Потоки {\tt integers} и {\tt fibs} были
определены при помощи <<порождающих>> процедур, которые явным образом
вычисляют элементы потока один за другим.  Однако можно определять
потоки неявно, пользуясь задержанным вычислением.  Например, следующее
выражение определяет {\tt ones} как бесконечный поток,
состоящий из одних единиц:

\begin{Verbatim}[fontsize=\small]
(define ones (cons-stream 1 ones))
\end{Verbatim}
Это выражение работает примерно так же, как рекурсивная процедура:
{\tt ones} является парой, чей {\tt car} есть 1, а
{\tt cdr} представляет собой обещание вычислить
{\tt ones}. Обращение к {\tt cdr} дает нам снова 1 и
обещание вычислить {\tt ones}, и так далее.

Можно делать и более интересные вещи с помощью операций
вроде {\tt add\-streams}, которая порождает поэлементную сумму
двух данных потоков\footnote{Здесь используется обобщенная версия
{\tt stream-map} из упражнения~\ref{EX3.50}.
}:

\begin{Verbatim}[fontsize=\small]
(define (add-streams s1 s2)\index{ru}{add-streams||||pd|}
  (stream-map + s1 s2))
\end{Verbatim}
Теперь можно определить поток целых чисел следующим образом:

\begin{Verbatim}[fontsize=\small]
(define integers (cons-stream 1 (add-streams ones integers)))\index{ru}{integers (бесконечный поток)|неявное определение|||pd|}
\end{Verbatim}
Здесь {\tt integers} определяются как поток, в котором первый
элемент 1, а остаток равен сумме {\tt ones} и
{\tt integers}. Таким образом, второй элемент
{\tt integers} равен 1 плюс первый элемент
{\tt integers}, то есть 2; третий элемент равен 1 плюс второй
элемент {\tt integers}, то есть 3, и так далее.  Это
определение работает потому, что в любой момент сгенерировано
достаточно элементов потока {\tt integers}, чтобы мы могли
обратиться к ним в определении и породить следующий элемент.

В том же стиле можно определить числа Фибоначчи:

\begin{Verbatim}[fontsize=\small]
(define fibs\index{ru}{fibs (бесконечный поток)|неявное определение|||pd|}
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs)
                                         fibs))))
\end{Verbatim}
Это определение говорит, что {\tt fibs} есть поток, начинающийся
с 0 и 1, такой, что остаток потока порождается сложением
{\tt fibs} с собой самим, сдвинутым на одну позицию:

\medskip

\begin{tabular}{rrrrrrrrrrl}
   &   & 1 & 1 & 2 & 3 & 5 &  8 & 13 & 21 & \texttt{... = (stream-cdr fibs)}\\
   &   & 0 & 1 & 1 & 2 & 3 &  5 &  8 & 13 & \texttt{... = fibs}\\
\hline\\
 0 & 1 & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & \texttt{... = fibs}\\
\end{tabular}
\medskip%HERE286, between the table and the text

Еще одна полезная процедура для подобных определений
потоков --- {\tt scale-stream}.  Она умножает каждый элемент
потока на данную константу:
{\sloppy

}
\begin{Verbatim}[fontsize=\small]
(define (scale-stream stream factor) \index{ru}{scale-stream||||pd|}
  (stream-map (lambda (x) (* x factor)) stream))
\end{Verbatim}
Например,

\begin{Verbatim}[fontsize=\small]
(define double (cons-stream 1 (scale-stream double 2)))
\end{Verbatim}
порождает поток степеней двойки: 1, 2, 4, 8, 16, 32 \ldots

Можно дать альтернативное определение потока простых
чисел, начав с потока целых чисел, и фильтруя его через проверку на
простоту.  Вначале нам потребуется первое простое число, 2:

\begin{Verbatim}[fontsize=\small]
(define primes \index{ru}{primes (бесконечный поток)|неявное определение|||pd|}
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
\end{Verbatim}

Это определение не столь тривиально, как кажется, поскольку мы будем
проверять число $n$ на простоту, проверяя, делится ли
$n$ на простые числа (а не на все целые), меньшие или
равные $\sqrt{n}$:

\begin{Verbatim}[fontsize=\small]
(define (prime? n) \index{ru}{prime||||pd|}
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
\end{Verbatim}
Это рекурсивное определение, поскольку {\tt primes}
определяются посредством предиката {\tt prime?}, а он сам
использует поток {\tt primes}.  Работает эта процедура
потому, что в любой момент имеется
достаточно элементов потока {\tt primes} для проверки на
простоту следующего требуемого числа.  А именно, при
проверке {\tt n} либо оказывается не простым (а в
таком случае имеется уже сгенерированное простое число, на которое
оно делится), либо оно простое (а в таком случае, имеется
уже сгенерированное простое число --- то есть, простое число меньше
$n$, --- большее $\sqrt{n}$\footnote{Это тонкая деталь, которая основана на том, что
$p_{n+1} \le p_{n}^2$ (Здесь $p_k$ обозначает
$k$-е простое число.)  Такие оценки достаточно трудно
доказать.  Античное доказательство Евклида показывает, что
имеется бесконечное количество простых чисел, и что
$p_{n+1} \le p_1 p_2 \cdots p_n + 1$. Никакого
существенно лучшего результата не было найдено до 1851 года, когда
русский математик
П.~Л.~Чебышев\index{ru}{Чебышев, Пафнутий Львович||||n|п}
доказал, что для всех $n$,
$p_{n+1} \le 2p_n$.  Предположение, что это так, было
высказано в 1845 году и известно как \index{ru}{Бертрана гипотеза||Bertrand's hypothesis|||п}\index{en}{Bertrand's hypothesis||Бертрана гипотеза|||п}{\em гипотеза Бертрана} (Bertrand's hypothesis).
Доказательство можно найти в разделе~22.3 в книге
Hardy and Wright 1960.
\index{ru}{Харди, Годфри Харольд||Godfrey Harold Hardy||n|п}\index{en}{Godfrey Harold Hardy||Харди, Годфри Харольд||n|п}
\index{ru}{Райт,~Э.~М.||E.~M.~Wright||n|п}\index{en}{E.~M.~Wright||Райт,~Э.~М.||n|п}
}.
\begin{exercise}{3.53}\label{EX3.53}%
Не запуская программу, опишите элементы потока,
порождаемого

\begin{Verbatim}[fontsize=\small]
(define s (cons-stream 1 (add-streams s s)))
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.54}\label{EX3.54}%
Определите процедуру {\tt mul-streams},
\index{ru}{mul-streams||||p|(упр.~3.54)}
аналогичную {\tt add-streams}, которая порождает поэлементное
произведение двух входных потоков. \index{ru}{бесконечный поток|факториалов||||(упр.~3.54)} \index{ru}{факториал|бесконечный поток||||(упр.~3.54)}С помощью нее и потока
{\tt integers} закончите следующее определение потока,
$n$-й элемент которого (начиная с 0) равен факториалу
$n+1$:

\begin{Verbatim}[fontsize=\small]
(define factorials (cons-stream 1 (mul-streams \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$})))
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.55}\label{EX3.55}%
Определите процедуру {\tt partial-sums},
\index{ru}{partial-sums||||p|(упр.~3.55)}
которая
в качестве аргумента берет поток $S$, а возвращает поток,
элементы которого равны $S_0, S_0 + S_1, S_0 + S_1 + S_2,
\ldots$.  Например, {\tt (partial-sums integers)} должно
давать поток 1, 3, 6, 10, 15 \ldots
\end{exercise}
\begin{exercise}{3.56}\label{EX3.56}%
Существует знаменитая задача, впервые
сформулированная Р.~Хэммингом: породить в
\index{ru}{Хэмминг, Ричард Уэсли||Richard Wesley Hamming||n|(упр.~3.56)}\index{en}{Richard Wesley Hamming||Хэмминг, Ричард Уэсли||n|(упр.~3.56)}
возрастающем порядке и без повторений все положительные целые числа, у
которых нет других простых делителей, кроме 2, 3 и 5. Очевидное
решение состоит в том, чтобы перебирать все натуральные числа по
очереди и проверять, есть ли у них простые множители помимо 2, 3 и
5. Однако эта процедура весьма неэффективна, поскольку чем больше
числа, тем меньшая их доля соответствует условию.  Применим
альтернативный подход: назовем искомый поток чисел  {\tt S} и обратим
внимание на следующие факты:

\begin{plainlist}


\item
{\tt S} начинается с 1.

\item
Элементы {\tt (scale-stream S 2)} также
принадлежат {\tt S}

\item
То же верно и для {\tt (scale-stream S 3)}
и {\tt (scale-stream S 5)}.

\item
Других элементов {\tt S} нет.
\end{plainlist}
Теперь требуется только \index{ru}{бесконечный поток|слияние||||(упр.~3.56)} соединить элементы из этих источников.  Для
этого мы определяем процедуру {\tt merge}, которая сливает два
упорядоченных потока в один упорядоченный поток, убирая при этом
повторения:

\begin{Verbatim}[fontsize=\small]
(define (merge s1 s2)\index{ru}{merge||||pd|(упр.~3.56)}
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))
\end{Verbatim}
Тогда требуемый поток можно получить с помощью {\tt merge}
таким образом:

\begin{Verbatim}[fontsize=\small]
(define S (cons-stream 1 (merge \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$})))
\end{Verbatim}
Заполните пропуски в местах, обозначенных знаком \textit{$\langle$??$\rangle$}.
\end{exercise}
\begin{exercise}{3.57}\label{EX3.57}%
Сколько сложений происходит при вычислении
$n$-го числа Фибоначчи, в случае, когда мы используем
определение $fibs$ через процедуру
{\tt add-streams}?  Покажите, что число сложений выросло бы
экспоненциально, если бы мы реализовали
{\tt (delay \textit{$\langle$выраже\-ние$\rangle$})} просто как
\index{ru}{delay (особая форма)|мемоизированная|||p|(упр.~3.57)}
{\tt (lambda () \textit{$\langle$выражение$\rangle$})}, без оптимизации через
процедуру {\tt memo-proc} из
раздела~\ref{STREAMS-ARE-DELAYED-LISTS}\footnote{Это упражнение показывает, как близко связан
\index{ru}{вызов по необходимости|связь с     мемоизацией||||п} \index{ru}{мемоизация|и          вызов по необходимости||||п} вызов
по  необходимости с обычной мемоизацией,
описанной в упражнении~\ref{EX3.27}.  В этом упражнении мы при
помощи присваивания явным образом создавали локальную таблицу.  Наша
оптимизация с вызовом по необходимости, в сущности, автоматически
создает такую же таблицу, сохраняя значения в уже размороженных частях
потока.
}.
\end{exercise}
\begin{exercise}{3.58}\label{EX3.58}%
Дайте интерпретацию потоку, порождаемому следующей
процедурой:

\begin{Verbatim}[fontsize=\small]
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
\end{Verbatim}
(Элементарная процедура \index{ru}{элементарные процедуры|{\tt quotient}||||(упр.~3.58)} \index{ru}{quotient (элементарная процедура)||||p|(упр.~3.58)} {\tt quotient} возвращает целую часть
частного двух целых чисел.)  Каковы последовательные элементы потока,
порожденного выражением {\tt (expand 1 7 10)}?  Что дает
вычисление {\tt (expand 3 8 10)}?
\end{exercise}
\begin{exercise}{3.59}\label{EX3.59}%
В разделе~\ref{EXAMPLE-SYMBOLIC-ALGEBRA} мы
увидели, как реализовать систему арифметики многочленов, используя
представление многочленов в виде списка термов.  Подобным же образом
можно работать со
\index{ru}{бесконечный поток|представление степенных рядов||||(упр.~3.59)} \index{ru}{степенной ряд, представленный как поток||power series, as a stream|||(упр.~3.59)}\index{en}{power series, as a stream||степенной ряд, представленный как поток|||(упр.~3.59)}{\em  степенными рядами} (power series),
например
\index{ru}{косинус|степенной ряд||||(упр.~3.59)}%
\index{ru}{$e^x$, степенной ряд|||||(упр.~3.59)}%
\index{ru}{синус|степенной ряд||||(упр.~3.59)}%
$$
\begin{array}{l}
e^x = 1 + x + \dfrac{x^2}{2} + \dfrac{x^3}{3 \cdot 2} + \dfrac{x^4}{4 \cdot 3 \cdot 2} + \cdots,\\[10 pt]
\cos x = 1 - \dfrac{x^2}{2} + \dfrac{x^4}{4 \cdot 3 \cdot 2} - \cdots,\\ [10pt]
\sin x = x - \dfrac{x^3}{3 \cdot 2} + \dfrac{x^5}{5 \cdot 4 \cdot 3 \cdot 2} - \cdots,\\
\end{array}
$$
представленными в виде бесконечных потоков.  Будем представлять
последовательность $a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots$
как поток, элементами которого являются коэффициенты
$a_0, a_1, a_2, a_3 \ldots$

\begin{plainenum}

\item
\index{ru}{интеграл|степенного ряда||||(упр.~3.59)}  \index{ru}{степенные ряды как потоки|интегрирование||||(упр.~3.59)} Интеграл последовательности
$a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots$ есть
последовательность
$$
c + a_0 x + \frac{1}{2} a_1 x^2 + \frac{1}{3} a_2 x^3 + \frac{1}{4} a_3 x^4 + \cdots
$$
где $c$ --- произвольная константа.  Определите процедуру
{\tt integrate-series},
\index{ru}{integrate-series||||p|(упр.~3.59)}
которая на входе принимает поток
$a_0, a_1, a_2,\ldots$, представляющую степенной ряд, и
возвращает поток
$a_0, \dfrac{1}{2} a_1, \dfrac{1}{3} a_2, \ldots$
коэффициентов при неконстантных членах интеграла последовательности.
(Поскольку в результате отсутствует постоянный член, он не
представляет собой степенной ряд; при использовании
{\tt integrate-series} мы через {\tt cons} будем
присоединять к началу соответствующую константу.)

\item
Функция $x \mapsto e^x$ равна своей
собственной производной.  Отсюда следует, что $e^x$ и
интеграл $e^x$ суть одна и та же последовательность, с
точностью до постоянного члена, который равен $e^0 = 1$.
Соответственно, можно породить последовательность для $e^x$
через

\begin{Verbatim}[fontsize=\small]
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
\end{Verbatim}
Покажите, как породить последовательности для синуса и косинуса,
опираясь на то, что производная синуса равна косинусу, а производная
косинуса равна минус синусу:

\begin{Verbatim}[fontsize=\small]
(define cosine-series
  (cons-stream 1 \textit{$\langle$??$\rangle$}))

(define sine-series
  (cons-stream 0 \textit{$\langle$??$\rangle$}))
\end{Verbatim}
\end{plainenum}
\end{exercise}
\begin{exercise}{3.60}\label{EX3.60}%
Если \index{ru}{степенной ряд, представленный как поток|сложение||||(упр.~3.60)}степенной ряд представляется в виде потока своих
коэффициентов, как в упражнении~\ref{EX3.59}, то сумма
последовательностей реализуется посредством {\tt add-stre\-ams}.
Завершите определение следующей процедуры для  \index{ru}{степенной ряд, представленный как поток|перемножение||||(упр.~3.60)} перемножения
последовательностей:

\begin{Verbatim}[fontsize=\small]
(define (mul-series s1 s2)\index{ru}{mul-series||||p|(упр.~3.60)}
   (cons-stream \textit{$\langle$??$\rangle$} (add-streams \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$})))
\end{Verbatim}
Можете проверить свою процедуру, убедившись, что
$\sin^2 x + \cos^2 x = 1$ с помощью последовательностей из
упражнения~\ref{EX3.59}.
\end{exercise}
\begin{exercise}{3.61}\label{EX3.61}%
Пусть $S$ будет степенным рядом
(упражнение~\ref{EX3.59} с постоянным членом 1.  Предположим, что мы
хотим найти степенной ряд $1/S$, то есть такой ряд
$X$, что $S \cdot X = 1$.  Запишем
$S = 1 + S_R$, где $S_R$~--- часть
$S$ после постоянного члена.  Тогда мы можем решить
уравнение для $X$ так:
$$
\begin{array}{rcl}
S \cdot X               & = & 1\\
(1 + S_R) \cdot X       & = & 1\\
X + S_R \cdot X         & = & 1\\
X                       & = & 1 - S_R \cdot X
\end{array}
$$
Другими словами, $X$ есть степенной ряд с постоянным членом
1, чьи члены с более высокими степенями определяются как минус
произведение $S_R$ и $X$.  Воспользовавшись этим,
напишите процедуру {\tt invert-unit-series}, которая
вычисляет $1/S$ для степенного ряда $S$ с
постоянным членом 1.  Вам потребуется {\tt mul-series} из
упражнения~\ref{EX3.60}.
\end{exercise}
\begin{exercise}{3.62}\label{EX3.62}%
 \index{ru}{степенной ряд, представленный как поток|деление||||(упр.~3.62)}При помощи результатов
упражнений~\ref{EX3.60} и \ref{EX3.61} определите
процедуру  {\tt div-series},
\index{ru}{div-series||||p|(упр.~3.62)}
которая делит один степенной ряд на другой. {\tt Div-series}
должна работать для любых двух рядов, при
условии, что ряд в знаменателе начинается с ненулевого постоянного
члена. (Если в знаменателе постоянный член равен нулю,
{\tt div-series} должна сообщать об ошибке.)  Покажите, как при
помощи {\tt div-series} и результата
упражнения~\ref{EX3.59} получить
\index{ru}{тангенс|степенной ряд||||(упр.~3.62)}
степенной ряд для тангенса.
\end{exercise}

\subsection{Использование парадигмы потоков}
\label{EXPLOITING-THE-STREAM-PARADIGM}


Потоки с задержкой вычисления могут служить мощным
инструментом моделирования.  Они дают многие из преимуществ, обычно
предоставляемых внутренним состоянием и присваиванием.  Более того,
они избегают некоторых из теоретических неудобств, связанных с
введением присваивания в язык программирования.

\index{ru}{модульность|и потоки||||}
Потоковый метод может изменять взгляд на
вещи, так как он позволяет строить системы с другими границами модулей,
не такими, как в системах, основанных на присваивании переменным состояния.
Например, можно сосредоточивать внимание на всей временной
последовательности (или сигнале), а не на значении переменных состояния в
отдельные моменты.  Оказывается удобно сочетать и сравнивать параметры
состояния в различные моменты времени.

\paragraph{Итерация как потоковый процесс}


\index{ru}{итеративный процесс|как потоковый процесс||||}
В разделе~\ref{LINEAR-RECURSION-AND-ITERATION} мы ввели понятие
итеративного процесса, по мере исполнения изменяющего переменные
состояния.  Теперь мы узнали, что можно представлять состояние в виде
<<вневременного>> потока значений, а не набора обновляемых
переменных.  Давайте примем этот взгляд и заново рассмотрим
процедуру поиска квадратного корня из
раздела~\ref{EXAMPLE-SQUARE-ROOTS-BY-NEWTONS-METHOD}.  Напомним,
что идея процедуры состояла в том, чтобы порождать последовательность все
лучших и лучших приближений к квадратному корню $x$, снова
и снова применяя процедуру улучшения гипотезы:

\begin{Verbatim}[fontsize=\small]
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
\end{Verbatim}

 \index{ru}{квадратный корень|поток приближений||||}В исходной процедуре {\tt sqrt} эти гипотезы были
последовательными значениями переменной состояния.  Вместо этого можно
породить бесконечный поток гипотез, в голове которого стоит начальная
гипотеза 1\footnote{Внутреннюю переменную {\tt guesses} нельзя
связать с помощью {\tt let}, поскольку значение
{\tt guesses} зависит от нее самой.  В
упражнении~\ref{EX3.63} рассматривается вопрос, зачем здесь нужна
внутренняя переменная.
}:

\begin{Verbatim}[fontsize=\small]
(define (sqrt-stream x) \index{ru}{sqrt-stream||||pd|}
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)

(display-stream (sqrt-stream 2))
\textit{1}
\textit{1.5}
\textit{1.4166666666666665}
\textit{1.4142156862745097}
\textit{1.4142135623746899}
\textit{\ldots}
\end{Verbatim}
Можно порождать все больше элементов потока, получая все лучшие
приближения.  Если нужно, можно написать процедуру, которая бы
порождала гипотезы до тех пор, пока ответ не окажется достаточно
хорош. (См.~упражнение~\ref{EX3.64}.)

\index{ru}{бесконечный поток|для суммирования ряда||||}
\index{ru}{пи ($\pi$)|поток приближений||||}
\index{ru}{суммирование последовательности|с потоками||||}
Еще один итеративный процесс, который можно рассматривать
подобным образом ---  \index{ru}{пи ($\pi$)|ряд Лейбница||||} аппроксимация числа $\pi$, основанная
на знакочередующемся ряде, упомянутом в разделе~\ref{PROCEDURES-AS-ARGUMENTS}:
$$
\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \cdots
$$
Сначала мы порождаем поток элементов ряда (числа, обратные нечетным
натуральным, с чередующимся знаком).  Затем мы берем поток сумм все
большего количества элементов (при помощи процедуры
{\tt partial-sums} из упражнения~\ref{EX3.55}) и
домножаем результат на 4:
\index{ru}{Лейбниц, барон Готфрид Вильгельм фон|ряд для вычисления $\pi$|Baron Gottfried Wilhelm von Leibniz||n|}\index{en}{Baron Gottfried Wilhelm von Leibniz||Лейбниц, барон Готфрид Вильгельм фон|ряд для вычисления $\pi$|n|}

\begin{Verbatim}[fontsize=\small]
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))

(define pi-stream\index{ru}{pi-stream||||pd|}
  (scale-stream (partial-sums (pi-summands 1)) 4))

(display-stream pi-stream)
\textit{4.}
\textit{2.666666666666667}
\textit{3.466666666666667}
\textit{2.8952380952380956}
\textit{3.3396825396825403}
\textit{2.9760461760461765}
\textit{3.2837384837384844}
\textit{3.017071817071818}
\textit{\ldots}
\end{Verbatim}
Получается поток все более точных приближений к $\pi$, но
сходятся эти приближения довольно медленно.  Восемь членов
последовательности поместили $\pi$ между 3.284 и 3.017.

 \index{ru}{суммирование последовательности|ускорение последовательности приближений||||}
Пока что подход с потоком состояний не слишком отличается
от потока с переменными состояния.  Однако потоки дают нам возможность
проделывать некоторые интересные трюки.  Например, поток можно
преобразовать с помощью
\index{ru}{ускоритель последовательности||sequence accelerator|||}\index{en}{sequence accelerator||ускоритель последовательности|||}{\em ускорителя
последовательности} (sequence accelerator), преобразующего последовательность
приближений в новую последовательность, которая сходится к тому же
значению, что и исходная, но быстрее.

Один такой ускоритель, открытый швейцарским
математиком восемнадцатого века
\index{ru}{Эйлер, Леонард|ускоритель рядов|Leonhard Euler|||}\index{en}{Leonhard Euler||Эйлер, Леонард|ускоритель рядов||}
Леонардом Эйлером, хорошо работает с
последовательностями частичных сумм знакочередующихся рядов (рядов,
знаки элементов которых чередуются).  По методу Эйлера, если
$S_n$ есть $n$-й член исходного ряда, то
ускоренная последовательность имеет элементы
$$
S_{n+1} - \frac{(S_{n+1} - S_n)^2}
               {S_{n-1} - 2S_n + S_{n+1}}
$$
Таким образом, если исходная последовательность представлена как
поток значений, преобразованная последовательность дается процедурой

\begin{Verbatim}[fontsize=\small]
(define (euler-transform s)\index{ru}{euler-transform||||pd|}
  (let ((s0 (stream-ref s 0))   {\em ; $S_{n-1}$}
        (s1 (stream-ref s 1))   {\em ; $S_n$}
        (s2 (stream-ref s 2)))  {\em ; $S_{n+1}$}
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
\end{Verbatim}

Можно продемонстрировать ускорение Эйлера на нашей
последовательности приближений к $\pi$:

\begin{Verbatim}[fontsize=\small]
(display-stream (euler-transform pi-stream))
\textit{3.166666666666667}
\textit{3.1333333333333337}
\textit{3.1452380952380956}
\textit{3.13968253968254}
\textit{3.1427128427128435}
\textit{3.1408813408813416}
\textit{3.142071817071818}
\textit{3.1412548236077655}
\textit{\ldots}
\end{Verbatim}

Более того, можно ускорить ускоренную последовательность,
рекурсивно ускорить результат, и так далее.  То есть, можно создать
поток потоков (структуру, которую мы будем называть
\index{ru}{табло||tableau|||}\index{en}{tableau||табло|||}{\em табло} (tableau)), в котором каждый поток есть
результат преобразования предыдущего:

\begin{Verbatim}[fontsize=\small]
(define (make-tableau transform s)\index{ru}{make-tableau||||pd|}
  (cons-stream s
               (make-tableau transform
                             (transform s))))
\end{Verbatim}
Табло имеет вид
$$
\begin{array}{cccccc}
s_{00} & s_{01} & s_{02} & s_{03} & s_{04} & \ldots\\
       & s_{10} & s_{11} & s_{12} & s_{13} & \ldots\\
       &        & s_{20} & s_{21} & s_{22} & \ldots\\
       &        &        &        & \ldots\\
\end{array}
$$
Наконец, можно построить последовательность, членами которой будут
первые элементы каждой строки табло:

\begin{Verbatim}[fontsize=\small]
(define (accelerated-sequence transform s)\index{ru}{accelerated-sequence||||pd|}
  (stream-map stream-car
              (make-tableau transform s)))
\end{Verbatim}

Можно показать, как работает такое <<сверхускорение>> на
последовательности приближений к $\pi$:

\begin{Verbatim}[fontsize=\small]
(display-stream (accelerated-sequence euler-transform
                                      pi-stream))
\textit{4.}
\textit{3.166666666666667}
\textit{3.142105263157895}
\textit{3.141599357319005}
\textit{3.1415927140337785}
\textit{3.1415926539752927}
\textit{3.1415926535911765}
\textit{3.141592653589778}
\textit{\ldots}
\end{Verbatim}
Результат впечатляет.  Восемь членов последовательности дают нам
верное значение $\pi$ с точностью до 14 десятичных знаков.
Если бы у нас была только исходная последовательность приближений к
$\pi$, то пришлось бы вычислить порядка $10^{13}$
ее элементов (то есть довести последовательность до такого места, где
ее элементы становятся меньше $10^{-13}$), чтобы добиться
такой точности!

Все эти методы ускорения можно было бы реализовать и без
помощи потоков.  Однако формулировка в терминах потоков обладает
особым удобством и изяществом, поскольку мы имеем доступ ко всей
последовательности состояний в виде структуры данных, с которой можно
работать при помощи единого набора операций.
\begin{exercise}{3.63}\label{EX3.63}%
Хьюго Дум спрашивает, почему нельзя было написать
{\tt sqrt-stream} более простым способом, без внутренней
переменной {\tt guesses}:

\begin{Verbatim}[fontsize=\small]
(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess)
                             (sqrt-improve guess x))
                           (sqrt-stream x))))
\end{Verbatim}
Лиза П.~Хакер отвечает, что эта версия процедуры значительно менее
эффективна, поскольку производит избыточные вычисления.  Объясните
Лизин ответ.  Сохранилось бы отличие в эффективности, если бы
реализация {\tt delay} использовала только {\tt (lambda ()
\textit{$\langle$выражение$\rangle$})}, без оптимизации
через {\tt memo-proc} (см. раздел~\ref{STREAMS-ARE-DELAYED-LISTS})?
\end{exercise}
\begin{exercise}{3.64}\label{EX3.64}%
\index{ru}{sqrt|как предел потока|||p|(упр.~3.64)} Напишите процедуру \index{ru}{stream-limit||||p|(упр.~3.64)}{\tt stream-limit}, которая в
качестве аргумента принимает поток и число (погрешность).  Она должна
просматривать поток, пока не найдется два элемента подряд,
различающихся меньше, чем на погрешность, и возвращать второй из этих
элементов. При помощи этой процедуры можно будет вычислять квадратные
корни с заданной точностью так:

\begin{Verbatim}[fontsize=\small]
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
\end{Verbatim}
\end{exercise}
\begin{exercise}{3.65}\label{EX3.65}%
\index{ru}{логарифм, аппроксимация $\ln 2$||logarithm, approximating $\ln 2$|||(упр.~3.65)}%
\index{en}{logarithm, approximating $\ln 2$||логарифм, аппроксимация $\ln 2$|||(упр.~3.65)}%
С помощью ряда
$$
\ln 2 = 1 - \frac{1}{2} + \frac{1}{3} - \frac{1}{4} + \cdots
$$
породите три последовательности приближений к натуральному логарифму 2, так же, как
мы выше сделали это для $\pi$.  Как быстро сходятся эти
последовательности?
\end{exercise}

\paragraph{Бесконечные потоки пар}


\index{ru}{бесконечный поток|пар||||}
\index{ru}{пара (пары)|бесконечные потоки||||}
\index{ru}{отображение|вложенное||||}
В разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES} мы видели, как
парадигма работы с последовательностями рассматривает вложенные циклы
традиционной парадигмы в виде процессов, определенных на
последовательности пар.  Если мы обобщим этот метод на бесконечные
потоки, то сможем писать программы, которые трудно воспроизвести
с помощью обычных циклов, поскольку <<цикл>> охватывает бесконечное
множество.

Например, пусть нам хочется обобщить процедуру
\index{ru}{prime-sum-pairs|бесконечный поток|||p|}
{\tt sum-of-primes} из
раздела~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES} так, чтобы
получился поток из {\em всех} пар натуральных чисел $(i,j)$, таких, что
$i \leq j$ и $i+j$ простое.  Если
{\tt int-pairs} есть последовательность всех пар натуральных
чисел $(i,j)$, где $i \leq j$, то необходимый
нам поток таков\footnote{Как и в
разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}, мы
представляем пару натуральных чисел в виде списка, а не лисповской
пары.
}:

\begin{Verbatim}[fontsize=\small]
(stream-filter (lambda (pair)
                 (prime? (+ (car pair) (cadr pair))))
               int-pairs)
\end{Verbatim}

Задача, следовательно, состоит в том, чтобы породить
поток {\tt int-pairs}.  В более общем случае допустим, что у
нас есть два потока $S = (S_i)$ и $T = (T_j)$, и
представим себе бесконечную матрицу
$$
\begin{array}{cccc}
(S_0, T_0) & (S_0, T_1) & (S_0, T_2) & \ldots\\
(S_1, T_0) & (S_1, T_1) & (S_1, T_2) & \ldots\\
(S_2, T_0) & (S_2, T_1) & (S_2, T_2) & \ldots\\
\ldots\\
\end{array}
$$
Нам хочется породить поток, который содержит все пары из этой матрицы,
лежащие на диагонали или выше, а именно пары
$$
\begin{array}{cccc}
(S_0, T_0) & (S_0, T_1) & (S_0, T_2) & \ldots\\
           & (S_1, T_1) & (S_1, T_2) & \ldots\\
           &            & (S_2, T_2) & \ldots\\
           &            &            & \ldots\\
\end{array}
$$
(Если мы возьмем и $S$, и $T$ равными потоку
натуральных чисел, то получим как раз необходимый нам поток
{\tt int-pairs}.)

Назовем общий поток пар {\tt (pairs S T)}, и будем
считать, что он состоит из трех частей: пары $(S_0, T_0)$,
остатка пар в первом ряду, и всех остальных пар\footnote{В упражнении~\ref{EX3.68} объясняется,
почему мы выбрали именно такую декомпозицию.}:
$$
\begin{array}{c|ccc}
(S_0, T_0) & (S_0, T_1) & (S_0, T_2) & \ldots\\
\hline
           & (S_1, T_1) & (S_1, T_2) & \ldots\\
           &            & (S_2, T_2) & \ldots\\
           &            &            & \ldots\\
\end{array}
$$
Заметим, что третья часть этой декомпозиции (пары, не лежащие в первом
ряду) суть пары, получаемые (рекурсивно) из {\tt (stream-cdr
S)} и {\tt (stream-cdr T)}.  Заметим также, что вторая
часть (остаток первого ряда) есть

\begin{Verbatim}[fontsize=\small]
(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
\end{Verbatim}
Таким образом, мы можем сформировать наш поток пар так:

\begin{Verbatim}[fontsize=\small]
(define (pairs s t)\index{ru}{pairs||||pd|}
  (cons-stream
   (list (stream-car s) (stream-car t))
   ($\langle$\textit{как-нибудь смешать}$\rangle$
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
\end{Verbatim}

\index{ru}{бесконечный поток|слияние||||}
Чтобы закончить определение процедуры, нужно выбрать
какой-нибудь способ смешать два внутренних потока.  В голову приходит
воспользоваться потоковым аналогом процедуры {\tt append}
из раздела~\ref{REPRESENTING-SEQUENCES}:

\begin{Verbatim}[fontsize=\small]
(define (stream-append s1 s2) \index{ru}{stream-append||||pd|}
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
\end{Verbatim}
Однако эта идея не срабатывает с бесконечными потоками, поскольку,
прежде чем перейти ко второму потоку, нужно пройти весь первый поток
до конца.  В частности, если мы попробуем породить все пары натуральных
чисел при помощи

\begin{Verbatim}[fontsize=\small]
(pairs integers integers)
\end{Verbatim}
то получившийся поток сначала попытается перечислить все пары, где первый
элемент равен 1, а следовательно, никогда не породит ни одной пары с
другим значением первого члена.

Для работы с бесконечными потоками требуется придумать
способ смешения, который гарантировал бы, что каждый элемент будет
достигнут, если программе дать достаточно времени.  Изящный
способ добиться этого состоит в том, чтобы воспользоваться следующей
процедурой {\tt interleave}\footnote{Точная формулировка требования, которому должен
удовлетворять порядок
слияния, выглядит так: должна существовать функция от двух аргументов
$f$, такая, что пара, соответствующая $i$-му
элементу первого потока и $j$-му элементу второго,
появится в качестве элемента выходного потока под номером
$f(i,j)$.  Трюк с чередованием через
{\tt interleave} нам показал Дэвид Тёрнер, который использовал
его в языке \index{ru}{KRC|||||п} KRC (Turner 1981).
\index{ru}{Тёрнер, Дэвид||David Turner||n|п}\index{en}{David Turner||Тёрнер, Дэвид||n|п}
}:

\begin{Verbatim}[fontsize=\small]
(define (interleave s1 s2)\index{ru}{interleave||||pd|}
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
\end{Verbatim}
Поскольку {\tt interleave} чередует элементы из двух потоков,
всякий элемент второго потока рано или поздно попадет в смешанный
поток, даже если первый поток бесконечен.

Таким образом, мы можем породить требуемый поток пар так:

\begin{Verbatim}[fontsize=\small]
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
\end{Verbatim}
\begin{exercise}{3.66}\label{EX3.66}%
Рассмотрим поток {\tt (pairs integers integers)}
Можете ли Вы что-то сказать о порядке, в котором пары попадают в
поток? Например, сколько приблизительно пар предшествуют паре (1,
100)? Паре (99, 100)? (100, 100)?  (Если Вы способны предоставить
точные математические утверждения,~--- прекрасно. Однако если Вы увязаете
в деталях, достаточно качественных оценок.)
\end{exercise}
\begin{exercise}{3.67}\label{EX3.67}%
Измените процедуру так, чтобы {\tt (pairs
integers integers)} порождало поток из {\em всех} пар
натуральных чисел $(i,j)$, без дополнительного условия
$i \leq j$.  Подсказка: потребуется примешать еще один
поток.
\end{exercise}
\begin{exercise}{3.68}\label{EX3.68}%
Хьюго Дум считает, что построение потока пар из трех
частей~--- процедура слишком сложная.  Он предлагает вместо того,
чтобы отделять пару $(S_0, T_0)$, работать с первой строкой
целиком:

\begin{Verbatim}[fontsize=\small]
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
\end{Verbatim}
Будет ли такой код работать?  Посмотрите, что произойдет, если мы
попытаемся вычислить {\tt (pairs integers integers)}, используя
определение Хьюго.
\end{exercise}
\begin{exercise}{3.69}\label{EX3.69}%
Напишите процедуру {\tt triples}, которая
берет три бесконечных потока $S$, $T$ и
$U$, и порождает поток троек $(S_i, T_j, U_k)$,
таких, что $i \leq j \leq k$.  С помощью
{\tt triples} породите поток всех \index{ru}{Пифагоровы тройки|в потоках||||(упр.~3.69)}Пифагоровых троек натуральных
чисел, т.~е. таких троек $(i,j,k)$, что $i \leq
j$ и $i^2 + j^2 = k^2$
\end{exercise}
\begin{exercise}{3.70}\label{EX3.70}%
Интересно было бы уметь порождать потоки в каком-либо
полезном порядке, а не в порядке, задаваемом к случаю придуманным
процессом чередования.  \index{ru}{бесконечный поток|слияние||||(упр.~3.70)}Можно воспользоваться методом, подобным
процедуре {\tt merge} из упражнения~\ref{EX3.56},
если мы определим способ сказать, что одна пара целых чисел <<меньше>>
другой.  Один из способов состоит в том, чтобы определить <<функцию
взвешивания>> $W(i,j)$ и постановить, что $(i_1,
j_1)$ меньше, чем $(i_2, j_2)$, если
$W(i_1, j_1) \leq W(i_2, j_2)$.  Напишите процедуру
{\tt merge-weighted},
\index{ru}{merge-weighted||||p|(упр.~3.70)}
которая во всем подобна
{\tt merge}, но только в качестве дополнительного аргумента
принимает процедуру {\tt weight}, которая вычисляет вес пары, и
используется для определения порядка, в котором элементы должны
появляться в получающемся смешанном потоке\footnote{Мы будем требовать от функции взвешивания, чтобы вес пары возрастал при движении вправо по строке или вниз
по столбцу в матрице пар.
}.
При помощи {\tt merge-weighted} напишите процедуру
{\tt weighted-pairs}, обобщающую {\tt pairs}. Она должна
принимать два потока и процедуру, вычисляющую функцию взвешивания, и
порождать поток пар, упорядоченных по весу.  Породите, используя эту
процедуру:
\begin{plainenum}
\item
Поток всех пар натуральных чисел $(i,j)$ где
$ i \leq j $, упорядоченных по сумме $i+j$.

\item
 поток всех пар натуральных чисел
$(i,j)$, где $i \leq j$, ни $i$, ни
$j$ не делится ни на 2, ни на 3, ни на 5, и пары
упорядочены по значению суммы $2i + 3j + 5ij$.
\end{plainenum}
\end{exercise}
\begin{exercise}{3.71}\label{EX3.71}%
Числа, которые можно выразить в виде суммы двух кубов
более, чем одним способом, иногда называют
\index{ru}{Рамануджана числа||Ramanujan numbers|||(упр.~3.71)}\index{en}{Ramanujan numbers||Рамануджана числа|||(упр.~3.71)}{\em числами Рамануджана} (Ramanujan numbers), в честь
математика Шринивасы Рамануджана\footnote{Цитата из некролога на
  смерть Рамануджана,\index{ru}{Рамануджан, Шриниваса||Srinivasa
    Ramanujan||n|п}\index{en}{Srinivasa Ramanujan||Рамануджан,
    Шриниваса||n|п}
написанного Г.~Х.~Харди  (Hardy 1921):\index{ru}{Харди, Годфри
  Харольд||Godfrey Harold Hardy||n|п}\index{en}{Godfrey Harold
  Hardy||Харди, Годфри Харольд||n|п}
<<Кажется, это мистер Литлвуд заметил, что <<каждое натуральное число было ему
другом>>. Я помню, как однажды навестил его, когда он лежал больной в
Путни.  Я приехал в такси номер 1729, сказал, что число показалось
мне скучным, и выразил надежду, что это не было несчастливым
знаком. <<Нет, --- ответил он, --- это очень интересное число; это
наименьшее число, которое можно двумя различными способами выразить как
сумму двух кубов>>. Трюк с использованием взвешенных пар для
порождения чисел Рамануджана нам показал Чарльз Лейзерсон.}.
Упорядоченные потоки пар предлагают изящное решение для задачи
порождения таких чисел.  Чтобы найти число, которое можно двумя
разными способами записать в виде суммы двух кубов, требуется только
породить поток пар натуральных чисел $(i,j)$, взвешенных
согласно сумме $i^3 + j^3$
(см.~упражнение~\ref{EX3.70}), и искать в этом потоке две
пары подряд с одинаковым весом.  Напишите процедуру для порождения
чисел Рамануджана.  Первое такое число 1729.  Каковы следующие
пять?
\end{exercise}
\begin{exercise}{3.72}\label{EX3.72}%
Используя метод, подобный описанному в
упражнении~\ref{EX3.71}, породите поток всех чисел,
которые можно
записать как сумму двух квадратов тремя различными способами (и
покажите, каковы эти способы).
\end{exercise}

\paragraph{Потоки как сигналы}



\begin{cntrfig}
\input{xfig-mod/3-32.eepic}
\caption{Процедура {\tt integral} в виде
системы преобразования сигналов}
\label{P3.32}

\end{cntrfig}

\index{ru}{обработка сигналов|потоковая модель||||}
Мы начали обсуждение потоков с того, что описали их как
вычислительные аналоги <<сигналов>> в системах обработки сигналов.
\index{ru}{бесконечный поток|для моделирования сигналов||||}
На самом деле с помощью потоков такие системы можно моделировать
самым непосредственным образом, представляя значения сигнала в
последовательные моменты времени как последовательные элементы
потока.  Например, можно реализовать
\index{ru}{интегратор||integrator|||}\index{en}{integrator||интегратор|||}{\em интегратор} (integrator), или
\index{ru}{сумматор для сигналов||summer|||}\index{en}{summer||сумматор для сигналов|||}{\em сумматор} (summer), который, для входного потока
$x = (x_i)$, начального значения $C$ и малого
приращения времени $dt$, собирает сумму
$$
S_i = C + \sum_{j=1}^i x_j dt
$$
и возвращает поток значений $S = (S_i)$. Следующая
процедура {\tt integral} напоминает <<неявное>> определение
потока целых (раздел~\ref{INFINITE-STREAMS}):

\begin{Verbatim}[fontsize=\small]
(define (integral integrand initial-value dt)\index{ru}{integral||||pd|}
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
\end{Verbatim}
На рисунке~\ref{P3.32} показана система преобразования
сигналов, соответствующая процедуре {\tt integral}.  Входной
поток делится на отрезки $dt$ и пропускается через
сумматор, а вывод сумматора опять направляется на его вход.  Ссылка на
самого себя в определении {\tt int} отражена на диаграмме в
виде цикла обратной связи, соединяющего выход сумматора с одним из его
входов.


\begin{cntrfig}
\input{xfig-mod/3-33-1.eepic}
$v = v_0 + 1/C \int_0^1idt + Ri$

\input{xfig-mod/3-33-2.eepic}
\caption{RC-цепь и связанная с ней диаграмма
потока сигналов.}
\label{P3.33}

\end{cntrfig}
\begin{exercise}{3.73}\label{EX3.73}%
\index{ru}{электрические цепи, моделируемые с помощью потоков|||||(упр.~3.73)}%
\index{ru}{диаграмма потока сигналов|||||(упр.~3.73)}%
\index{ru}{цепь электрическая|моделируемая с помощью потоков|circuit|||(упр.~3.73)}%
\index{en}{circuit||цепь электрическая|моделируемая с     помощью  потоков||(упр.~3.73)}%
\index{ru}{схема|моделируемая с помощью потоков|circuit|||(упр.~3.73)}%
\index{en}{circuit||схема|моделируемая с помощью потоков||(упр.~3.73)}%
Можно моделировать электрические цепи с помощью
потоков, представляющих значения тока или напряжения в определенные
моменты времени.  Допустим, например, что у нас имеется
\index{ru}{RC-цепь||RC circuit|||(упр.~3.73)}\index{en}{RC circuit||RC-цепь|||(упр.~3.73)}{\em цепь RC} (RC circuit),
состоящая из резистора с
сопротивлением $R$ и конденсатора емкостью $C$,
соединенных последовательно.  Значение напряжения $v$ в
зависимости от заданного тока $i$ определяется формулой,
показанной на рис.~\ref{P3.33}. Структура формулы показана
на прилагаемой диаграмме потока сигналов.

Напишите процедуру {\tt RC}, моделирующую эту
цепь. На входе {\tt RC} должна получать значения
$R$, $C$ и $dt$, и выдавать
процедуру, которая принимает на входе поток значений тока
$i$ и начальное значение напряжения $v_0$, а на
выходе выдает поток значений напряжения $v$.  Например, у Вас
должна быть возможность смоделировать при помощи {\tt RC} RC-цепь
с $R = 5$ ом, $C = 1$ фараде, и временным шагом
в 0,5 секунды, вычислив {\tt (define RC1 (RC 5 1 0.5))}.  Здесь
{\tt RC1} определяется как процедура, которая принимает на
входе поток, представляющий временную последовательность токов, и
исходное напряжение на конденсаторе, а на выходе дает временной
поток напряжений.
\end{exercise}

\begin{exercise}{3.74}\label{EX3.74}%
Лиза П.~Хакер разрабатывает систему для обработки
сигналов, приходящих от физических сенсоров.  \index{ru}{обработка  сигналов|переход сигнала через ноль||||(упр.~3.74)}
\index{ru}{переход сигнала через ноль|||||(упр.~3.74)}
Один из важных
инструментов, который она хочет построить, --- это сигнал, описывающий
\index{ru}{переход сигнала через ноль||zero crossing of a signal|||(упр.~3.74)}\index{en}{zero crossing of a signal||переход сигнала через ноль|||(упр.~3.74)}{\em переходы входного сигнала
через ноль} (zero crossings).
Выходной сигнал должен равняться +1, когда сигнал на входе меняется
с отрицательного на положительный, -1, когда сигнал меняется с
положительного на отрицательный, и 0 в
остальных случаях. (Допустим, что знак нулевого входа
положителен). Например, типичный входной сигнал и связанный с ним
сигнал перехода через ноль могут выглядеть так:

\medskip
$$
\arraycolsep=0,05em
\begin{array}{crlrlrlrlrlrlrlrlrlrlrlrlrlrr}
\ldots & 1&  & 2&  & 1.5&  & 1&  & 0.5&  & -0.1&   & -2&  & -3&  & -2&  & -0.5&  & 0.2&  & 3&  & 4 & & \ldots\\
\ldots &  &0 &  &0 &    &0 &  &0 &    &0 &     &-1 &   &0 &   &0 &   &0 &     &0 &    &1 &  &0 &  &0 &  \ldots\\
\end{array}
$$

\medskip
В Лизиной системе сигнал от сенсора представляется как поток
{\tt sense-data}, а {\tt zero-crossings} представляет
соответствующий поток пересечений нуля.  Для начала Лиза пишет
процедуру {\tt sign-change-detector}, которая берет два
значения в качестве аргументов и, срав\-нив их знаки, выдает 0, 1 или -1.
Затем она строит поток переходов через ноль следующим образом:

\begin{Verbatim}[fontsize=\small]
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector (stream-car input-stream) last-value)
   (make-zero-crossings (stream-cdr input-stream)
                        (stream-car input-stream))))

(define zero-crossings (make-zero-crossings sense-data 0))
\end{Verbatim}
Мимо проходит Лизина начальница Ева Лу Атор и замечает, что
программа приблизительно равносильна следующей, написанной с
использованием обобщенной версии {\tt stream-map} из
упражнения~\ref{EX3.50}:

\begin{Verbatim}[fontsize=\small]
(define zero-crossings
  (stream-map sign-change-detector sense-data \textit{$\langle$выражение$\rangle$}))
\end{Verbatim}
Завершите программу, вставив необходимое \textit{$\langle$выражение$\rangle$}.
\end{exercise}
\begin{exercise}{3.75}\label{EX3.75}%
\index{ru}{обработка сигналов|сглаживание сигнала||||(упр.~3.75)}%
\index{ru}{обработка сигналов|переход сигнала     через ноль||||(упр.~3.75)}%
\index{ru}{сглаживание сигнала||smoothing a signal|||(упр.~3.75)}%
\index{en}{smoothing a signal||сглаживание сигнала|||(упр.~3.75)}%
\index{ru}{переход сигнала через ноль|||||(упр.~3.75)}%
К сожалению, Лизин детектор
перехода через ноль из
упражнения~\ref{EX3.74} оказывается недостаточным, потому
что зашумленный сигнал от сенсоров приводит к ложным срабатываниям.
Инженер-электронщик Дайко Поправич предлагает Лизе сгладить сигнал,
чтобы отфильтровать шум, прежде, чем отлавливать пересечение нуля.
Лиза принимает его совет и решает извлечь переходы через ноль из сигнала,
полученного взятием среднего арифметического каждого значения входных
данных с предыдущим значением.  Она объясняет задачу своему помощнику
Хьюго Думу, и тот пытается реализовать идею, поправив Лизин
текст следующим образом:

\begin{Verbatim}[fontsize=\small]
(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-value)
                 (make-zero-crossings (stream-cdr input-stream)
                                      avpt))))
\end{Verbatim}
Этот код неверно реализует замысел Лизы.  Найдите ошибку, внесенную
Хьюго, и исправьте ее, не меняя структуру программы. (Подсказка:
придется увеличить число аргументов {\tt make-zero-crossings}.)
\end{exercise}
\begin{exercise}{3.76}\label{EX3.76}%
\index{ru}{обработка сигналов|сглаживание сигнала||||(упр.~3.76)}%
\index{ru}{обработка сигналов|переход сигнала     через ноль||||(упр.~3.76)}%
\index{ru}{сглаживание сигнала|||||(упр.~3.76)}%
\index{ru}{переход сигнала через ноль|||||(упр.~3.76)}%
Ева Лу Атор недовольна
подходом Хьюго из упражнения~\ref{EX3.75}.  Написанная им программа не модульна,
поскольку смешивает операции сглаживания и отлова пересечений ноля.
Например, тест на пересечение не должен изменяться, если Лизе удастся
найти другой способ улучшить качество входного сигнала.  Помогите Хьюго
и напишите процедуру {\tt smooth}, которая берет на входе
поток, а на выходе выдает поток, элементы которого получены усреднением каждых двух
последовательных элементов входного потока.  Затем используйте
{\tt smooth} как компоненту и реализуйте детектор перехода
через ноль в более модульном стиле.
\end{exercise}

\subsection{Потоки и задержанное вычисление}
\label{STREAMS-AND-DELAYED-EVALUATION}


\index{ru}{поток(и)|и задержанное         вычисление||||}%
\index{ru}{задержанные вычисления|и потоки||||}%
Процедура {\tt integral} в конце предыдущего
раздела  показывает, как с помощью потоков можно моделировать системы
обработки сигналов, которые содержат
\index{ru}{цикл обратной связи, моделируемый с помощью потоков||feedback loop|||}
\index{en}{feedback loop||цикл обратной связи, моделируемый с помощью потоков|||}
циклы обратной связи.  Цикл
обратной связи для сумматора, показанный на
рис.~\ref{P3.32}, моделируется тем, что внутренний поток
{\tt int} в процедуре {\tt integral} определяется с
использованием себя самого:

\begin{Verbatim}[fontsize=\small]
(define int
  (cons-stream initial-value
               (add-streams (scale-stream integrand dt)
                            int)))
\end{Verbatim}
Способность интерпретатора работать с таким косвенным определением
зависит от {\tt delay}, встроенного в
{\tt cons-stream}.  Без этой задержки интерпретатор не мог бы
построить {\tt int}, не вычислив оба аргумента
{\tt cons-stream}, а для этого нужно, чтобы {\tt int}
уже был определен.  В общем случае, {\tt delay} играет ключевую
роль, когда мы моделируем системы обработки сигналов с обратной связью
при помощи потоков.  В отсутствие задержки нам приходилось бы
формулировать модели так, чтобы вход всякого обрабатывающего блока
полностью вычислялся, прежде чем блок выдает что-либо на выходе.  Такое
условие исключает циклы.

К сожалению, потоковые модели систем с циклами могут
требовать применения задержек помимо той, которая <<спрятана>> в
{\tt cons-stream}.  Например, на
рисунке~\ref{P3.34} показана система обработки сигналов, решающая
\index{ru}{дифференциальное уравнение||differential
  equation|||}\index{en}{differential     equation||дифференциальное
  уравнение|||}дифференциальное уравнение $dy/dt = f(y)$, где
$f$ --- заданная функция.  На рисунке показан отображающий
блок, который применяет $f$ ко входному сигналу, связанный
в цикл обратной связи с интегратором. Это очень похоже на работу
аналоговых схем, действительно используемых для решения
такого рода уравнений.


\begin{cntrfig}
\input{xfig-mod/3-34.eepic}
%\vspace{2,8cm}
\caption{<<Аналоговая компьютерная цепь>>,
которая решает уравнение $dy/dt = f(y)$.}
%%%% Добиться переноса уравнения на отдельную строчку!
\label{P3.34}
\end{cntrfig}

Если нам дано начальное значение $y_0$, мы могли
бы попытаться смоделировать эту систему с помощью процедуры

\begin{Verbatim}[fontsize=\small]
(define (solve f y0 dt) \index{ru}{solve||||pd|}
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
\end{Verbatim}
Эта процедура не работает, потому что вызов {\tt integral} в
\index{ru}{integral|необходимость задержанного вычисления|||p|}
первой строке {\tt solve} требует, чтобы был определен входной
поток {\tt dy}, а это происходит только во второй строке
процедуры {\tt solve}.

С другой стороны, замысл, заключенный в этом
определении, вполне здрав, поскольку мы можем, в принципе, начать
порождать поток {\tt y} и не зная {\tt dy}.
Действительно, {\tt integral} и многие другие операции над
потоками обладают свойствами, подобными {\tt cons-stream}, а
именно, мы можем породить часть ответа, даже если нам дана только
частичная информация об аргументах.  В случае {\tt integral}, первый
элемент выходного потока есть указанное начальное значение
{\tt initial-value}.  Таким образом, можно породить первый
элемент выходного потока и не вычисляя интегрируемую величину
{\tt dy}.  А раз мы знаем первый элемент {\tt y}, то
{\tt stream-map} во второй строке {\tt solve} может
начать работать и породить первый элемент {\tt dy}, а с его
помощью мы получим второй элемент {\tt y}, и так далее.

Чтобы воспользоваться этой идеей, переопределим
{\tt integral} так, чтобы он ожидал интегрируемый поток в виде
\index{ru}{аргумент(ы)|задержанный||||}
\index{ru}{задержанный аргумент||delayed argument|||}\index{en}{delayed argument||задержанный аргумент|||}{\em задержанного аргумента} (delayed argument).
\index{ru}{delay (особая форма)|явная|||p|}
{\tt Integral} будет размораживать вычисление входного потока
через {\tt force} только тогда, когда ему нужно породить
элементы входного потока помимо первого:

\begin{Verbatim}[fontsize=\small]
(define (integral delayed-integrand initial-value dt)\index{ru}{integral|с задержанным аргументом|||pd|}
  (define int
    (cons-stream initial-value
                 (let ((integrand (force delayed-integrand)))
                   (add-streams (scale-stream integrand dt)
                                int))))
   int)
\end{Verbatim}
Теперь можно реализовать процедуру {\tt solve}, задержав
вычисление {\tt dy} внутри определения {\tt y}\footnote{Не гарантируется, что эта процедура будет работать во
всех реализациях Scheme, но для любой реализации должен найтись простой
способ заставить подобную процедуру работать.  Проблемы связаны с
тонкими различиями в том, как реализации Scheme обрабатывают
внутренние определения.
(См.~раздел~\ref{INTERNAL-DEFINITIONS-CH4}.)}:

\begin{Verbatim}[fontsize=\small]
(define (solve f y0 dt) \index{ru}{solve||||pd|}
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{Verbatim}
Теперь при любом вызове {\tt integral} необходимо
задерживать интегрируемый аргумент.  Можно показать, что процедура
{\tt solve} работает, \index{ru}{$e$|как  решение дифференциального уравнения||||}аппроксимируя $e \approx
2.718$ вычислением в точке $y = 1$ решения
дифференциального уравнения $dy/dt = y$ с начальным
условием $y(0) = 1$:

\begin{Verbatim}[fontsize=\small]
(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
\textit{2.716924}
\end{Verbatim}
\begin{exercise}{3.77}\label{EX3.77}%
Вышеприведенная процедура {\tt integral} была
аналогична <<непрямому>> определению бесконечного потока натуральных
чисел из раздела~\ref{INFINITE-STREAMS}.  В виде
альтернативы можно дать определение {\tt integral}, более
похожее на {\tt integers-starting-from} (также в
разделе~\ref{INFINITE-STREAMS}):

\begin{Verbatim}[fontsize=\small]
(define (integral integrand initial-value dt)\index{ru}{integral||||pd|(упр.~3.77)}
  (cons-stream initial-value
               (if (stream-null? integrand)
                   the-empty-stream
                   (integral (stream-cdr integrand)
                             (+ (* dt (stream-car integrand))
                                initial-value)
                             dt))))
\end{Verbatim}
В системах с циклами эта реализациея порождает такие же проблемы,
как и наша исходная версия {\tt integral}.  Модифицируйте
процедуру так, чтобы она ожидала {\tt integrand} как задержанный
аргумент, а следовательно, могла быть использована в процедуре
{\tt solve}.
\end{exercise}

\begin{cntrfig}
\input{xfig-mod/3-35.eepic}
\caption{Диаграмма потока сигналов для решения
линейного дифференциального уравнения второго
порядка.\index{ru}{дифференциальное уравнение|второго порядка||||(упр.~3.78)}}
\label{P3.35}
\end{cntrfig}

\begin{cntrfig}
\input{xfig-mod/3-36.eepic}
\caption{Последовательная RLC-цепь}
\label{P3.36}
\end{cntrfig}

\begin{exercise}{3.78}\label{EX3.78}%
Рассмотрим задачу проектирования системы обработки
сигналов для решения гомогенных линейных дифференциальных уравнений
второго порядка
$$
\frac{d^2 y}{dt^2} - a \frac{dy}{dt} - by = 0
$$
Выходной поток, моделирующий $y$, порождается сетью,
содержащей цикл.  Этот цикл возникает потому, что
значение ${d^2 y}/{dt^2}$ зависит от значений
$y$ и $dy/dt$, а они оба получаются
интегрированием ${d^2 y}/{dt^2}$.  Диаграмма, которую
нам хотелось бы закодировать, показана на
рис.~\ref{P3.35}.  Напишите процедуру
{\tt solve-2nd}, которая в качестве аргументов берет константы
$a$, $b$ и $dt$ и начальные значения
$y_0$ и $dy_0$ для $y$ и
$dy$, и порождает поток последовательных значений
$y$.
\end{exercise}
\begin{exercise}{3.79}\label{EX3.79}%
Обобщите процедуру {\tt solve-2nd} из
упражнения~\ref{EX3.78} так, чтобы с ее помощью можно было решать
\index{ru}{дифференциальное уравнение|второго порядка||||(упр.~3.79)}
дифференциальные уравнения второго порядка общего вида
${d^2 y}/{dt^2} = f (dy/dt, y)$.
\end{exercise}
\begin{exercise}{3.80}\label{EX3.80}%
\index{ru}{RLC-цепь последовательная||series RLC circuit|||(упр.~3.80)}\index{en}{series RLC circuit||RLC-цепь последовательная|||(упр.~3.80)}{\em Последовательная
RLC-цепь} (series RLC circuit)\index{ru}{электрические цепи, моделируемые с помощью потоков|||||(упр.~3.80)}\index{ru}{цепь электрическая|моделируемая с помощью потоков||||(упр.~3.80)}\index{ru}{схема|моделируемая с помощью потоков||||(упр.~3.80)}
состоит из резистора, конденсатора и катушки
индуктивности, соединенных последовательно, как показано на
рис.~\ref{P3.36}. Если сопротивление, индуктивность и
емкость равны, соответственно, $R$, $L$ и
$C$, то отношения между напряжением $v$ и током
$i$ на трех элементах описываются уравнениями
$$
v_R = i_R R
$$
$$
v_L = L \frac{di_L}{dt}
$$
$$
i_C = C \frac{dv_C}{dt}
$$
а  цепь диктует соотношения
$$
i_R = i_L = -i_C
$$
$$
v_C = v_L + v_R
$$
Сочетание этих условий показывает, что состояние цепи
(характеризуемое через $v_C$, напряжение на конденсаторе, и
$i_L$, ток через катушку) описывается парой
дифференциальных уравнений
$$
\frac{dv_C}{dt} = -\frac{i_L}{C}
$$
$$
\frac{di_L}{dt} = \frac{1}{L} v_C - \frac{R}{L} i_L
$$
Диаграмма потока сигналов, представляющая эту систему дифференциальных
ура\-внений, показана на рисунке~\ref{P3.37}.

Напишите процедуру {\tt RLC}, которая в качестве
аргументов берет параметры цепи $R$, $L$ и
$C$ и точность по времени $dt$.  Подобно
процедуре {\tt RC} из упражнения~\ref{EX3.73},
{\tt RLC} должна порождать процедуру, которая берет начальные
значения переменных состояния $v_{C_0}$ и
$i_{L_0}$ и порождает (через {\tt cons}) пару
потоков состояния $v_C$ и $i_L$.  С помощью
{\tt RLC} породите пару потоков, которая моделирует поведение
RLC-цепи c $R = 1$ ом, $C = 0.2$ фарад, $L
= 1$ генри, $dt = 0.1$ секунды, и начальными
значениями $i_{L_0} = 0$ ампер и $v_{C_0} = 10$
вольт.
\end{exercise}

\begin{cntrfig}
\input{xfig-mod/3-37.eepic}
\caption{Диаграмма потока сигналов для решения
уравнений последовательной RLC-цепи.}
\label{P3.37}
\end{cntrfig}

\paragraph{Нормальный порядок вычислений}

\index{ru}{задержанные вычисления|и нормальный  порядок вычислений||||}\index{ru}{нормальный порядок вычислений|и задержанные вычисления||||}Примеры из этого раздела показывают, как явное
использование {\tt delay} и {\tt force} сообщает
программированию большую гибкость, однако те же самые примеры
показывают, как наши программы от этого могут стать сложнее и
запутаннее.  Например, новая процедура {\tt integral} позволяет
моделировать системы с циклами, но теперь нам приходится помнить, что
звать ее надо с задержанным аргументом, и все процедуры, которые
пользуются {\tt integral}, должны это знать.  В результате мы
создали два клас\-са процедур: обычные и те, которым требуются
задержанные аргументы.  В общем случае создание новых классов
процедур требует от нас еще и создания новых классов процедур высших
порядков\footnote{Здесь мы получаем в Лиспе слабое отражение тех
сложностей, которые возникают при работе с процедурами высших порядков
\index{ru}{процедура высшего порядка|и сильная  типизация||||п} в
обыкновенных \index{ru}{тип данных|в сильно типизированных
  языках||||п}\index{ru}{язык программирования|сильно
  типизированный||||п}\index{ru}{сильно типизированный язык||strongly
  typed language|||п}\index{en}{strongly typed language||сильно
  типизированный язык|||п}сильно типизированных языках
вроде \index{ru}{Pascal (Паскаль)|сложности с процедурами высших порядков||||п}Паскаля.  В таких
языках программисту нужно указывать типы данных для аргументов и
результата каждой процедуры: число, логическое значение,
последовательность и~т.~д.  Следовательно, мы не можем выразить такую
абстракцию, как <<применить данную процедуру {\tt proc} ко всем
элементам последовательности>> в виде единой процедуры высшего порядка
вроде {\tt stream-map}.  Вместо этого нам потребуется отдельная
процедура для каждой комбинации типов аргументов и результата, которые
можно указать для {\tt proc}.  Практическая поддержка понятия
<<тип данных>> при наличии процедур высших порядков приводит ко
многим интересным проблемам.  Один из способов работы с ними
иллюстрирует язык  \index{ru}{ML|||||п}ML (Gordon,
Milner, and Wadsworth 1979),\index{ru}{Гордон, Майкл||Michael
  Gordon||n|п}\index{en}{Michael Gordon||Гордон,
  Майкл||n|п}\index{ru}{Милнер, Робин||Robin
  Milner||n|п}\index{en}{Robin Milner||Милнер,
  Робин||n|п}\index{ru}{Уодсворт, Кристофер||Christopher
  Wadsworth||n|п}\index{en}{Christopher Wadsworth||Уодсворт,
  Кристофер||n|п}
в котором <<полиморфные типы данных>> включают шаблоны для
преобразований между типами данных высшего уровня.  Более того, для
большинства процедур в ML типы данных явно не определяются
программистом.  Вместо этого в ML встроен механизм
\index{ru}{вывод типов||type inference|||п}\index{en}{type inference||вывод типов|||п}{\em вывода типов} (type inference), который при помощи
контекстной информации вычисляет типы данных для вновь определяемых
процедур.}.

Один из способов избежать необходимости вводить два
класса процедур состоит в том, чтобы заставить все процедуры принимать
задержанные аргументы.  Можно принять модель вычислений, в которой все
аргументы процедур автоматически задерживаются, и вынуждение
происходит только тогда, когда их значения реально нужны (например,
для выполнения элементарной операции). Таким образом наш язык станет
использовать нормальный порядок вычислений, который мы впервые
описали, когда разговор шел о подстановочной модели вычислений в
разделе~\ref{SUBST-MODEL-FOR-PROC-APPL}.  Переход к
нормальному порядку вычислений предоставляет нам изящный и
единообразный способ упростить использование задержанных вычислений, и
если бы нас интересовала только обработка потоков, было бы естественно
принять эту стратегию.  В
разделе~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION}, после того,
как мы изучим устройство вычислителя, мы увидим, как можно
преобразовать язык именно таким способом.  К сожалению, добавив
задержки в вызовы процедур, мы совершенно лишили себя возможности
строить программы, работа которых зависит от порядка событий, то есть
программы, использующие присваивание, изменяющие свои данные или
производящие ввод-вывод.  Одно-единственное использование
{\tt delay} в форме {\tt cons-stream} уже может привести к
неразберихе, как показано в упражнениях~\ref{EX3.51} и
\ref{EX3.52}.  Насколько известно, в языках
программирования изменение состояния и
задержанные вычисления плохо совместимы, и
поиск возможностей использовать одновременно и то, и другое является
активной областью исследований.

\subsection{Модульность функциональных программ\protect\\
  и модульность объектов}
\label{MODULARITY-OF-FUNCTIONAL-PROGRAMS-AND-MODULARITY-OF-OBJECTS}

\index{ru}{модульность|функциональных программ vs. объектов||||}\index{ru}{функциональное программирование|||||}Как мы видели в
разделе~\ref{THE-BENEFITS-OF-INTRODUCING-ASSIGNMENT}, одно из
основных преимуществ от введения присваивания состоит в том, что мы
можем повысить модульность своих систем при помощи инкапсуляции, или
<<сокрытия>>, частей большой системы во внутренних переменных.
Потоковые модели могут предоставить нам такой же уровень модульности
без использования присваивания.  В качестве примера мы можем заново
реализовать \index{ru}{моделирование методом Монте-Карло|формулировка в терминах потоков||||}  \index{ru}{пи ($\pi$)|оценка Чезаро||||} аппроксимацию
$\pi$ методом Монте-Карло,
которую мы рассматривали в
разделе~\ref{THE-BENEFITS-OF-INTRODUCING-ASSIGNMENT}, с точки
зрения обработки потоков.

Главная задача при обеспечении модульности состояла в том,
что нам хотелось спрятать внутреннее состояние генератора случайных
чисел от программ, которые пользуются случайными числами.  Мы начали с
процедуры {\tt rand-update}, последовательные
значения которой служили для нас источником случайных чисел, и уже с
ее помощью построили генератор случайных чисел:

\begin{Verbatim}[fontsize=\small]
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
\end{Verbatim}

При формулировке посредством потоков генератора случайных
чисел как такового не существует, имеется только поток случайных
чисел, полученных вызовами {\tt rand-update}:

\begin{Verbatim}[fontsize=\small]
(define random-numbers \index{ru}{бесконечный поток|случайных чисел||||}
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
\end{Verbatim}
С его помощью мы порождаем поток результатов испытаний Чезаро,
проведенных на последовательных парах потока случайных чисел:

\begin{Verbatim}[fontsize=\small]
(define cesaro-stream\index{ru}{cesaro-stream||||pd|}
  (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
                        random-numbers))

(define (map-successive-pairs f s)\index{ru}{map-successive-pairs||||pd|}
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
\end{Verbatim}
Поток {\tt cesaro-stream} подается на вход процедуре
{\tt monte-carlo}, которая порождает поток оценок вероятности.
Затем этот результат преобразуется, и получается поток оценок значения
$\pi$.  В этой версии программы не требуется параметра,
указывающего, сколько испытаний требуется проводить.  Более точные
оценки $\pi$ (полученные при большем количестве испытаний)
можно получить, дальше заглянув в поток {\tt pi}:

\begin{Verbatim}[fontsize=\small]
(define (monte-carlo experiment-stream passed failed)\index{ru}{monte-carlo|бесконечный поток|||pd|}
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))

(define pi
  (stream-map (lambda (p) (sqrt (/ 6 p)))
              (monte-carlo cesaro-stream 0 0)))
\end{Verbatim}
\index{ru}{модульность|через бесконечные     потоки||||}Такой подход достаточно модулен, поскольку
мы по-прежнему имеем возможность сформулировать общую процедуру
{\tt monte-carlo}, работающую с произвольными испытаниями.
Однако здесь нет ни присваивания, ни внутреннего состояния.
\begin{exercise}{3.81}\label{EX3.81}%
\index{ru}{генератор случайных  чисел|со сбрасыванием, потоковая версия||||(упр.~3.81)}%
В упражнении~\ref{EX3.6} обсуждалась
возможность обобщить генератор случайных чисел и позволить
пользователю сбрасывать последовательность случайных чисел, так, чтобы
можно было порождать воспроизводимые <<случайные>>
последовательности.  Постройте потоковый вариант такой же процедуры-генератора,
которая работает со входным потоком запросов вида
{\tt generate} --- породить новое число, либо
{\tt reset} --- сбросить последовательность в нужную точку, и
которая порождает требуемый поток случайных чисел.  Не используйте в
своем решении присваивание.
\end{exercise}
\begin{exercise}{3.82}\label{EX3.82}%
Переделайте на основе потоков упражнение~\ref{EX3.5} на
\index{ru}{определенный интеграл|приближенное вычисление методом
  Монте-Карло||||(упр.~3.82)}\index{ru}{Монте-Карло, интегрирование
  методом|формулировка в терминах
  потоков||||(упр.~3.82)}интегрирование методом Монте-Карло.
Потоковая версия процедуры
{\tt estimate-integral} не требует аргумента, который говорит,
сколько проводить испытаний.  Вместо этого она порождает поток оценок,
основанных на все большем количестве испытаний.\index{ru}{пи
  ($\pi$)|приближенное вычисление через интегрирование методом
  Монте-Карло||||(упр.~3.82)}\index{ru}{пи ($\pi$)|приближенное
  вычисление методом половинного деления||||(упр.~3.82)}
\end{exercise}

\paragraph{Взгляд на время в функциональном программировании}

\index{ru}{время|и функциональное программирование||||}\index{ru}{функциональное программирование|и время||||}Вернемся теперь к вопросам об объектах и
изменении, поднятым в начале этой главы, и рассмотрим их в новом
свете.  Мы ввели присваивание и изменяемые объекты, чтобы иметь
механизм для модульного построения программ, которые моделируют обладающие
состоянием системы.  Мы порождали вычислительные объекты с внутренними
переменными состояния и изменяли эти объекты при помощи присваивания.
Мы моделировали временн\'{о}е поведение объектов мира через временное
поведение соответствующих вычислительных объектов.

Теперь мы видим, что потоки дают альтернативный
способ моделирования объектов, обладающих внутренним состоянием.
Можно моделировать изменяющуюся величину, например, внутреннее
состояние какого-либо объекта, через поток, который представляет
динамику изменений состояния.  В сущности, с помощью
потоков мы представляем время явно, так что время в моделируемом мире
оказывается отделено от последовательности событий, происходящих во
время вычисления.  Действительно, благодаря наличию
{\tt delay} между имитируемым временем модели и
последовательностью событий при вычислении может быть весьма
мало общего.

Чтобы сопоставить эти два подхода к моделированию,
рассмотрим еще раз <<обработчик снятия денег>>, следящий за значением
баланса на банковском счету.  В
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT} мы реализовали
упрощенную версию такой программы обработки:

\begin{Verbatim}[fontsize=\small]
(define (make-simplified-withdraw balance)\index{ru}{make-simplified-withdraw||||pd|}
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
\end{Verbatim}
Вызовы {\tt make-simplified-withdraw} порождают вычислительные
объекты, и каждый из них содержит внутреннюю переменную
{\tt balance}, которая уменьшается при каждом обращении к объекту.
Этот объект принимает в качестве аргумента количество денег
{\tt amount}, а возвращает новый баланс.  Можно представить
себе, как пользователь банковского счета печатает последовательность
входных данных для такого объекта и рассматривает на экране
дисплея последовательность возвращаемых данных.

С другой стороны, можно смоделировать обработчик снятия
денег и в виде  \index{ru}{банковский счет|потоковая модель||||}процедуры,
которая принимает на входе баланс и поток
снимаемых сумм, а порождает поток последовательных балансов на счету:

\begin{Verbatim}[fontsize=\small]
(define (stream-withdraw balance amount-stream) \index{ru}{stream-withdraw||||pd|}
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
\end{Verbatim}

{\tt Stream-withdraw} реализует хорошо определенную
математическую фун\-кцию, выход которой полностью определяется входом.
Однако предположим, что вход {\tt amount-stream} есть поток
последовательных значений, вводимых пользователем, и что получающийся
поток балансов выводится на печать.  В таком случае, с точки зрения
пользователя, который печатает значения и смотрит на результаты,
потоковый процесс обладает тем же поведением, что и объект, созданный
при помощи {\tt make-simplified-withdraw}.  Однако в потоковой
версии нет ни присваивания, ни внутренней переменной состояния, и,
следовательно, \index{ru}{состояние|исчезновение в потоковой формулировке||||}она не вызывает никаких теоретических сложностей из
описанных в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}.  И все-таки
система обладает состоянием!

Это достижение достойно внимания.  Несмотря на то, что
{\tt stream-withdraw} реализует хорошо определенную
математическую функцию, поведение которой не меняется, у пользователя
создается впечатление, что он взаимодействует с системой, обладающей
изменяющимся состоянием.  Один из способов разрешить парадокс
заключается в том, чтобы понять, что именно существование пользователя
во времени навязывает системе состояние.  Если бы пользователь мог
принять более отстраненную точку зрения и думать в терминах потоков и
балансов, а не отдельных актов взаимодействия, система выглядела бы
как объект без состояния\footnote{Подобным образом в физике, когда мы наблюдаем за
движением частицы, мы говорим, что позиция (состояние) частицы
изменяется.  \index{ru}{мировая линия частицы|||||п}
Однако с точки зрения мировой линии частицы в
пространстве-времени никакого изменения нет.}.
{\sloppy

}

С точки зрения одной части сложного процесса кажется, что
другие его части меняются со временем.  Они содержат скрытое
изменчивое внутреннее состояние.  Если мы хотим писать программы,
моделирующие такой тип естественной декомпозиции нашего мира (как мы
видим его со своей точки зрения, будучи частицами этого мира) при помощи
структур в нашем компьютере, мы строим вычислительные объекты, не
являющиеся функциональными, --- они обязаны меняться со временем.  Мы
моделируем состояние при помощи внутренних переменных, и изменение
состояния мы моделируем через присваивание этим переменным.  Пойдя по
этому пути, мы делаем время выполнения вычислительной модели временем
мира, частью которого мы являемся, и так в нашем компьютере возникают
<<объекты>>.

Моделирование при помощи объектов --- мощная и интуитивно
понятная техника, во многом потому, что она соответствует восприятию
взаимодействия с миром, частью которого мы являемся.  Однако, как мы
неоднократно видели в этой главе, в таких моделях возникают неудобные
вопросы управления порядком событий и синхронизации множественных
процессов.  Возможность избежать этих проблем стимулировала развитие
\index{ru}{функциональное программирование|функциональный язык
  программирования||||}\index{ru}{язык
  программирования|функциональный||||}\index{ru}{функциональный язык
  программирования||functional programming
  language|||}\index{en}{functional programming
  language||функциональный язык программирования|||}{\em функциональных
языков программирования} (functional programming languages), в которых нет понятий присваивания и
изменяемых данных.  В таком языке все процедуры реализуют точно
определенные математические функции, поведение которых не меняется.
 \index{ru}{параллелизм|и функциональное программирование||||} \index{ru}{функциональное программирование|и параллельность||||}Функциональный подход
весьма привлекателен при
работе с параллельными системами\footnote{Джон Бэкус, \index{ru}{Fortran (Фортран)|изобретатель||||п} изобретатель Фортрана, привлек внимание к
функциональному программированию, когда в 1978 году получил премию
Тьюринга Американской Ассоциации по Вычислительным Машинам (ACM).  В своей
инаугурационной речи
(Backus 1978)\index{ru}{Бэкус, Джон||John Backus||n|п}\index{en}{John Backus||Бэкус, Джон||n|п}
он горячо отстаивал
функциональный подход.  Хороший обзор функционального программирования
дается в книгах Henderson 1980\index{ru}{Хендерсон, Питер||Peter Henderson||n|п}\index{en}{Peter Henderson||Хендерсон, Питер||n|п}
и Darlington, Henderson, and Turner~1982.\index{ru}{Дарлингтон,
  Джон||John Darlington||n|п}\index{en}{John Darlington||Дарлингтон,
  Джон||n|п}\index{ru}{Тёрнер, Дэвид||David
  Turner||n|п}\index{en}{David Turner||Тёрнер, Дэвид||n|п}}.

\begin{cntrfig}
\input{xfig-mod/3-38.eepic}
\caption{Совместный банковский счет, смоделированный через слияние двух потоков
событий-транзакций.}
\label{P3.38}
\end{cntrfig}

С другой стороны, при более внимательном взгляде мы
обнаружим, что и функциональные модели не избавляют от проблем,
связанных со временем.  Одна из самых болезненных возникает, когда нам
нужно проектировать интерактивные системы, особенно такие, которые
моделируют взаимодействие между независимыми сущностями.  К примеру,
рассмотрим еще раз реализацию банковской системы, которая позволяет
иметь совместные счета.  В традиционной системе с присваиванием и
объектами информация о том, что у Петра и Павла есть общий счет,
моделировалась бы тем, что и Петр, и Павел посылали бы заказы на
транзакции одному и тому же объекту-банковскому счету, как мы видели в
разделе~\ref{THE-COSTS-OF-INTRODUCING-ASSIGNMENT}.  С точки зрения
потоков, где <<объекты>> сами по себе не существуют, банковский счет,
как мы уже указывали, может моделироваться в виде процесса,
работающего с потоком заказов на транзакции и порождающего поток
реакций.  Соответственно, информация о том, что Петр и Павел совместно
владеют счетом, может моделироваться путем смешения потока
заказов Петра на транзакции с потоком Павла и направления слитого потока в
 \index{ru}{банковский счет|совместный,      смоделированный с помощью потоков||||}процесс-поток
банковского счета, как показано на
рисунке~\ref{P3.38}.

Проблему в этой формулировке вызывает понятие
\index{ru}{бесконечный
  поток|слияние||||}\index{ru}{слияние||merge|||}\index{en}{merge||слияние|||}{\em слияния} (merge).
Неверным решением будет просто
брать по очереди один заказ от Петра и один от Павла.  Допустим, что
Павел очень редко обращается к счету.  Не следует заставлять Петра
ждать, пока Павел обратится к счету, прежде чем он сможет осуществить
вторую транзакцию.  Как бы ни было реализовано слияние, оно должно
чередовать потоки транзакций так, чтобы соответствовать <<реальному
времени>> с точки зрения Петра и Павла, в том смысле, что если Петр и
Павел встретятся, то они могут согласиться, что определенные
транзакции произошли до встречи, а определенные после\footnote{Заметим, что для любых двух потоков в принципе
существует более одного возможного способа чередования. Так что с
технической точки зрения \index{ru}{бесконечный поток|слияние как отношение||||п}<<слияние>> не функция, а
отношение --- ответ
не является детерминистской функцией аргументов.  Мы уже упоминали (в
примечании \ref{F3.39}), что \index{ru}{недетерминизм в поведении параллельных  программ|||||п}
недетерминизм имеет
существенное значение при работе с параллельными процессами.
Отношение слияния показывает тот же самый недетерминизм с
функциональной точки зрения.  В
разделе~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING} мы
рассмотрим еще одну точку зрения на \linebreak
недетерминизм.}
Это в точности то же самое ограничение, с которым нам приходилось
сталкиваться в
разделе~\ref{THE-NATURE-OF-TIME-IN-CONCURRENT-SYSTEMS},
где у нас
возникла необходимость ввести явную синхронизацию, чтобы добиться
<<правильного>> порядка событий при параллельной обработке объектов,
обладающих состоянием.  Таким образом, при попытке поддержать
функциональный стиль необходимость сливать потоки ввода от различных
агентов опять привносит те самые проблемы, от которых функциональный
стиль должен был нас \mbox{избавить}.
%\looseness=2

В начале этой главы мы поставили цель научиться строить
вычислительные модели, чья структура соответствует нашему
восприятию реального мира, который мы моделируем.  Мы можем
моделировать мир либо как собрание ограниченных во времени
взаимодействующих объектов, обладающих состоянием, либо же
как единую, вневременную, лишенную состояния сущность.
Каждая из этих точек зрения имеет свои преимущества, но ни одна из них
не удовлетворяет нас полностью.  Время великого объединения пока не
\mbox{настало}\footnote{Объектная модель строит приближенное описание мира,
разделяя его на отдельные фрагменты.  Функциональная модель не проводит
\index{ru}{модульность|границы модулей, проведенные по границам объектов||||п} границ модулей по границам объектов.  Объектная модель полезна тогда,
когда раздельное состояние <<объектов>> намного больше, чем состояние,
общее для всех или некоторых из них.  Примером области, где объектный
взгляд не работает, является
\index{ru}{квантовая механика||quantum mechanics|||п}\index{en}{quantum mechanics||квантовая механика|||п}квантовая механика, где попытки думать об объектах
как отдельных частицах ведут к парадоксам и недоразумениям.  Объединение
объектного взгляда с функциональным может иметь отношение не столько к
программированию, сколько к фундаментальным вопросам эпистемологии.
}.
%\looseness=1

%\end{document}
