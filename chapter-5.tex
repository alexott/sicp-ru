\chapter{Вычисления на регистровых машинах}
\label{COMPUTING-WITH-REGISTER-MACHINES}
%\markboth{Глава 5 \qquad Вычисления на регистровых машинах}{}
\thispagestyle{empty}
\epigraph{

Моя цель~--- показать, что небесная машина не некое божественное
живое существо,~а скорее часовой механизм (а тот, кто верит, что у
часов есть душа, приписывает славу творца творению), 
поскольку почти все из ее многочисленных движений вызываются
простейшей материальной силой, так же, как все движения часов
вызываются весом гири.
\index{ru}{Кеплер, Иоганн||Johannes Kepler||n|}%
\index{en}{Johannes Kepler||Кеплер, Иоганн||n|}}%
{Иоганн Кеплер \\
(письмо к Герварту фон Гогенбургу, 1605)}
%MLR% указать переводчика.

Эта книга начинается с изучения процессов и с описания процессов в
терминах процедур, написанных на Лиспе.  Чтобы объяснить значение этих
процедур, мы последовательно использовали несколько моделей
вычисления: подстановочную модель из 
главы~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES}, модель с
окружениями из главы~\ref{MODULARITY-OBJECTS-AND-STATE} и
метациклический интерпретатор из главы~\ref{METALINGUISTIC-ABSTRACTION}.  
Изучая последний,
мы по большей части сняли покров тайны с деталей интерпретации
лиспоподобных языков.  Однако даже
метациклический интерпретатор оставляет многие вопросы без ответа,
поскольку он не проясняет механизмы управления Лисп-системы.  Например,
интерпретатор не показывает, как при вычислении подвыражения удается
вернуть значение выражению, это значение использующему, или почему одни
рекурсивные процедуры порождают итеративные процессы (то есть
занимают неизменный объем памяти),~в то время как другие процедуры
порождают рекурсивные процессы.  Эти вопросы остаются без ответа
потому, что метациклический интерпретатор сам по себе является
программой на Лиспе,~а следовательно, наследует управляющую структуру
нижележащей Лисп-системы. Чтобы предоставить более полное описание
управляющей структуры вычислителя Лиспа, нам нужно работать на более
элементарном уровне, чем сам Лисп.

В этой главе мы будем описывать процессы~в терминах пошаговых
операций традиционного компьютера. Такой компьютер, или 
\index{ru}{регистровая машина||register machine|||}\index{en}{register machine||регистровая машина|||}{\em регистровая машина} (register machine),
последовательно выполняет \index{ru}{команда||instruction|||}\index{en}{instruction||команда|||}{\em команды} (instructions),
которые работают с ограниченным числом элементов памяти, называемых
\index{ru}{регистр||register|||}\index{en}{register||регистр|||}{\em регистрами} (registers).  Типичная команда регистровой
машины применяет элементарную операцию к содержимому нескольких
регистров и записывает результат еще~в один регистр.  Наши описания
процессов, выполняемых регистровыми машинами, будут очень похожи на
<<машинный язык>> обыкновенных компьютеров. Однако вместо того, чтобы
сосредоточиться на машинном языке какого-то конкретного компьютера, мы
рассмотрим несколько процедур на Лиспе и спроектируем специальную
регистровую машину для выполнения каждой из этих процедур.  Таким
образом, мы будем решать задачу с точки зрения архитектора аппаратуры,
а не с точки зрения программиста на машинном языке компьютера.  При
проектировании регистровых машин мы разработаем механизмы для
реализации важных программистских конструкций, таких, как рекурсия.
Кроме того, мы представим язык для описания регистровых машин.  В
разделе~\ref{A-REGISTER-MACHINE-SIMULATOR} мы реализуем
программу на Лиспе, которая с помощью этих описаний имитирует
проектируемые нами машины.

Большинство элементарных операций наших регистровых машин очень
просты.  Например, такая операция может складывать числа, взятые из
двух регистров, и сохранять результат~в третьем.  Несложно описать
устройство, способное выполнять такие операции.  Однако для работы со
списковыми структурами мы будем использовать также операции
{\tt car}, {\tt cdr} и {\tt cons},~а они требуют
сложного механизма выделения памяти.  В 
разделе~\ref{STORAGE-ALLOCATION-AND-GARBAGE-COLLECTION} мы изучаем
их реализацию на основе более простых операций.

В разделе~\ref{THE-EXPLICIT-CONTROL-EVALUATOR},
накопив опыт выражения простых процессов~в виде регистровых машин, мы
спроектируем машину, которая реализует алгоритм, описываемый
метациклическим интерпретатором из 
раздела~\ref{THE-METACIRCULAR-EVALUATOR}.  Таким образом, окажется
заполненным пробел~в нашем понимании того, как интерпретируются
выражения языка Scheme, поскольку будет представлена явная модель
механизмов управления вычислителя. В 
разделе~\ref{COMPILATION} мы рассмотрим простой компилятор,
переводящий программы на Scheme~в последовательности команд,
которые можно впрямую выполнить с помощью регистров и операций
регистровой машины-вычислителя.
\section{Проектирование регистровых машин}
\label{DESIGNING-REGISTER-MACHINES}


\index{ru}{регистровая машина|проектирование||||} Чтобы спроектировать регистровую машину, требуется описать ее
\index{ru}{регистровая машина|пути данных||||} 
\index{ru}{пути данных регистровой машины||data paths for register machine|||}\index{en}{data paths for register machine||пути данных регистровой машины|||}{\em пути данных} (data paths), то
есть регистры и \index{ru}{операция|в регистровой машине||||} операции,~а 
\index{ru}{регистровая машина|контроллер||||} 
также 
\index{ru}{контроллер для регистровой машины||controller for register machine|||}
\index{en}{controller for register machine||контроллер для регистровой машины|||}
{\em контроллер} (controller), который управляет
последовательностью этих операций.  Чтобы продемонстрировать
строение простой регистровой машины, рассмотрим алгоритм Евклида
для вычисления наибольшего общего делителя (НОД)
двух натуральных чисел.  Как мы видели~в 
разделе~\ref{GREATEST-COMMON-DIVISORS}, 
\index{ru}{Евклида алгоритм|||||}
\index{ru}{алгоритм|Евклида||||}
алгоритм Евклида можно
реализовать~в виде итеративного процесса, который описывается
следующей процедурой:
\index{ru}{gcd|регистровая машина|||p|}

\begin{Verbatim}[fontsize=\small]
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{Verbatim}

Машина, реализующая алгоритм, должна отслеживать 
два числовых значения, $a$ и $b$. Поэтому
предположим, что эти числа хранятся~в двух регистрах с такими же именами. Основные
требуемые операции~--- это проверка, не является ли содержимое регистра
{\tt b} нулем, и вычисление остатка от деления содержимого
регистра {\tt a} на содержимое регистра {\tt b}.
Операция вычисления остатка~--- сложный процесс, однако пока что
предположим, что у нас есть элементарное устройство, вычисляющее
остатки. В каждом цикле алгоритма вычисления НОД содержимое регистра
{\tt a} требуется заменить содержимым регистра {\tt b},
а содержимое регистра {\tt b} следует заменить на остаток от
деления старого содержимого {\tt a} на старое содержимое
{\tt b}.  Было бы удобно, если бы можно было производить эти
замены одновременно, однако для нашей модели регистровых машин мы
предположим, что на каждом шаге можно присвоить новое значение только
одному регистру.  Чтобы произвести замены, наша машина использует
третий <<временный>> регистр, который мы назовем
{\tt t}. (Сначала мы помещаем остаток~в {\tt t}, затем
помещаем содержимое {\tt b}~в {\tt a}, и наконец
переносим остаток, хранимый~в {\tt t},~в {\tt b}.)

Можно изобразить регистры и операции, требуемые нашей
машине, при помощи 
\index{ru}{пути данных регистровой машины|диаграмма путей данных||||} 
\index{ru}{регистровая машина|диаграмма путей данных||||}
диаграммы путей данных, показанной на 
рисунке~\ref{P5.1}. Регистры ({\tt a}, {\tt b} и
{\tt t}) на этой диаграмме изображаются~в виде
прямоугольников.  Каждый способ присвоить регистру значение
обозначается стрелкой, указывающей из источника данных на регистр, со
значком Х позади головки. Можно считать этот Х кнопкой, которая при
нажатии позволяет значению из источника <<перетечь>>~в указанный
регистр.  Метка рядом~--- это имя для кнопки.
Имена эти произвольны, и их можно подбирать с мнемоническим
значением (например, {\tt a<-b} обозначает нажатие кнопки,
которая присваивает содержимое регистра {\tt b} регистру
{\tt a}). Источником данных для регистра может служить другой
регистр (как~в случае присваивания {\tt a<-b}), результат
операции (как~в случае присваивания {\tt t<-r}) или константа
(встроенное значение, которое нельзя изменять и которое представляется
на диаграмме путей данных~в виде треугольника со значением
внутри).

Операция, которая вычисляет значение на основе констант и
содержимого регистров, представляется на диаграмме путей данных в
виде трапеции, содержащей имя операции.  Например, фигура,
обозначенная на рисунке~\ref{P5.1} как {\tt rem},
представляет операцию, вычисляющую остаток от деления содержимых
регистров {\tt a} и {\tt b}, к которым она
подсоединена.  Стрелки (без кнопок) указывают из входных регистров и
констант на фигуру,~а другие стрелки связывают результат операции с
регистрами.  Сравнение изображается~в виде круга, содержащего имя
теста.  К примеру,~в нашей машине НОД имеется операция, которая
проверяет, не равно ли содержимое регистра {\tt b} нулю.  У
\index{ru}{регистровая машина|тест||||} 
\index{ru}{тест, операция~в регистровой машине||test|||}
\index{en}{test||тест, операция~в регистровой машине|||}
теста тоже есть входные стрелки, ведущие из входных регистров и
констант, но у него нет исходящих стрелок; его значение используется
контроллером,~а не путями данных.  В целом, диаграмма путей данных
показывает регистры и операции, которые нужны машине, и как они должны
быть связаны.  Если мы рассматриваем стрелки как провода,~а кнопки Х
как переключатели, то диаграмма путей данных оказывается очень
похожа на схему машины, которую можно было бы построить из
электронных деталей.

Для того, чтобы пути данных вычисляли НОД, нужно нажимать
кнопки~в правильной последовательности.  Мы будем описывать эту
последовательность с помощью \index{ru}{контроллер для регистровой машины|диаграмма||||} \index{ru}{регистровая машина|диаграмма контроллера||||} диаграммы
контроллера, показанной на 
рисунке~\ref{P5.2}.  Элементы диаграммы контроллера
показывают, как следует работать с компонентами путей данных.
Прямоугольные блоки~в такой диаграмме указывают, на какие кнопки
следует нажимать,~а стрелки описывают последовательный переход от
одного шага к другому.  Ромб на диаграмме обозначает выбор.  Произойдет
переход по одной из двух исходящих стрелок,~в зависимости от значения
того теста~в потоке данных, имя которого указано~в ромбе.  Можно
интерпретировать контроллер с помощью физической аналогии: представьте
себе, что диаграмма~--- это лабиринт,~в котором катается шарик. Когда
шарик закатывается~в прямоугольник, он нажимает на кнопку, имя которой
в прямоугольнике написано.  Когда шарик закатывается~в узел выбора (например,
тест ${\tt b} = 0$), он покидает этот узел по
стрелке, которую определяет результат указанного теста.  Взятые
вместе, пути данных и контроллер полностью определяют машину для
вычисления НОД.  Мы запускаем контроллер (катящийся шарик)~в месте,
обозначенном {\tt start}, поместив предварительно числа в
регистры {\tt a} и {\tt b}.  Когда контроллер достигает
точки, помеченной {\tt done},~в регистре {\tt a}
оказывается значение НОД.


\begin{cntrfig}
\input{xfig-mod/5-1.eepic}
\caption{Пути данных~в машине НОД.}
\label{P5.1}
\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/5-2.eepic}
%{\small начало\\
%да\\
%конец\\
%нет\\}
\caption{Контроллер машины НОД.}
\label{P5.2}

\end{cntrfig}
\begin{exercise}{5.1}\label{EX5.1}%
Спроектируйте регистровую машину для вычисления факториалов
с помощью итеративного алгоритма, задаваемого следующей процедурой.
Нарисуйте для этой машины диаграммы путей данных и контроллера.
\index{ru}{factorial|регистровая машина (итеративная)|||p|(упр.~5.1)}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{Verbatim}
\end{exercise}

\subsection{Язык для описания регистровых машин}
\label{A-LANGUAGE-FOR-DESCRIBING-REGISTER-MACHINES}

\index{ru}{регистровая машина|язык для описания||||} 
Диаграммы путей данных и контроллера адекватно
представляют простые машины вроде машины НОД, но для описания сложных
машин вроде интерпретатора Лиспа они непригодны.  Чтобы можно было
работать со сложными машинами, мы создадим язык, который представляет
в текстовом виде всю информацию, содержащуюся~в диаграммах путей
данных и контроллера.  Начнем с нотации, которая впрямую отражает
диаграммы.

Мы определяем пути данных ({\tt data-paths}) машины, описывая регистры
({\tt registers}) и
операции ({\tt operations}).  Чтобы описать регистр, мы даем
ему имя ({\tt name}) и указываем кнопки ({\tt buttons}),
которые присваивают ему значение.  Каждой из этих кнопок мы даем имя
({\tt name}) и
указываем источник ({\tt source}) для данных, которые попадают~в регистр, управляемый
кнопкой.  Источником может служить регистр ({\tt register}),
константа ({\tt constant}) или операция ({\tt operation}).
Для описания операции нам нужно дать ей имя и указать входы
({\tt inputs})~--- регистры или константы.

Контроллер машины мы определяем как последовательность
\index{ru}{язык регистровых машин|команды||||}
\index{ru}{команда||instruction|||}
\index{en}{instruction||команда|||}
{\em команд} (in\-struc\-ti\-ons) с 
\index{ru}{метка||label|||}
\index{en}{label||метка|||}
{\em метками} (labels),
\index{ru}{label (в регистровой машине)||||p|}
\index{ru}{язык регистровых машин|\texttt{метка}||||}
которые определяют
\index{ru}{язык регистровых машин|точки входа||||}
\index{ru}{точка входа||entry point|||}
\index{en}{entry point||точка входа|||}
{\em точки входа} (entry points).  Есть
следующие виды команд:

\begin{plainlist}


\item
Имя кнопки на пути данных, которую следует нажать и
присвоить регистру значение. (Это соответствует прямоугольнику на
диаграмме контроллера.)

\item
Команда {\tt test}, 
\index{ru}{test (в регистровой машине)||||p|}
\index{ru}{язык регистровых машин|\texttt{test}||||}
которая выполняет указанный тест.

\item
Условный переход (команда {\tt branch}) 
\index{ru}{branch (в регистровой машине)||||p|}
\index{ru}{язык регистровых машин|\texttt{branch}||||}
в место, определяемое
\index{ru}{язык регистровых машин|\texttt{label}||||}
меткой контроллера, на основании предыдущего
теста. ({\tt Test} и {\tt branch} вместе соответствуют
ромбу на диаграмме контроллера.)  Если тест дает результат <<ложь>>, контроллер должен
выполнять следующую команду~в последовательности. В противном случае
он должен выполнять команду, которая следует за меткой.

\item
Безусловный переход (команда  \index{ru}{язык регистровых машин|\texttt{goto}||||}{\tt goto}),
\index{ru}{goto (в регистровой машине)||||p|}
указывающий метку, с которой следует продолжить выполнение.
\end{plainlist}
Машина начинает работу с начала последовательности команд контроллера
и заканчивает, когда выполнение достигает конца последовательности.
Кроме тех случаев, когда переход изменяет поток управления, команды
выполняются по порядку, так, как они перечислены.

На рисунке~\ref{P5.3} изображена описанная на
нашем языке машина НОД.  Этот пример служит не более чем намеком на степень
общности таких описаний, поскольку машина НОД~--- очень простой
случай: у каждого регистра всего по одной кнопке, и каждая кнопка
используется~в контроллере только один раз.

\begin{cntrfig}
{\small 
\begin{Verbatim}[fontsize=\small]
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))

 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0))))

 (controller
  test-b                        {\em ; метка}
    (test =)                    {\em ; тест}
    (branch (label gcd-done))   {\em ; условный переход}
    (t<-r)                      {\em ; нажатие кнопки}
    (a<-b)                      {\em ; нажатие кнопки}
    (b<-t)                      {\em ; нажатие кнопки}
    (goto (label test-b))       {\em ; безусловный переход}
  gcd-done))                    {\em ; метка}
\end{Verbatim}
}\caption{Описание машины НОД.}
\label{P5.3}

\end{cntrfig}

К сожалению, такое описание неудобно читать.  Чтобы понимать
команды контроллера, нам все время приходится смотреть на определения
имен кнопок и операций,~а чтобы понять, что делают операции,
приходится обращаться к определениям имен операций.  Поэтому мы изменим
свой способ записи и сольем информацию из описания контроллера и описания путей
данных, так, чтобы видеть их одновременно.

В этой новой форме записи мы заменим
произвольные имена кнопок и операций на описание их поведения. 
\index{ru}{язык регистровых машин|\texttt{reg}||||}
\index{ru}{язык регистровых машин|\texttt{op}||||}
\index{ru}{язык регистровых машин|\texttt{assign}|register machine language|||}
\index{en}{register machine language||язык регистровых машин|\texttt{assign}||}
То есть, вместо того, чтобы говорить (в контроллере) <<нажать кнопку
{\tt t<-r}>> и отдельно (в путях данных) <<кнопка
{\tt t<-r} присваивает регистру {\tt t} значение
операции {\tt rem}>>,~а также <<входы операции
{\tt rem}~--- это  содержимое регистров {\tt a} и
{\tt b}>>, мы будем говорить (в контроллере) <<нажать кнопку,
которая  присваивает регистру {\tt t} результат операции
{\tt rem} от содержимого регистров {\tt a} и
{\tt b}>>.
\index{ru}{язык регистровых машин|\texttt{const}||||}
Подобным образом, вместо <<выполнить тест
{\tt =}>> (в контроллере) и отдельно (в путях
данных) <<тест {\tt =} применяется к содержимому регистра
{\tt b} и константе 0>>, будем говорить <<выполнить тест
{\tt =} над содержимым регистра {\tt b} и константой
0>>. Описание путей данных мы будем опускать, оставляя только
последовательность команд контроллера.  Таким образом, машину НОД
можно описать так:
\index{ru}{assign (в регистровой машине)||||p|}
\index{ru}{const (в регистровой машине)||||p|}
\index{ru}{op (в регистровой машине)||||p|}
\index{ru}{reg (в регистровой машине)||||p|}

\pagebreak

\begin{Verbatim}[fontsize=\small]
(controller 
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
\end{Verbatim}

Запись~в такой форме проще читать, чем описания на
разновидности языка, показанной на рисунке~\ref{P5.3}, но
есть у нее и недостатки: 

\begin{plainlist}


\item
Для больших машин такие описания длиннее, поскольку
полные определения элементов путей данных повторяются каждый раз, как
эти элементы упоминаются~в последовательности команд контроллера. (В
примере с НОД этой проблемы не возникает, поскольку каждая операция и
каждая кнопка используются только по разу.)  Более того, повторение описаний
путей данных скрывает структуру этих путей~в машине; для больших машин
становится сложно определить, сколько~в них регистров, операций и кнопок, и как
они связаны.

\item
Поскольку команды контроллера~в определении машины
похожи на выражения Лиспа, легко забыть, что это не произвольные
Лисп-выражения.  Можно описывать только разрешенные операции машины.
Например, операции впрямую могут работать только с константами и
содержимым регистров,~а не с результатами других операций.
\end{plainlist}
Несмотря на указанные недостатки, мы будем использовать такой язык описания
регистровых машин на всем протяжении этой главы, поскольку нас в
большей мере будет занимать понимание работы контроллеров, чем
понимание элементов и связей~в путях данных.  Следует, однако,
помнить, что проектирование путей данных~--- ключевой элемент в
разработке настоящих машин.
\begin{exercise}{5.2}%%
\label{EX5.2}%
С помощью языка регистровых машин опишите итеративную
факториал-машину из упражнения~\ref{EX5.1}.\index{ru}{factorial|регистровая машина (итеративная)|||p|(упр.~5.2)}
\sloppy
\end{exercise}

\paragraph{Действия}

\index{ru}{регистровая машина|действия||||}
Давайте теперь изменим машину НОД так, чтобы можно было
вводить числа, НОД которых мы хотим получить, и видеть результаты,
напечатанные на терминале.  Мы не будем обсуждать, как построить
машину для считывания и печати,~а предположим (как и с процедурами
{\tt read} и {\tt display}~в Scheme), что эти действия
доступны как элементарные операции\footnote{Такое предположение покрывает большую и сложную
область.  Обычно значительная часть реализации Лисп-систем посвящена
работе ввода и вывода.
}.

\index{ru}{read, операция регистровой машины||||p|}
{\tt Read} подобна операциям, которые мы 
использовали ранее, поскольку она порождает значение, и его можно
сохранить~в регистре.  Однако {\tt read} не принимает входа ни
из каких регистров; ее значение зависит от событий, происходящих за
пределами тех компонентов машины, проектированием которых мы заняты.
Мы позволим операциям нашей машины вести себя таким образом, и,
следовательно, будем рисовать {\tt read} и
изображать ее~в языке описания так же, как любую другую операцию,
вычисляющую значение.

 \index{ru}{print, операция~в регистровой машине||||p|}
{\tt Print}, с другой стороны, фундаментальным
образом отличается от тех операций, которыми мы до сих пор пользовались:
она не порождает результата, который можно было бы поместить
в регистр.  Хотя она и производит эффект, этот эффект не касается тех
частей машины, которые мы проектируем.  Этот тип операций мы будем
называть \index{ru}{действия,~в регистровой машине||actions, in register machine|||}\index{en}{actions, in register machine||действия,~в регистровой машине|||}{\em действиями} (actions).  На диаграмме путей
данных мы будем представлять действие так же, как и операции,
вычисляющие значение~--- как трапецию с именем действия.  В этот
элемент входят стрелки из входов (регистров или констант).  Кроме
того, мы связываем с действием кнопку.  Нажатие кнопки заставляет
действие совершиться.  Чтобы скомандовать контроллеру нажать кнопку
действия, мы вводим новый тип команды {\tt perform}.
\index{ru}{perform (в регистровой машине)||||p|}
 \index{ru}{язык регистровых машин|\texttt{perform}||||}
Таким образом, действие по распечатке содержимого регистра {\tt a}
представляется~в последовательности контроллера командой

\begin{Verbatim}[fontsize=\small]
(perform (op print) (reg a))
\end{Verbatim}

На рисунке~\ref{P5.4} показаны пути данных и
контроллер для новой машины НОД.  Вместо того, чтобы останавливать
машину после печати ответа, мы приказываем ей начать сначала, так что
она~в цикле считывает пару чисел, вычисляет их НОД и печатает
результат.  Такая структура подобна управляющим циклам, которые мы
использовали~в интерпретаторах из главы~\ref{METALINGUISTIC-ABSTRACTION}.


\begin{cntrfig}
\input{xfig-mod/5-4.eepic}
\begin{Verbatim}[fontsize=\small]
(controller
 gcd-loop
   (assign a (op read))
   (assign b (op read))
 test-b
   (test (op =) (reg b) (const 0)
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
gcd-done
  (perform (op print) (reg a))
  (goto (label gcd-loop)))
\end{Verbatim}
\caption{Машина НОД, которая считывает входные числа и
печатает результат.}
\label{P5.4}

\end{cntrfig}

\subsection{Абстракция~в проектировании машин}
\label{ABSTRACTION-IN-MACHINE-DESIGN}


\index{ru}{абстракция|при проектировании регистровых машин||||}
Часто~в определении машины мы будем использовать
<<элементарные>> операции, которые на самом деле весьма сложны.
Например,~в разделах~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}
и \ref{COMPILATION} мы будем рассматривать операции с
окружениями Scheme как элементарные.  Такая абстракция полезна,
поскольку она позволяет нам игнорировать детали частей машины, так что
мы можем сосредоточиться на других сторонах общего плана. Однако,
хотя мы и скрываем существенную часть сложности, это не означает, что
проект машины нереалистичен.  Сложные <<примитивы>> всегда можно заменить 
более простыми операциями.

Рассмотрим машину НОД.  В ней содержится команда, которая
вычисляет остаток от деления содержимого регистров {\tt a} и
{\tt b} и сохраняет результат~в регистре {\tt t}.  Если
мы хотим построить машину НОД без использования элементарной операции
взятия остатка, нам нужно указать, как вычислять остатки с помощью
более простых операций, например, вычитания.  Действительно, можно
написать на Scheme процедуру нахождения остатка таким образом:

\begin{Verbatim}[fontsize=\small]
(define (remainder n d)
  (if (< n d)
      n
      (remainder (- n d) d)))
\end{Verbatim}
Значит, мы можем заменить операцию взятия остатка~в машине НОД
операцией вычитания и тестом-сравнением.  На 
рисунке~\ref{P5.5} показаны пути данных и контроллер уточненной
машины. 

\pagebreak

Команда

\begin{Verbatim}[fontsize=\small]
(assign t (op rem) (reg a) (reg b))
\end{Verbatim}
в определении контроллера НОД заменяется на последовательность команд,
содержащую цикл, как показано на рисунке~\ref{P5.6}.


\begin{figure}[p]
\begin{center}
\input{xfig-mod/5-5.eepic}
%{\small начало\\
%конец
%да (2 раза)\\
%нет (2 раза)}
\caption{Пути данных и контроллер уточненной машины НОД.}
\label{P5.5}
\end{center}
\end{figure}


\begin{cntrfig}
\begin{Verbatim}[fontsize=\small]
(controller
 test-b
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (reg a))
rem-loop
 (test (op <) (reg t) (reg b))
 (branch (label rem-done))
 (assign t (op -) (reg t) (reg b))
 (goto (label rem-loop))
rem-done
 (assign a (reg b))
 (assign b (reg t))
(goto (label test-b))
gcd-done)
\end{Verbatim}
\caption{Последовательность команд контроллера машины
НОД с рисунка~\ref{P5.5}.}
\label{P5.6}

\end{cntrfig}
\begin{exercise}{5.3}%%
\label{EX5.3}%
Спроектируйте машину для вычисления квадратных корней
методом Ньютона, как описано~в 
разделе~\ref{EXAMPLE-SQUARE-ROOTS-BY-NEWTONS-METHOD}:
\index{ru}{sqrt|регистровая машина|||p|(упр.~5.3)}
\samepage
\begin{Verbatim}[fontsize=\small]
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{Verbatim}
Для начала предположите, что операции {\tt good-enough?} и
{\tt improve} имеются как примитивы. Затем покажите, как
развернуть их с помощью арифметических операций.  Опишите каждую из
версий машины {\tt sqrt}, нарисовав диаграмму путей данных, и
написав определение контроллера на языке регистровых машин.
\end{exercise}

\subsection{Подпрограммы}
\label{SUBROUTINES}

\index{ru}{регистровая машина|подпрограмма||||}
При проектировании машины для некоторого вычисления мы
часто предпочтем устроить так, чтобы компоненты ее разделялись
различными частями вычисления,~а не дублировались.  Рассмотрим машину,
которая включает~в себя два вычисления НОД~--- одно находит НОД
содержимого регистров {\tt a} и {\tt b},~а другое НОД
содержимого регистров {\tt c} и {\tt d}.  Для начала
можно предположить, что имеется элементарная операция
{\tt gcd},~а затем развернуть два экземпляра {\tt gcd} в
терминах более простых операций.  На рисунке~\ref{P5.7}
показаны только части получившихся путей данных, относящиеся к НОД.
Связи с остальными частями машины опущены.  Кроме того, на рисунке
показаны соответствующие сегменты последовательности команд
контроллера машины.


\begin{cntrfig}
\input{xfig-mod/5-7.eepic}
\begin{Verbatim}[fontsize=\small]
gcd-1
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-1))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-1))
after gcd-1
  .
  .
  .
gcd-2
(test (op =) (reg d) (const 0))
(branch (label after-gcd-2))
(assign s (op rem) (reg c) (reg d))
(assign c (reg d))
(assign d (reg s))
(goto (label gcd-2))
after-gcd-2
\end{Verbatim}
\caption{Части путей данных и последовательностей
команд контроллера для машины с двумя вычислениями НОД.}
\label{P5.7}

\end{cntrfig}

В этой машине два блока вычисления остатка и два блока
проверки на равенство.  Если повторяющиеся компоненты сложны, как,
например, блок вычисления остатка, такое построение машины окажется
неэкономным.  Можно избежать дублирования компонент путей данных, если
использовать для обоих вычислений НОД одни и те же компоненты, при
условии, что такое решение не повлияет на остальные вычисления большой
машины.  Если к тому времени, как контроллер добирается до
{\tt gcd-2}, значения~в регистрах {\tt a} и
{\tt b} не нужны (или если их можно временно сохранить в
каких-то еще регистрах), то мы можем изменить машину так, чтобы она
использовала регистры {\tt a} и {\tt b},~а не
{\tt c} и {\tt d}, при вычислении второго НОД, так же
как и при вычислении первого.  Так у нас получится
последовательность команд контроллера, показанная на 
рисунке~\ref{P5.8}.


\begin{cntrfig}
\begin{Verbatim}[fontsize=\small]
gcd-1
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-1))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (goto (label gcd-1))
after-gcd-1
.
.
.
gcd-2
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-2))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-2))
after-gcd-2  
\end{Verbatim}
\caption{Сегменты последовательности команд
контроллера для машины, которая использует одни и те же компоненты
путей данных для двух различных вычислений НОД.}
\label{P5.8}

\end{cntrfig}

Мы удалили одинаковые компоненты путей данных (так что они
снова стали такими, как на рисунке~\ref{P5.1}), но теперь в
контроллере содержатся две последовательности команд вычисления НОД,
которые различаются только метками. Было бы лучше заменить эти две
последовательности переходами к единой последовательности~--- 
\index{ru}{подпрограмма,~в регистровой машине||subroutine|||}\index{en}{subroutine||подпрограмма,~в регистровой машине|||}{\em подпрограмме} (subroutine),~---~в конце которой мы
возвращаемся обратно к нужному месту~в основной последовательности
команд.  Этого можно добиться так: прежде, чем перейти к
{\tt gcd}, мы помещаем определенное значение (0 или 1)~в особый
регистр, {\tt continue}.
\index{ru}{continue, регистр||||pd|}
В конце подпрограммы {\tt gcd}
мы переходим либо к {\tt after-gcd-1}, либо к
{\tt after-gcd-2},~в зависимости от значения из регистра
{\tt continue}. На рисунке~\ref{P5.9} показан
соответствующий сегмент получающейся последовательности команд
контроллера, который содержит только одну копию команд
{\tt gcd}.


\begin{cntrfig}
\begin{Verbatim}[fontsize=\small]
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
   .
   .
   .
 {\em ;; Прежде, чем перейти к {\tt gcd} из первого места, где}
 {\em ;; он нужен, заносим 0~в регистр {\tt continue}}
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 {\em ;;  Перед вторым использованием {\tt gcd} помещаем 1~в регистр {\tt continue}.}
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
\end{Verbatim}
\caption{Использование регистра {\tt continue} ради избежания повторяющейся
последовательности команд с рисунка~\ref{P5.8}.}
\label{P5.9}
\end{cntrfig}


\begin{cntrfig}
\begin{Verbatim}[fontsize=\small]
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   .
   .
   .
 {\em ;; Перед вызовом {\tt gcd} заносим~в {\tt continue}}
 {\em ;; метку, на которую {\tt gcd} должен вернуться.}
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 {\em ;;  Второй вызов{\tt gcd}, с другим продолжением.}
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
\end{Verbatim}
\caption{Присваивание регистру {\tt continue} меток упрощает и обобщает
стратегию с рисунка~\ref{P5.9}.}
\label{P5.10}

\end{cntrfig}

Для маленьких задач это разумный подход, однако если бы
в последовательности команд контроллера имелось много вызовов
вычисления НОД, он стал бы неудобен.  Чтобы решить, где продолжать
вычисление после подпрограммы {\tt gcd}, нам пришлось бы иметь
в контроллере тесты и переходы для всех мест, где используется
{\tt gcd}. Более мощный метод реализации подпрограмм состоит в
том, чтобы запоминать~в регистре {\tt continue} метку точки
входа~в последовательности контроллера, с которой выполнение должно
продолжиться, когда подпрограмма закончится.  Реализация этой
стратегии требует нового вида связи между путями данных и контроллером
регистровой машины: должно быть возможно присвоить регистру метку в
последовательности команд контроллера таким образом, чтобы это
значение можно было из регистра извлечь и с его помощью продолжить
выполнение с указанной точки входа.

Чтобы отразить эту возможность, мы расширим команду
{\tt assign}
\index{ru}{assign (в регистровой машине)|сохранение метки~в регистре|||p|}
языка регистровых машин и позволим присваивать
регистру~в качестве значения метку из последовательности команд
контроллера (как особого рода константу). Кроме того, мы расширим
команду {\tt goto} 
\index{ru}{goto (в регистровой машине)|переход на содержимое регистра|||p|}
и позволим вычислению продолжаться с точки входа,
которая описывается содержимым регистра,~а не только с точки входа,
описываемой меткой-константой.  С помощью этих двух команд мы можем
завершить подпрограмму {\tt gcd} переходом~в место, хранимое в
регистре {\tt continue}.  Это ведет к последовательности
команд, показанной на рисунке~\ref{P5.10}.

Машина,~в которой имеется более одной подпрограммы, могла
бы использовать различные регистры продолжения (например,
{\tt gcd-continue}, {\tt facto\-rial-con\-ti\-nue}), или же мы
могли бы для всех подпрограмм использовать один регистр
{\tt continue}.  Разделение регистра экономичнее, однако
тогда требуется отслеживать случаи, когда из одной подпрограммы
({\tt sub1}) зовется другая ({\tt sub2}).  Если
{\tt sub1} не сохранит значение {\tt continue} в
каком-то другом регистре, прежде чем использовать
{\tt continue} при вызове {\tt sub2}, то {\tt sub1}
не будет знать, откуда продолжать выполнение после ее конца.
Механизм, который разрабатывается~в следующем разделе для работы с
рекурсией, дает хорошее решение и для проблемы с вложенными вызовами
подпрограмм.

\subsection{Реализация рекурсии с помощью стека}
\label{USING-A-STACK-TO-IMPLEMENT-RECURSION}

\index{ru}{стек|для рекурсии~в регистровой машине||||}
\index{ru}{итеративный процесс|регистровая машина||||} 
\index{ru}{рекурсивный процесс|регистровая машина||||} 
\index{ru}{регистровая машина|стек||||} 
При помощи описанных до сих пор механизмов мы можем
реализовать любой итеративный процесс, задав регистровую машину, в
которой имеется по регистру на каждую переменную состояния процесса.
Машина выполняет цикл контроллера, изменяя при этом состояние
регистров, до тех пор, пока не окажется выполнено некоторое условие
окончания процесса.  В каждой точке последовательности команд
контроллера состояние машины (представляющее состояние итеративного
процесса) полностью определяется состоянием регистров (значением
переменных состояния).

 \index{ru}{итеративный процесс|vs. рекурсивный процесс||||} \index{ru}{рекурсивный процесс|vs. итеративный процесс||||}
Однако реализация рекурсивных процессов требует
дополнительного механизма.  Рассмотрим следующий рекурсивный метод
вычисления факториала, описанный нами~в 
разделе~\ref{LINEAR-RECURSION-AND-ITERATION}:
\index{ru}{factorial|регистровая машина (рекурсивная)|||p|}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{Verbatim}
Как мы видим из этой процедуры, вычисление $n!$ требует
вычисления $(n-1)!$.  Машина НОД, которая моделирует
процедуру

\begin{Verbatim}[fontsize=\small]
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{Verbatim}
также должна была вычислять НОД других чисел, помимо начальных
значений.  Однако между машиной НОД, которая сводит исходное
вычисление к вычислению другого НОД, и {\tt factorial}, в
котором нужно вычислить другой факториал как подзадачу, есть
существенная разница. В машине НОД
ответ, выдаваемый новым вычислением НОД~--- это и есть ответ на исходную
задачу.  Чтобы вычислить следующий НОД, мы просто помещаем новые
аргументы во входные регистры машины и заново используем ее пути
данных, прогоняя ту же самую последовательность команд контроллера.
Когда машина заканчивает решение последней задачи НОД, исходное вычисление
также заканчивается.

В случае с факториалом (и~в любом другом рекурсивном
процессе) ответ на подзадачу-факториал не является решением общей
задачи.  Значение, полученное для $(n-1)!$, требуется еще
домножить на $n$, чтобы получить окончательный ответ. Если
мы попытаемся сымитировать решение задачи НОД и решить
подзадачу-факториал, уменьшив регистр {\tt n} и запустив машину
заново, у нас больше не будет старого значения {\tt n}, на
которое можно было бы домножить результат.  Для решения подзадачи нам
бы потребовалась еще одна факториальная машина.  Во втором вычислении
факториала также есть подзадача-факториал, для нее требуется третья
факториальная машина, и так далее.  Поскольку внутри каждой
факториальной машины содержится другая факториальная машина,~в общей
машине должно содержаться бесконечное гнездо вложенных друг~в друга
машин,~а следовательно, ее нельзя построить из заранее заданного
конечного числа деталей.

Тем не менее реализовать факториальный процесс в
виде регистровой машины можно, если использовать одни и те же
компоненты для всех встроенных ее экземпляров. ~а именно, машина,
которая вычисляет $n!$, должна использовать одни и те же
детали для работы над подзадачей вычисления $(n-1)!$,
$(n-2)!$ и так далее.  Такое построение возможно,
поскольку, несмотря на то, что факториальный процесс требует для
своего вычисления неограниченное число одинаковых машин,~в каждый
момент времени только одна из этих машин активна.  Когда машина
встречает рекурсивную подзадачу, она может остановить работу над
основной задачей, использовать свои физические детали для решения
подзадачи,~а затем продолжить остановленное вычисление.

Содержимое регистров внутри подзадачи будет отличаться от
их значения~в главной задаче. (В нашем случае регистр {\tt n}
уменьшается на единицу.)  Чтобы суметь продолжить остановленное
вычисление, машина должна сохранить содержимое всех регистров, которые
ей понадобятся после того, как подзадача будет решена,~а затем
восстановить их, прежде чем возобновить работу.  В случае с
факториалом мы сохраним старое значение {\tt n} и восстановим
его, когда закончим вычисление факториала от уменьшенного значения
регистра {\tt n}\footnote{Казалось бы, незачем сохранять старое
{\tt n}; после того, как мы его уменьшим на единицу и решим
подзадачу, можно эту единицу добавить и восстановить старое значение.
Такая стратегия работает для факториала, но~в общем случае она
работать не может, поскольку старое значение регистра не всегда можно
вычислить на основании нового.
}.

Поскольку нет никакого априорного ограничения на число вложенных
рекурсивных вызовов, нам может понадобиться хранить произвольное
число значений регистров. Значения эти требуется восстанавливать в
порядке, обратном порядку их сохранения, поскольку~в гнезде рекурсий
последняя начатая подзадача должна завершаться первой.  Поэтому
требуется использовать для сохранения значений регистров 
\index{ru}{стек||stack|||}\index{en}{stack||стек|||}{\em стек} (stack), или структуру 
данных вида <<последним вошел, первым вышел>>.  Можно расширить язык
регистровых машин и добавить~в него стек, если ввести два новых вида
команд: значения заносятся на стек командой \index{ru}{язык регистровых машин|\texttt{save}||||}  \index{ru}{save (в регистровой машине)||||p|}{\tt save} и
снимаются со стека при помощи команды \index{ru}{язык регистровых машин|\texttt{restore}||||} 
\index{ru}{restore (в регистровой машине)||||p|}
{\tt restore}.  После 
того, как последовательность значений сохранена на стеке,
последовательность команд {\tt restore} восстановит их в
обратном порядке\footnote{В 
разделе~\ref{STORAGE-ALLOCATION-AND-GARBAGE-COLLECTION} мы увидим,
как стек можно реализовать на основе более элементарных операций.
}.

С помощью стека можно использовать для всех
подзадач-факториалов единую копию путей данных факториальной
машины. Имеется подобная проблема и при использовании
последовательности команд контроллера, который управляет путями
данных.  Чтобы запустить новое вычисление факториала, контроллер не
может просто перейти~в начало последовательности, как~в итеративном
процессе, поскольку после решения подзадачи поиска $(n-1)!$
машине требуется еще домножить результат на $n$.
Контроллер должен остановить вычисление $n!$, решить
подзадачу поиска $(n-1)!$ и затем продолжить вычисление
$n!$.  Такой взгляд на вычисление факториала приводит к
использованию механизма подпрограмм из 
раздела~\ref{SUBROUTINES}, при котором контроллер с помощью
регистра {\tt continue}
\index{ru}{continue, регистр|и рекурсия|||pd|}
переходит к той части
последовательности команд, которая решает подзадачу,~а затем
продолжает с того места, где он остановился~в главной задаче. Мы можем 
таким образом написать факториальную подпрограмму, которая
возвращается к точке входа, сохраненной~в регистре
{\tt continue}.  При каждом вызове подпрограммы мы сохраняем и
восстанавливаем регистр {\tt continue} подобно регистру
{\tt n}, поскольку все <<уровни>> вычисления факториала
используют один и тот же регистр {\tt continue}.  Так что
факториальная подпрограмма должна записать~в {\tt continue}
новое значение, когда она вызывает сама себя для решения подзадачи, но
для возврата~в место, откуда она была вызвана для решения подзадачи,
ей потребуется старое значение {\tt continue}.

На рисунке~\ref{P5.11} показаны пути данных и
контроллер машины, реализующей рекурсивную процедуру
{\tt factorial}. В этой машине имеются стек и три регистра с
именами {\tt n}, {\tt val} и {\tt continue}.
Чтобы упростить диаграмму путей данных, мы не стали давать имена
кнопкам присваивания регистров, и поименовали только кнопки работы со
стеком~--- {\tt sc} и {\tt sn} для сохранения регистров,
{\tt rc} и {\tt rn} для их восстановления.  В начале работы
мы кладем~в регистр {\tt n} число, факториал которого
желаем вычислить, и запускаем машину.  Когда машина достигает состояния
{\tt fact-done}, вычисление закончено и результат находится в
регистре {\tt val}.  В последовательности команд контроллера
{\tt n} и {\tt continue} сохраняются перед каждым
рекурсивным вызовом и восстанавливаются при возврате из этого вызова.
Возврат из вызова происходит путем перехода к месту, хранящемуся в
{\tt continue}.  В начале работы машины {\tt continue}
получает такое значение, что последний возврат переходит в
{\tt fact-done}.  Регистр {\tt val}, где хранится
результат вычисления факториала, не сохраняется перед рекурсивным
вызовом, поскольку после возврата из подпрограммы его старое содержимое
не нужно.  Используется только новое значение {\tt val}, то есть
результат подвычисления.

Несмотря на то, что~в принципе вычисление факториала
требует бесконечной машины, машина на рисунке~\ref{P5.11}
конечна, за исключением стека, который потенциально неограничен.
Однако любая конкретная физическая реализация стека будет иметь
конечный размер и таким образом будет ограничивать возможную глубину
рекурсивных вызовов, которые машина сможет делать.  Такая реализация
факториала иллюстрирует общую стратегию реализации рекурсивных
алгоритмов~в виде обыкновенных регистровых машин, дополненных стеком.
Когда нам требуется решить рекурсивную подзадачу, мы сохраняем на
стеке регистры, текущее значение которых потребуется после решения
этой подзадачи, решаем ее, затем восстанавливаем сохраненные регистры
и продолжаем выполнение главной задачи. Регистр {\tt continue}
следует сохранять всегда.  Нужно ли сохранять другие регистры, зависит
от конкретной машины, поскольку не все рекурсивные вычисления
нуждаются~в исходных значениях регистров во время решения подзадачи
(см.~упражнение~\ref{EX5.4}).


\begin{cntrfig}%[t]
\input{xfig-mod/5-11.eepic}
\begin{Verbatim}[fontsize=\small]
(controller
   (assign continue (label fact-done))  {\em ; установить адрес} 
   {\em ; окончательного возврата}
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   {\em ;; Подготовиться к рекурсивному вызову, сохраняя {\tt n} и {\tt continue}.}
   {\em ;; Установить  {\tt continue} так, что вычисление продолжится }
   {\em ;; с {\tt after-fact} после возврата из подпрограммы.}
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val)){\em ; теперь {\tt val} содержит $n(n-1)!$}
   (goto (reg continue))             {\em ; возврат в вызывающую программу}
 base-case
 (assign val (const 1))              {\em ; базовый случай: $1! = 1$}
   (goto (reg continue))             {\em ; возврат в вызывающую программу}
 fact-done)
\end{Verbatim}
\caption{Рекурсивная факториальная машина.
\index{ru}{factorial|регистровая машина (рекурсивная)|||p|}}
\label{P5.11}
\end{cntrfig}

\paragraph{Двойная рекурсия}


Рассмотрим более сложный рекурсивный процесс~--- древовидную
рекурсию при вычислении чисел Фибоначчи, описанную~в 
разделе~\ref{TREE-RECURSION}:

\begin{Verbatim}[fontsize=\small]
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{Verbatim}
Как и~в случае с факториалом, рекурсивное вычисление чисел Фибоначчи
можно реализовать~в виде  регистровой машины с регистрами
{\tt n}, {\tt val} и {\tt continue}.  Машина
более сложна, чем факториальная, поскольку~в последовательности команд
контроллера здесь два места, где нам нужно произвести рекурсивный
вызов~--- один раз для вычисления $\mathop{\rm Fib}(n-1)$, а
другой для вычисления $\mathop{\rm Fib}(n-2)$.  При подготовке
к этим вызовам мы сохраняем регистры, чье значение нам потребуется
позже, устанавливаем~в регистр {\tt n} число,
$\mathop{\rm Fib}$ от которого нам требуется вычислить
($n-1$ или $n-2$), и присваиваем регистру
{\tt continue} точку входа~в главной последовательности, куда
нужно вернуться (соответственно, {\tt afterfib-n-1} или
{\tt afterfib-n-2}). Затем мы переходим к метке
{\tt fib-loop}.  При возврате из рекурсивного вызова ответ
содержится~в {\tt val}. На рисунке~\ref{P5.12}
показана последовательность команд контроллера для этой машины.\index{ru}{fib|регистровая машина (с древовидной рекурсией)|||p|}

\newpage

\begin{cntrfig}
\begin{Verbatim}[fontsize=\small]
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   {\em ;; готовимся вычислить $\mathop{\rm Fib} (n-1)$}
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                          {\em ; сохранить старое значение \tt{n}}
   (assign n (op -) (reg n) (const 1)){\em{; записать в{\tt n} $n-1$}}
   (goto (label fib-loop))        {\em ; произвести рекурсивный вызов}
 afterfib-n-1                     {\em ; при возврате{\tt val} содержит $\textrm{Fib}(n-1)$}
   (restore n)
   (restore continue)
   {\em ;; готовимся вычислить $\mathop{\rm Fib} (n-2)$}
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                    {\em ; сохранить $\mathop{\rm Fib}(n-1)$}
   (goto (label fib-loop))
 afterfib-n-2                    {\em ; при возврате {\tt val} содержит $\mathop{\rm Fib}(n-2)$}
   (assign n (reg val))          {\em ; теперь {\tt n} содержит $\mathop{\rm Fib}(n-2)$}
   (restore val)                 {\em ; теперь {\tt val} содержит $\mathop{\rm Fib}(n-1)$}
   (restore continue)
   (assign val                   {\em ; $\mathop{\rm Fib}(n-1) + \mathop{\rm Fib}(n-2)$}
           (op +) (reg val) (reg n)) 
   (goto (reg continue))         {\em ; возврат, ответ~в {\tt val}}
 immediate-answer
   (assign val (reg n))          {\em ; базовый случай:$\mathop{\rm Fib}(n) = n$}
   (goto (reg continue))
 fib-done)
\end{Verbatim}
\caption{Контроллер машины для вычисления чисел Фибоначчи.
\index{ru}{fib|регистровая машина (с древовидной рекурсией)|||p|}}
\label{P5.12}

\end{cntrfig}
\begin{exercise}{5.4}\label{EX5.4}%
%\samepage
Опишите регистровые машины для реализации каждой из
следующих процедур.  Для каждой из этих машин напишите
последовательность команд контроллера и нарисуйте диаграмму,
показывающую пути данных.

\begin{plainenum}


\item
Рекурсивное возведение~в степень:
\index{ru}{expt|регистровая машина|||p|(упр.~5.4)}

\begin{Verbatim}[fontsize=\small]
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
\end{Verbatim}

\item
Итеративное возведение~в степень:

\begin{Verbatim}[fontsize=\small]
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))
\end{Verbatim}
\end{plainenum}
\end{exercise}
\begin{exercise}{5.5}%%
\label{EX5.5}%
Смоделируйте вручную работу факториальной машины и
машины Фибоначчи с каким-нибудь нетривиальным значением на входе
(чтобы потребовался хотя бы один рекурсивный вызов). Покажите
содержимое стека~в каждый момент выполнения.
\end{exercise}
\begin{exercise}{5.6}%%
\label{EX5.6}%
Бен Битобор утверждает, что последовательность команд
машины Фибоначчи содержит одну лишнюю команду {\tt save} и одну
лишнюю {\tt restore}, которые можно убрать и получить более
быструю машину.  Что это за команды?
\end{exercise}

\subsection{Обзор системы команд}
\label{INSTRUCTION-SUMMARY}

\index{ru}{язык регистровых машин|команды||||}
Команда контроллера~в нашей регистровой машине имеет одну
из следующих форм, причем каждый
\textit{$\langle$источник${}_{\mbox{i}}$$\rangle$}~--- это либо
{\tt (reg \textit{$\langle$имя-регистра$\rangle$})}, либо  \index{ru}{язык регистровых машин|\texttt{const}||||}{\tt (const
\textit{$\langle$значение-константы$\rangle$})}.
\sloppy

Команды, введенные~в 
разделе~\ref{A-LANGUAGE-FOR-DESCRIBING-REGISTER-MACHINES}:

\begin{plainlist}
\sloppy
\item {\tt (assign \textit{$\langle$имя-регистра$\rangle$}(reg \textit{$\langle$имя-регистра$\rangle$}))}%
\index{ru}{язык регистровых машин|\texttt{reg}||||}\index{ru}{язык регистровых машин|\texttt{assign}||||} 

\item {\tt (assign \textit{$\langle$имя-регистра$\rangle$} (const \textit{$\langle$значение-константы$\rangle$}))}%
\index{ru}{const (в регистровой машине)|синтаксис|||p|}

\item {\tt (assign \textit{$\langle$имя-регистра$\rangle$} (op \textit{$\langle$имя-операции$\rangle$})
 \textit{$\langle$источник${}_{\mbox{1}}$$\rangle$} \ldots\ \textit{$\langle$ис\-точник${}_{\mbox{n}}$$\rangle$})}%
\index{ru}{язык регистровых машин|\texttt{op}||||}
\sloppy

\item {\tt (perform (op \textit{$\langle$имя-операции$\rangle$}) \textit{$\langle$источник${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$источник${}_{\mbox{n}}$$\rangle$})%
\index{ru}{язык регистровых машин|\texttt{perform}||||}

\item {\tt (test (op \textit{$\langle$имя-операции$\rangle$})  \textit{$\langle$источник${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$источник${}_{\mbox{n}}$$\rangle$})}%
\index{ru}{язык регистровых машин|\texttt{test}||||}

\item {\tt (branch (label \textit{$\langle$имя-метки$\rangle$})) \index{ru}{язык регистровых машин|\texttt{branch}||||}}%
\index{ru}{язык регистровых машин|\texttt{branch}||||}

\item {\tt (goto (label \textit{$\langle$имя-метки$\rangle$}))}} \index{ru}{язык регистровых машин|\texttt{goto}||||}

\end{plainlist}

Использование регистров для хранения меток, введенное в
разделе~\ref{SUBROUTINES}:

\begin{plainlist}
\item {\tt (assign \textit{$\langle$имя-регистра$\rangle$} (label \textit{$\langle$имя-метки$\rangle$}))}

\item {\tt (goto (reg \textit{$\langle$имя-регистра$\rangle$}))}
\end{plainlist}

Команды для работы со стеком, введенные~в 
разделе~\ref{USING-A-STACK-TO-IMPLEMENT-RECURSION}:

\begin{plainlist}
\item {\tt(save \textit{$\langle$имя-регистра$\rangle$})} \index{ru}{язык регистровых машин|\texttt{save}||||}

\item {\tt (restore \textit{$\langle$имя-регистра$\rangle$})} \index{ru}{язык регистровых машин|\texttt{restore}||||}
\end{plainlist}

До сих пор единственный вид
\textit{$\langle$значений-константы$\rangle$}, который нам встречался,~--- числа,
но~в дальнейшем мы будем использовать строки, символы и списки.
Например,  \index{ru}{язык регистровых машин|\texttt{const}||||}{\tt (const "abc")} представляет строку
{\tt "abc"{\em }}, {\tt (const abc)} представляет символ {\tt abc},
{\tt (const (a b c))}~--- список {\tt (a b c)}, а
{\tt (const ())}~--- пустой список.

\section{Программа моделирования регистровых машин}
\label{A-REGISTER-MACHINE-SIMULATOR}

\index{ru}{регистровая машина|программа моделирования||||}
Чтобы как следует разобраться~в работе регистровых
машин, нам нужно уметь тестировать проектируемые нами машины и
проверять, работают ли они~в соответствии с ожиданиями.  Один из
способов проверки проекта состоит~в ручном моделировании работы
контроллера, как~в упражнении~\ref{EX5.5}.  Однако этот
способ подходит только для совсем простых машин.  В этом разделе мы
строим программу имитационного моделирования, 
\index{ru}{имитатор регистровых машин||register-machine simulator|||}\index{en}{register-machine simulator||имитатор регистровых машин|||}{\em имитатор} (simulator), для машин, задаваемых на
языке описания регистровых машин.  Имитатор представляет собой
программу на Scheme с четырьмя интерфейсными процедурами.  Первая из
них на основе описания регистровой машины строит ее модель (структуру
данных, части которой соответствуют частям имитируемой машины), а
остальные три позволяют имитировать машину, работая с этой
моделью:

\begin{plainlist}
\sloppy

\item
{\tt (make-machine \textit{$\langle$имена-регистров$\rangle$} \textit{$\langle$операции$\rangle$} \textit{$\langle$контроллер$\rangle$})}%
\index{ru}{make-machine||||p|} строит и возвращает модель машины с указанными регистрами, операциями
и контроллером.

\item
{\tt (set-register-contents!\hfill\textit{$\langle$модель-машины$\rangle$}\hfill\textit{$\langle$имя-регистра$\rangle$} \hfill \textit{$\langle$значе\-ние$\rangle$})}%
\index{ru}{set-register-contents!||||p|} записывает значение~в имитируемый регистр указанной машины.

\item
{\tt (get-register-contents \textit{$\langle$модель-машины$\rangle$} \textit{$\langle$имя-регистра$\rangle$})} \index{ru}{get-register-contents||||p|}
воз\-вра\-ща\-ет содержимое имитируемого регистра указанной машины.

\item
{\tt (start \textit{$\langle$модель-машины$\rangle$})} \index{ru}{start||||p|} имитирует работу данной машины. Машина запускается с начала
последовательности команд контроллера и останавливается, когда
достигнут конец этой последовательности.
\sloppy
\end{plainlist}

В качестве примера того, как используются эти процедуры,
можно определить переменную {\tt gcd-machine} как модель машины
НОД из раздела~\ref{A-LANGUAGE-FOR-DESCRIBING-REGISTER-MACHINES}
следующим образом:
\index{ru}{gcd|регистровая машина|||p|}

\begin{Verbatim}[fontsize=\small]
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
       (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
     gcd-done)))
\end{Verbatim}
Первым аргументом {\tt make-machine} является список имен
регистров.  Второй аргумент~--- таблица (список двухэлементных
списков), связывающая каждое имя операции с процедурой Scheme,
которая эту операцию реализует (то есть порождает тот же результат на
тех же входных значениях).  Последний аргумент описывает контроллер
в виде списка из меток и машинных команд, как~в 
разделе~\ref{DESIGNING-REGISTER-MACHINES}.

Чтобы вычислить НОД двух чисел с помощью этой машины, мы
заносим значения во входные регистры, запускаем машину,~а когда
имитация ее работы завершается, считываем результат:

\begin{Verbatim}[fontsize=\small]
(set-register-contents! gcd-machine 'a 206)
\textit{done}

(set-register-contents! gcd-machine 'b 40)
\textit{done}

(start gcd-machine)
\textit{done}

(get-register-contents gcd-machine 'a)
\textit{2}
\end{Verbatim}
Эта модель будет работать значительно медленнее, чем процедура
{\tt gcd}, написанная на Scheme, поскольку она имитирует
низкоуровневые команды машины, например, {\tt assign}, с помощью
значительно более сложных операций.
\begin{exercise}{5.7}%%
\label{EX5.7}%
Проверьте на имитаторе машины, построенные Вами в
упражнении~\ref{EX5.4}.
\end{exercise}

\subsection{Модель машины}
\label{THE-MACHINE-MODEL}


Модель машины, которую порождает
{\tt make-machine}, представляется~в виде процедуры с
внутренним состоянием при помощи методов передачи сообщений,
разработанных~в главе~\ref{MODULARITY-OBJECTS-AND-STATE}. При построении модели
{\tt make-machine} прежде всего вызывает процедуру
{\tt make-new-machine},  порождающую те части модели,
которые у всех регистровых машин одинаковые.  Эта базовая модель
машины, создаваемая {\tt make-new-machine}, является,~в сущности,
контейнером для нескольких регистров и стека,~а кроме того, содержит механизм
выполнения, который обрабатывает команды контроллера одну за
другой.

Затем {\tt make-machine} расширяет эту базовую
модель (посылая ей сообщения) и добавляет~в нее регистры, операции и
контроллер для конкретной определяемой машины.  Сначала она выделяет в
новой машине по регистру на каждое из данных имен регистров и
встраивает~в нее указанные операции.  Затем она с помощью 
\index{ru}{ассемблер||assembler|||}\index{en}{assembler||ассемблер|||}{\em ассемблера} (assembler)
(описанного~в 
разделе~\ref{THE-ASSEMBLER}) преобразует список контроллера
в команды новой машины и устанавливает их ей~в качестве последовательности
команд.  В качестве результата {\tt make-machine} возвращает
модифицированную модель машины.

\begin{Verbatim}[fontsize=\small]
(define (make-machine register-names ops controller-text)\index{ru}{make-machine||||pd|}
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)    
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
\end{Verbatim}

\paragraph{Регистры}


Мы будем представлять регистры~в виде процедур с
внутренним состоянием, как~в 
главе~\ref{MODULARITY-OBJECTS-AND-STATE}.  Процедура
{\tt make-register} создает регистр.  Регистр содержит
значение, которое можно считать или изменить.
\index{ru}{регистр|представление||||} 

\begin{Verbatim}[fontsize=\small]
(define (make-register name)\index{ru}{make-register||||pd|}
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Неизвестная операция -- REGISTER" message))))
    dispatch))
\end{Verbatim}
Для доступа к регистрам используются следующие процедуры:

\begin{Verbatim}[fontsize=\small]
(define (get-contents register)\index{ru}{get-contents||||pd|}
  (register 'get))

(define (set-contents! register value)\index{ru}{set-contents!||||pd|}
  ((register 'set) value))
\end{Verbatim}

\paragraph{Стек}


\index{ru}{стек|представление||||}Стек также можно представить~в виде процедуры с
внутренним состоянием.  Процедура {\tt make-stack} создает
стек, внутреннее состояние которого состоит из списка элементов на
стеке.  Стек принимает сообщение {\tt push}, кладущее
элемент на стек, сообщение {\tt pop}, снимающее со стека
верхний элемент и возвращающее его, и сообщение {\tt initialize},
которое дает стеку начальное пустое значение.
\index{ru}{initialize-stack, операция регистровой машины||||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-stack)\index{ru}{make-stack||||pd|}
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Пустой стек -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Неизвестная операция -- STACK"
                         message))))
    dispatch))
\end{Verbatim}
Для доступа к стеку используются следующие процедуры:

\begin{Verbatim}[fontsize=\small]
(define (pop stack)\index{ru}{pop||||pd|}
  (stack 'pop))

(define (push stack value)\index{ru}{push||||pd|}
  ((stack 'push) value))
\end{Verbatim}

\paragraph{Базовая машина}


Процедура {\tt make-new-machine}, приведенная на
рисунке~\ref{P5.13}, порождает объект, внутреннее
состояние которого состоит из стека, изначально пустой
последовательности команд, списка операций, где с самого начала
присутствует операция инициализации стека,~а также 
\index{ru}{таблица регистров,~в программе моделирования||register table|||}\index{en}{register table||таблица регистров,~в программе моделирования|||}{\em таблицы регистров} (register table),~в которой
изначально содержатся два регистра, {\tt flag} 
\index{ru}{flag, регистр||||p|}
и {\tt pc} 
\index{ru}{pc, регистр||||p|}
(от {\em program counter}, 
\index{ru}{счетчик программы||program counter|||}\index{en}{program counter||счетчик программы|||}
<<счетчик программы>>).  Внутренняя процедура {\tt allocate-register}
добавляет~в таблицу новый элемент,~а внутренняя процедура
{\tt lookup-register} ищет регистр~в таблице.

Регистр {\tt flag} используется для управления
переходами~в имитируемой машине.  Команды {\tt test}
присваивают ему результат теста (истину или ложь).  Команды
{\tt branch} определяют, нужно ли делать переход,~в зависимости от
значения регистра {\tt flag}.

Регистр {\tt pc} определяет порядок выполнения
команд при работе машины.  Этот порядок реализуется внутренней
процедурой {\tt execute}.  В нашей имитационной модели каждая
команда является структурой данных,~в которой есть процедура без
аргументов, называемая  \index{ru}{исполнительная процедура|в имитаторе регистровых машин||||}
\index{ru}{исполнительная процедура команды||instruction execution procedure|||}\index{en}{instruction execution procedure||исполнительная процедура команды|||}{\em исполнительная процедура
команды} (instruction execution procedure).  Вызов этой процедуры имитирует выполнение команды. Во
время работы модели {\tt pc} указывает на часть
последовательности команд, начинающуюся со следующей 
подлежащей исполнению команды. Процедура {\tt execute}
\index{ru}{execute||||p|}
считывает эту
команду, выполняет ее при помощи вызова исполнительной процедуры, и
повторяет этот процесс, пока имеется команды для выполнения (то есть
пока {\tt pc} не станет указывать на конец последовательности
команд).

В процессе работы каждая исполнительная процедура
изменяет {\tt pc} и указывает, какую следующую команду надо
выполнить.  Команды {\tt branch} и {\tt goto}
присваивают регистру {\tt pc} значение, указывающее на новый
адрес.  Все остальные команды просто продвигают {\tt pc} так,
чтобы он указывал на следующую команду~в последовательности.  Заметим,
что каждый вызов {\tt execute} снова зовет
{\tt execute}, но это не приводит к бесконечному циклу,
поскольку запуск исполнительной процедуры команды изменяет содержимое
{\tt pc}.

{\tt Make-new-machine} возвращает процедуру
{\tt dispatch}, которая дает доступ к внутреннему состоянию на
основе передачи сообщений.  Запуск машины осуществляется
путем установки {\tt pc}~в начало последовательности команд и
вызова {\tt execute}.

Ради удобства мы предоставляем альтернативный процедурный
интерфейс для операции {\tt start} регистровой машины,~а также
процедуры для доступа к содержимому регистров и их изменения, как
указано~в начале 
раздела~\ref{A-REGISTER-MACHINE-SIMULATOR}:

\begin{Verbatim}[fontsize=\small]
(define (start machine)\index{ru}{start||||pd|}
  (machine 'start))

(define (get-register-contents machine register-name)\index{ru}{get-register-contents||||pd|}
  (get-contents (get-register machine register-name)))

(define (set-register-contents! machine register-name value)\index{ru}{set-register-contents!||||pd|}
  (set-contents! (get-register machine register-name) value)
  'done)
\end{Verbatim}
Все эти процедуры (а также многие процедуры из 
разделов~\ref{THE-ASSEMBLER} и 
\ref{GENERATING-EXECUTION-PROCEDURES-FOR-INSTRUCTIONS})
следующим образом ищут регистр с данным именем~в данной машине:

\begin{Verbatim}[fontsize=\small]
(define (get-register machine reg-name)\index{ru}{get-register||||pd|}
  ((machine 'get-register) reg-name))
\end{Verbatim}


\begin{cntrfig}
{\small 
\begin{Verbatim}[fontsize=\small]
(define (make-new-machine)\index{ru}{make-new-machine||||pd|}
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Многократно определенный регистр: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Неизвестный регистр:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Неизвестная операция -- MACHINE" message))))
      dispatch)))
\end{Verbatim}
}\caption{Процедура {\tt make-new-machine}, реализующая базовую модель
машины.}
\label{P5.13}

\end{cntrfig}

\subsection{Ассемблер}
\label{THE-ASSEMBLER}


\index{ru}{ассемблер|||||} Ассемблер переводит
последовательность выражений 
контроллера машины~в соответствующий ей список машинных команд,
каждая со своей исполнительной процедурой.  По общему строению
ассемблер подобен интерпретаторам, которые мы изучали~в 
главе~\ref{METALINGUISTIC-ABSTRACTION}~--- имеется входной язык
(в этом случае язык регистровых машин), и нам нужно выполнить
некоторое действие для каждого типа выражений этого языка.

Методика порождения исполнительной процедуры для каждой
команды~в точности та же, которой мы пользовались~в 
разделе~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}, чтобы
ускорить интерпретацию путем 
\index{ru}{синтаксический анализ, отделение от выполнения|в имитаторе регистровых машин|separating syntactic analysis from execution|||}\index{en}{separating syntactic analysis from execution||синтаксический анализ, отделение от выполнения|в имитаторе регистровых машин||}
отделения синтаксического анализа от
выполнения.  Как мы видели~в главе~\ref{METALINGUISTIC-ABSTRACTION}, 
существенную часть
полезного анализа выражений Scheme можно провести, не зная конкретных
значений переменных.  Подобным образом и здесь существенную часть
анализа выражений машинного языка можно провести, не зная конкретного
содержимого регистров машины.  Например, можно заменить имена регистров
указателями на объекты-регистры,~а имена меток~---
указателями на те места~в последовательности команд, которые метками
обозначаются.

Прежде чем порождать исполнительные процедуры
команд, ассемблер должен знать, куда указывают все метки, так что
вначале он просматривает текст контроллера и отделяет метки от
команд. При просмотре текста он строит список команд и таблицу,
которая связывает каждую метку с указателем внутрь этого списка.  Затем
ассемблер дополняет список команд, вставляя~в каждую команду
исполнительную процедуру.

Процедура {\tt assemble}~--- основной вход в
ассемблер.  Она принимает~в качестве аргументов текст контроллера и
модель машины,~а возвращает последовательность команд, которую нужно
сохранить~в модели. {\tt Assemble} вызывает
{\tt extract-labels}, чтобы построить из данного ей списка
контроллера исходный список команд и таблицу меток.  Вторым аргументом
{\tt extract-labels} служит процедура, которую следует позвать
для обработки этих результатов: эта процедура зовет
{\tt update-insts!}, чтобы породить исполнительные процедуры
для команд и вставить их~в командный список,~а затем возвращает
модифицированный список команд.

\begin{Verbatim}[fontsize=\small]
(define (assemble controller-text machine)\index{ru}{assemble||||pd|}
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
\end{Verbatim}

{\tt Extract-labels} принимает на входе список
{\tt text} (последовательность выражений, обозначающих команды
контроллера) и процедуру \index{ru}{receive, процедура||||p|} {\tt receive}. 
{\tt Re\-ceive} будет вызвана с двумя аргументами: (1) списком {\tt insts}
структур данных, каждая из которых содержит команду из
{\tt text}; и (2) таблицей под названием {\tt labels},
связывающей каждую метку из {\tt text} с позицией в
списке {\tt insts}, которую эта метка обозначает.

\begin{Verbatim}[fontsize=\small]
(define (extract-labels text receive)\index{ru}{extract-labels||||pd|}
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
\end{Verbatim}
Работа {\tt extract-labels} заключается~в последовательном
просмотре элементов {\tt text} и сборке {\tt insts} и
{\tt labels}.  Если очередной элемент является символом (то
есть меткой), соответствующий вход добавляется~в таблицу
{\tt labels}.  В противном случае элемент добавляется к списку
{\tt insts}\footnote{Процедура {\tt receive} используется здесь, в
сущности,  для того, чтобы заставить {\tt extract-labels} вернуть
два значения~--- {\tt labels} и {\tt insts},~--- не
создавая специально структуры данных для их хранения.  Альтернативная
реализация, которая явным образам возвращает пару значений, выглядит
так:

\begin{Verbatim}
(define (extract-labels text)\index{ru}{extract-labels||||pd|п}
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
\end{Verbatim}
Вызывать ее из {\tt assemble} следовало бы таким образом:

\begin{Verbatim}
(define (assemble controller-text machine)\index{ru}{assemble||||pd|п}
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
\end{Verbatim}
Можно считать, что использование {\tt receive}
показывает изящный
\index{ru}{процедура|возврат нескольких значений||||п}
\index{ru}{возврат нескольких значений||returning     multiple values|||п}\index{en}{returning     multiple values||возврат нескольких значений|||п}
способ вернуть несколько значений,~а можно
считать, что это просто оправдание для демонстрации программистского
трюка.  Аргумент, который, как {\tt receive}, является
процедурой, вызываемой~в конце, называется
<<продолжением>>.
\index{ru}{продолжение|в имитаторе регистровых     машин|continuation|||п}\index{en}{continuation||продолжение|в имитаторе регистровых     машин||п}
Напомним, что мы уже использовали
продолжения для 
того, чтобы реализовать управляющую структуру перебора с возвратом в
разделе~\ref{IMPLEMENTING-THE-AMB-EVALUATOR}.
}. %%footnote!

{\tt Update-insts!} модифицирует командный список,
который сначала содержит только текст команд, так, чтобы~в нем имелись
соответствующие исполнительные процедуры:

\begin{Verbatim}[fontsize=\small]
(define (update-insts! insts labels machine) \index{ru}{update-insts!||||pd|}
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
\end{Verbatim}

Структура данных для машинной команды просто сочетает текст
команды с соответствующей исполнительной процедурой.  Когда
{\tt extract-labels} создает команду, исполнительной процедуры
еще нет, и она вставляется позже из процедуры
{\tt update-insts!}:

\begin{Verbatim}[fontsize=\small]
(define (make-instruction text)\index{ru}{make-instruction||||pd|}
  (cons text '()))

(define (instruction-text inst)\index{ru}{instruction-text||||pd|}
  (car inst))

(define (instruction-execution-proc inst)\index{ru}{instruction-execution-proc||||pd|}
  (cdr inst))

(define (set-instruction-execution-proc! inst proc)\index{ru}{set-instruction-execution-proc!||||pd|}
  (set-cdr! inst proc))
\end{Verbatim}
Текст команды не используется~в имитаторе, но сохраняется~в целях
отладки (см. упражнение~\ref{EX5.16}).

Элементы таблицы меток~--- это пары:

\begin{Verbatim}[fontsize=\small]
(define (make-label-entry label-name insts)\index{ru}{make-label-entry||||pd|}
  (cons label-name insts))
\end{Verbatim}
Записи~в таблице можно искать через

\begin{Verbatim}[fontsize=\small]
(define (lookup-label labels label-name)\index{ru}{lookup-label||||pd|}
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Неопределенная метка -- ASSEMBLE" label-name))))
\end{Verbatim}
\begin{exercise}{5.8}%%
\label{EX5.8}%
Следующий код для регистровой машины неоднозначен,
поскольку метка {\tt here} определена более одного раза:

\begin{Verbatim}[fontsize=\small]
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
\end{Verbatim}
Каково будет содержимое регистра {\tt a}~в нашем имитаторе,
когда управление достигнет {\tt there}?  Измените процедуру
{\tt extract-labels} так, чтобы ассемблер сообщал об ошибке в
случае, когда одно и то же имя метки обозначает две различных точки в
коде.
\end{exercise}

\subsection{Порождение исполнительных процедур для команд}
\label{GENERATING-EXECUTION-PROCEDURES-FOR-INSTRUCTIONS}


\index{ru}{исполнительная процедура|в имитаторе регистровых машин||||}
Чтобы породить для команды исполнительную процедуру,
ассемблер зовет {\tt make-execution-procedure}. Как и процедура
{\tt analyze}~в интерпретаторе из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}, она
делает выбор на основе типа команды и порождает соответствующую
исполнительную процедуру.

\begin{Verbatim}[fontsize=\small]
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)\index{ru}{make-execution-procedure||||pd|}
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Неизвестный тип команды -- ASSEMBLE"
                     inst))))
\end{Verbatim}

Для каждого типа команд языка регистровых машин имеется
процедура-генератор, которая порождает исполнительные процедуры.  Детали
порождаемых процедур определяют как синтаксис, так и семантику
отдельных команд машинного языка.  Мы изолируем с
помощью абстракции данных конкретный синтаксис
выражений языка регистровых машин от общего механизма вычисления,
подобно тому, как мы это делали для
интерпретатора из раздела~\ref{REPRESENTING-EXPRESSIONS},
и для считывания и классификации частей команды используем
синтаксические процедуры.

\paragraph{Команды {\tt assign}}


Процедура {\tt make-assign} обрабатывает команды
{\tt assign}:
\index{ru}{assign (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-assign inst machine labels operations pc)\index{ru}{make-assign||||pd|}
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()     {\em ; исполнительная процедура для {\tt assign}}
        (set-contents! target (value-proc))
        (advance-pc pc)))))
\end{Verbatim}
{\tt Make-assign} извлекает имя целевого регистра (второй
элемент команды) и выражение-значение (остаток списка, представляющего
команду) из команды {\tt assign} с помощью селекторов

\begin{Verbatim}[fontsize=\small]
(define (assign-reg-name assign-instruction)\index{ru}{assign-reg-name||||pd|}
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)\index{ru}{assign-value-exp||||pd|}
  (cddr assign-instruction))
\end{Verbatim}
По имени регистра с помощью {\tt get-register} находится
объект-целевой регистр. Выражение-значение передается в
{\tt make-operation-exp}, если значение является результатом
операции, и~в {\tt make-primitive-exp}~в противном случае. Эти
процедуры (приведенные ниже) рассматривают выражение-значение и
порождают исполнительную процедуру для вычисления этого
выражения. Это процедура без аргументов, называемая
\index{ru}{value-proc||||p|}{\tt value-proc}, которая будет вызвана во время работы
имитатора и породит значение, которое требуется присвоить регистру.
Заметим, что поиск регистра по имени и разбор
выражения-значения происходят только один раз во время
ассемблирования,~а не каждый раз при выполнении команды. Именно ради
такой экономии работы мы используем исполнительные процедуры, и этот
выигрыш прямо соответствует экономии, полученной путем  \index{ru}{синтаксический анализ, отделение от выполнения|в имитаторе регистровых машин||||} отделения
синтаксического анализа от выполнения~в интерпретаторе из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}.

Результат, возвращаемый {\tt make-assign}~--- это
исполнительная процедура для команды {\tt assign}.  Когда
эта процедура вызывается (из процедуры {\tt execute} модели),
она записывает~в целевой регистр результат, полученный при выполнении
{\tt value-proc}.  Затем она передвигает {\tt pc} на
следующую команду с помощью процедуры

\begin{Verbatim}[fontsize=\small]
(define (advance-pc pc)\index{ru}{advance-pc||||pd|}
  (set-contents! pc (cdr (get-contents pc))))
\end{Verbatim}
{\tt Advance-pc} вызывается~в конце исполнения всех команд,
кроме {\tt branch} и {\tt goto}.

\paragraph{Команды {\tt test}, {\tt branch} и
{\tt goto}}


{\tt Make-test} обрабатывает команду
{\tt test} похожим образом.  Эта процедура извлекает выражение,
которое определяет подлежащее проверке условие, и порождает для него
исполнительную процедуру.  Во время работы модели эта процедура для
условия вызывается, результат ее сохраняется~в регистре
{\tt flag}, и {\tt pc} передвигается на шаг:
\index{ru}{test (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-test inst machine labels operations flag pc)\index{ru}{make-test||||pd|}
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Плохая команда TEST -- ASSEMBLE" inst))))

(define (test-condition test-instruction)\index{ru}{test-condition||||pd|}
  (cdr test-instruction))
\end{Verbatim}

Исполнительная процедура для команды {\tt branch}
проверяет содержимое регистра {\tt flag} и либо записывает в
содержимое {\tt pc} целевой адрес (если переход происходит),
либо просто продвигает {\tt pc} (если переход не происходит).
Заметим, что указанная точка назначения для команды
{\tt branch} обязана быть меткой, и процедура
{\tt make-branch} это проверяет.  Заметим также, что поиск
метки происходит во время ассемблирования,~а не при каждом исполнении
команды {\tt branch}.
\index{ru}{branch (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-branch inst machine labels flag pc)\index{ru}{make-branch||||pd|}
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Плохая команда BRANCH -- ASSEMBLE" inst))))

(define (branch-dest branch-instruction)\index{ru}{branch-dest||||pd|}
  (cadr branch-instruction))
\end{Verbatim}

Команда {\tt goto} подобна {\tt branch}, но
только здесь~в качестве целевого адреса может быть указана либо метка,
либо регистр, и не надо проверять никакого условия~--- в
{\tt pc} всегда записывается новый адрес.
\index{ru}{goto (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-goto inst machine labels pc)\index{ru}{make-goto||||pd|}
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Плохая команда GOTO -- ASSEMBLE"
                       inst)))))

(define (goto-dest goto-instruction)\index{ru}{goto-dest||||pd|}
  (cadr goto-instruction))
\end{Verbatim}

\paragraph{Остальные команды}


Команды работы со стеком {\tt save} и
{\tt restore} просто используют стек и указанный регистр, а
затем продвигают {\tt pc}:

\begin{Verbatim}[fontsize=\small]
(define (make-save inst machine stack pc)\index{ru}{make-save||||pd|}\index{ru}{save (в регистровой машине)|моделирование|||p|}

  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)\index{ru}{make-restore||||pd|}\index{ru}{restore (в регистровой машине)|моделирование|||p|}
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))

(define (stack-inst-reg-name stack-instruction)\index{ru}{stack-inst-reg-name||||pd|}
  (cadr stack-instruction))
\end{Verbatim}

Последний тип команды, обрабатываемый процедурой
{\tt make-perform}, порождает исполнительную процедуру для
требуемого действия.  Во время работы имитатора действие выполняется
и продвигается {\tt pc}.
\index{ru}{perform (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-perform inst machine labels operations pc)\index{ru}{make-perform||||pd|}
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Плохая команда PERFORM -- ASSEMBLE" inst))))

(define (perform-action inst) (cdr inst))\index{ru}{perform-action||||pd|}
\end{Verbatim}

\paragraph{Исполнительные процедуры для подвыражений}


Значение выражения {\tt reg}, {\tt label}
или {\tt const} 
\index{ru}{const (в регистровой машине)|имитация|||p|}
\index{ru}{label (в регистровой машине)|имитация|||p|}
\index{ru}{reg (в регистровой машине)|имитация|||p|}
может потребоваться для присваивания регистру
({\tt make-assign}) или как аргумент операции
({\tt make-ope\-ra\-tion-exp}, далее).  Следующая процедура
порождает исполнительные процедуры, которые вычисляют во время
выполнения значения этих выражений:

\begin{Verbatim}[fontsize=\small]
(define (make-primitive-exp exp machine labels)\index{ru}{machine||||pd|}
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Неизвестный тип выражения -- ASSEMBLE" exp))))
\end{Verbatim}
Синтаксис выражений {\tt reg}, {\tt label} и
{\tt const} определяется так:

\begin{Verbatim}[fontsize=\small]
(define (register-exp? exp) (tagged-list? exp 'reg))\index{ru}{register-exp?||||pd|}

(define (register-exp-reg exp) (cadr exp))\index{ru}{register-exp-reg||||pd|}

(define (constant-exp? exp) (tagged-list? exp 'const))\index{ru}{constant-exp?||||pd|}

(define (constant-exp-value exp) (cadr exp))\index{ru}{constant-exp-value||||pd|}

(define (label-exp? exp) (tagged-list? exp 'label))\index{ru}{label-exp?||||pd|}

(define (label-exp-label exp) (cadr exp))\index{ru}{label-exp-label||||pd|}
\end{Verbatim}

Команды {\tt assign}, {\tt test} и
{\tt perform} могут включать~в себя применение машинной
операции (определяемой выражением {\tt op}) к нескольким
операндам (определяемым выражениями {\tt reg} или
{\tt const}). Следующая процедура порождает исполнительную
процедуру для <<выражения-операции>>~--- списка, состоящего из
выражений внутри команды, обозначающих операцию и операнды.
\index{ru}{op (в регистровой машине)|имитация|||p|}

\begin{Verbatim}[fontsize=\small]
(define (make-operation-exp exp machine labels operations)\index{ru}{make-operation-exp||||pd|}
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
\end{Verbatim}
Синтаксис выражений-операций определяется через

\begin{Verbatim}[fontsize=\small]
(define (operation-exp? exp)\index{ru}{operation-exp?||||pd|}
  (and (pair? exp) (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)\index{ru}{operation-exp-op||||pd|}
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)\index{ru}{operation-exp-operands||||pd|}
  (cdr operation-exp))
\end{Verbatim}

Заметим, что обработка выражений-операций очень
напоминает обработку вызовов процедур процедурой
{\tt analyze-application} интерпретатора из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION},
поскольку там и тут мы порождаем исполнительные процедуры для каждого
операнда.  Во время работы мы вызываем эти процедуры для операндов и
применяем процедуру Scheme, которая имитирует операцию, к полученным
значениям.  Имитирующая процедура получается путем поиска имени
операции~в таблице операций регистровой машины:

\begin{Verbatim}[fontsize=\small]
(define (lookup-prim symbol operations)\index{ru}{lookup-prim||||pd|}
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Неизвестная операция -- ASSEMBLE" symbol))))
\end{Verbatim}
\begin{exercise}{5.9}%%
\label{EX5.9}%
Приведенная~в тексте обработка позволяет машинным
операциям принимать~в качестве аргументов не только константы и
содержимое регистров, но и метки.  Измените процедуры, обрабатывающие
выражения, и обеспечьте выполнение условия, что операции можно
применять исключительно к регистрам и константам.
\end{exercise}
\begin{exercise}{5.10}%%
\label{EX5.10}%
Придумайте новый синтаксис для команд регистровой машины
и измените имитатор так, чтобы он использовал Ваш новый синтаксис.
Можете ли Вы реализовать свой синтаксис, ничего не трогая, кроме
синтаксических процедур из этого раздела?
\end{exercise}
\begin{exercise}{5.11}%%
\label{EX5.11}%
Когда мы~в 
разделе~\ref{USING-A-STACK-TO-IMPLEMENT-RECURSION} определяли
{\tt save} и {\tt restore}, мы не указали, что
произойдет, если попытаться восстановить значение не~в том регистре,
который был сохранен последним, как~в последовательности команд

\begin{Verbatim}[fontsize=\small]
(save y)
(save x)
(restore y)
\end{Verbatim}
Есть несколько разумных вариантов значения {\tt restore}:

\begin{plainenum}

\item
{\tt (restore y)} переносит~в {\tt y}
последнее значение, сохраненное на стеке, независимо от того, откуда
это значение взялось.  Так работает наш имитатор.  Покажите, как с
помощью такого поведения убрать одну команду из машины Фибоначчи
(раздел~\ref{USING-A-STACK-TO-IMPLEMENT-RECURSION},
рисунок~\ref{P5.12}).

\item
{\tt (restore y)} переносит~в {\tt y}
последнее значение, сохраненное на стеке, но только~в том случае,
когда это значение происходит из регистра {\tt y}; иначе
возникает сообщение об ошибке.  Модифицируйте имитатор и заставьте его
вести себя таким образом.  Придется изменить  {\tt save} так,
чтобы он сохранял имя регистра вместе со значением.

\item
{\tt (restore y)} переносит~в {\tt y}
последнее значение, сохраненное из {\tt y}, независимо от
того, какие другие регистры были сохранены и не восстановлены после
{\tt y}. Модифицируйте имитатор так, чтобы он вел себя таким
образом.  С каждым регистром придется связать свой собственный стек.
Операция {\tt initialize-stack} должна инициализировать стеки
всех регистров.
\end{plainenum}
\end{exercise}
\begin{exercise}{5.12}%%
\label{EX5.12}%
При помощи имитатора можно определять пути данных,
которые требуются для реализации машины с данным контроллером.
Расширьте ассемблер и заставьте его хранить следующую информацию о
модели машины:

\begin{plainlist}

\item
список всех команд, с удаленными дубликатами,
отсортированный по типу команды ({\tt assign},
{\tt goto} и так далее).

\item
список (без дубликатов) регистров,~в которых
хранятся точки входа (это те регистры, которые упоминаются~в командах
{\tt goto}).

\item
Список (без дубликатов) регистров, к которым
применяются команды {\tt save} или {\tt restore}.

\item
Для каждого регистра, список (без дубликатов)
источников, из которых ему присваивается значение (например, для
регистра {\tt val}~в факториальной машине на 
рисунке~\ref{P5.11} источниками являются {\tt (const 1)} и
{\tt ((op *) (reg n) (reg val))}).
\end{plainlist}
Расширьте интерфейс сообщений машины и включите~в него доступ к
новой информации.  Чтобы проверить свой анализатор, примените его к
машине Фибоначчи с рисунка~\ref{P5.12} и рассмотрите
получившиеся списки.
\end{exercise}
\begin{exercise}{5.13}%%
\label{EX5.13}%
Модифицируйте имитатор так, чтобы он определял, какие
регистры присутствуют~в машине, из последовательности команд
контроллера,~а не принимал список регистров~в качестве аргумента
{\tt make-machine}.  Вместо того, чтобы выделять регистры в
{\tt make-machine} заранее, их можно создавать по одному, когда
они встречаются~в первый раз при ассемблировании команд.
\end{exercise}

\subsection{Отслеживание производительности машины}
\label{MONITORING-MACHINE-PERFORMANCE}

\index{ru}{регистровая машина|отслеживание производительности||||} 
\index{ru}{имитация|для отслеживания производительности регистровой машины||||}
Имитационное моделирование может служить не только для
проверки правильности проекта машины, но и для измерения ее
производительности.  К примеру, можно установить~в нашу машину
<<счетчик>>, измеряющий количество операций со стеком, задействованных
при вычислении. Для этого мы изменяем моделируемый стек и
следим, сколько раз регистры сохраняются на стеке,
регистрируем максимальную
глубину, которой он достигает,~а также добавляем к интерфейсу стека
сообщение, которое распечатывает статистику, как показано ниже.  Кроме
того, мы добавляем к базовой машине операцию для распечатки
статистики, устанавливая значение {\tt the-ops} в
{\tt make-new-machine} в

\begin{Verbatim}[fontsize=\small]
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
\end{Verbatim}
Вот новая версия {\tt make-stack}:

\begin{Verbatim}[fontsize=\small]
(define (make-stack)\index{ru}{make-stack|с отслеживанием стека|||pd|}
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Пустой стек -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Неизвестная операция -- STACK" message))))
    dispatch))
\end{Verbatim}

В упражнениях от \ref{EX5.15} до 
\ref{EX5.19} описываются другие полезные возможности для
сбора информации и отладки, которые можно добавить к имитатору
регистровых машин.
\begin{exercise}{5.14}%%
\label{EX5.14}%
Измерьте количество сохранений и максимальную глубину
стека, требуемую для вычисления $n!$ при различных малых
значениях $n$ с помощью факториальной машины, показанной на
рисунке~\ref{P5.11}.  
\index{ru}{factorial|использование стека, регистровая машина|||p|(упр.~5.14)}
По этим данным определите формулы в
зависимости от $n$ для числа сохранений и максимальной
глубины стека, требуемых для вычисления $n!$ при любом
$n > 1$.  Обратите внимание, что это линейные функции от
$n$, и они определяются двумя константами.  Чтобы
увидеть статистику, Вам придется добавить к факториальной машине
команды для инициализации стека и распечатки статистики.  Можно также
заставить машину~в цикле считывать {\tt n}, вычислять факториал
и печатать результат (как для машины НОД с 
рисунка~\ref{P5.4}), так, чтобы не нужно было все время вызывать
{\tt get-register-contents},
{\tt set-register-contents!} и {\tt start}.
\end{exercise}
\begin{exercise}{5.15}%%
\label{EX5.15}%
Добавьте к модели регистровой машины 
\index{ru}{подсчет команд||instruction counting|||(упр.~5.15)}\index{en}{instruction counting||подсчет команд|||(упр.~5.15)}{\em подсчет команд} (instruction counting).  Это значит, что
машина должна подсчитывать число выполненных ею команд.  Расширьте
интерфейс модели и добавьте новое сообщение, которое печатает счетчик
команд и переустанавливает его~в ноль.
\end{exercise}
\begin{exercise}{5.16}%%
\label{EX5.16}%
Добавьте к имитатору 
\index{ru}{трассировка|команд|tracing|instruction||(упр.~5.16)}\index{en}{tracing|instruction|трассировка|команд||(упр.~5.16)}{\em трассировку
команд} (instruction tracing). ~а именно, перед тем, как выполнить каждую команду,
имитатор должен распечатывать ее текст.  Заставьте модель принимать
сообщения {\tt trace-on} и {\tt trace-off}, которые
включают и выключают трассировку.
\end{exercise}
\begin{exercise}{5.17}%%
\label{EX5.17}%
Расширьте трассировку команд из 
упражнения~\ref{EX5.16} так, чтобы перед тем, как печатать команду,
имитатор распечатывал метки, которые стоят~в последовательности
контроллера непосредственно перед этой командой.  Постарайтесь при
этом не помешать подсчету команд 
(упражнение~\ref{EX5.15}).  Придется заставить имитатор
хранить необходимую информацию о метках. 
\end{exercise}
\begin{exercise}{5.18}%%
\label{EX5.18}%
\index{ru}{регистровая машина|трассировка||||(упр.~5.18)}% 
\index{ru}{трассировка|регистров|tracing|register||(упр.~5.18)}%
\index{en}{tracing|register|трассировка|регистров||(упр.~5.18)}%
Измените процедуру {\tt make-register} из раздела
\ref{THE-MACHINE-MODEL}, так, чтобы можно было
трассировать регистры.  Регистры должны принимать сообщения, которые
включают и выключают трассировку.  Когда регистр подвергается
трассировке, присваивание ему значения должно вызывать распечатку
имени регистра, старого его содержимого и нового, которое ему
присваивается.  Расширьте интерфейс модели и дайте пользователю
возможность включать и выключать трассировку для указанных регистров
машины.
\end{exercise}
\begin{exercise}{5.19}%%
\label{EX5.19}%
Лиза П.~Хакер хочет добавить~в имитатор 
\index{ru}{контрольная точка||breakpoint|||(упр.~5.19)}\index{en}{breakpoint||контрольная точка|||(упр.~5.19)}{\em контрольные точки} (breakpoints) для
облегчения отладки проектов машин.  Вас наняли для реализации такой
возможности.  Лиза хочет, чтобы~в последовательности команд
контроллера можно было указать место, где имитатор остановится
и позволит ей исследовать состояние машины.  Вам нужно реализовать
процедуру

\begin{Verbatim}[fontsize=\small]
(set-breakpoint \textit{$\langle$машина$\rangle$} \textit{$\langle$метка$\rangle$} \textit{$\langle$n$\rangle$})
\end{Verbatim}
которая устанавливает контрольную точку перед $n$-й
командой, следующей за указанной меткой.  Например,

\begin{Verbatim}[fontsize=\small]
(set-breakpoint gcd-machine 'test-b 4)
\end{Verbatim}
установит контрольную точку~в {\tt gcd-machine} непосредственно
перед присваиванием регистру {\tt a}.  Когда моделирование
достигает контрольной точки, имитатор должен 
распечатать метку и смещение точки,~а затем прекратить выполнение
команд.  Тогда Лиза может с помощью
{\tt get-register-contents} и
{\tt set-register-contents!} исследовать и изменять состояние
имитируемой машины.  Затем она должна быть способна продолжить
выполнение, сказав

\begin{Verbatim}[fontsize=\small]
(proceed-machine \textit{$\langle$машина$\rangle$})
\end{Verbatim}
Кроме того, необходимо иметь возможность удалить контрольную точку с
помощью

\begin{Verbatim}[fontsize=\small]
(cancel-breakpoint \textit{$\langle$машина$\rangle$} \textit{$\langle$метка$\rangle$} \textit{$\langle$n$\rangle$})
\end{Verbatim}
и удалить все контрольные точки с помощью

\begin{Verbatim}[fontsize=\small]
(cancel-all-breakpoints \textit{$\langle$машина$\rangle$})
\end{Verbatim}
\end{exercise}

\section{Выделение памяти и сборка мусора}
\label{STORAGE-ALLOCATION-AND-GARBAGE-COLLECTION}


В разделе~\ref{THE-EXPLICIT-CONTROL-EVALUATOR} мы
покажем, как реализовать вычислитель для Scheme~в виде регистровой
машины. Для того, чтобы упростить обсуждение, мы будем предполагать, что наши
машины обладают 
\index{ru}{память|со списковой структурой|memory|list-structured||}\index{en}{memory|list-structured|память|со списковой структурой||}{\em памятью со списковой структурой} (list-structured memory),~в которой основные операции по работе
с данными списковой структуры элементарны.  Постулирование такой
памяти~--- удобная абстракция, если мы хотим сконцентрировать внимание
на механизмах управления~в интерпретаторе Scheme, однако она не
дает реалистической картины того, как на самом деле устроены элементарные
операции с данными~в современных компьютерах.  Для того, чтобы
получить более полное понимание работы Лисп-системы, требуется
исследовать, как списковую структуру можно представить способом,
совместимым с устройством памяти обыкновенных компьютеров.

При реализации списковой структуры возникает два вопроса.
Первый относится только к способу представления: как изобразить
структуру <<ячеек и указателей>>, присущую лисповским парам, используя
только механизмы хранения и адресации, которыми обладает обыкновенная
компьютерная память. Второй вопрос связан с управлением памятью по
мере того, как вычисление развивается.  Работа Лисп-системы
существенным образом зависит от ее способности постоянно создавать
новые объекты данных.  Сюда включаются как объекты, которые явным
образом выделяются~в интерпретируемых Лисп-процедурах, так и
структуры, создаваемые самим интерпретатором, например окружения и
списки аргументов.  Несмотря на то, что постоянное создание новых
объектов данных не вызвало бы проблемы на компьютере с бесконечным
количеством быстродействующей памяти,~в настоящих компьютерах объем
доступной памяти ограничен (к сожалению).  Поэтому
Лисп-системы реализуют
\index{ru}{автоматическое распределение памяти||automatic storage allocation|||}%
\index{en}{automatic storage allocation||автоматическое распределение памяти|||}%
{\em автоматическое распределение
памяти} (automatic storage allocation), которое поддерживает иллюзию бесконечной памяти.  Когда
объект данных перестает быть нужным, занятая под него память
автоматически освобождается и используется для построения новых
объектов данных.  Имеются различные методы реализации такого
автоматического распределителя памяти.  Метод, обсуждаемый нами~в этом
разделе, называется \index{ru}{сборка мусора||garbage collection|||}\index{en}{garbage collection||сборка мусора|||}{\em сборка
мусора} (garbage collection).

\subsection{Память как векторы}
\label{MEMORY-AS-VECTORS}


Обыкновенную память компьютера можно рассматривать как
массив клеток, каждая из которых может содержать кусочек информации. У
каждой клетки имеется собственное имя, которое называется ее 
\index{ru}{адрес||address|||}\index{en}{address||адрес|||}{\em адресом} (address). Типичная система памяти
предоставляет две элементарные операции: одна считывает данные,
хранящиеся по указанному адресу,~а вторая записывает по указанному
адресу новые данные.  Адреса памяти можно складывать с целыми числами
и получать таким образом последовательный доступ к некоторому
множеству клеток.  Если говорить более общо, многие важные операции с
данными требуют, чтобы адреса памяти рассматривались как данные,
которые можно записывать~в ячейки памяти, и которыми можно
манипулировать~в регистрах машины. Представление списковой структуры~--- одно из применений такой \index{ru}{адресная арифметика||address arithmetic|||}\index{en}{address arithmetic||адресная арифметика|||}{\em адресной
арифметики} (address arithmetic).

Для моделирования памяти компьютера мы используем новый
вид структуры данных, называемый
\index{ru}{вектор (структура данных)||vector (data structure)|||}
\index{en}{vector (data structure)||вектор (структура данных)|||}
{\em вектором} (vector).
С абстрактной точки зрения, вектор представляет собой составной
объект, к отдельным элементам которого можно обращаться при
помощи целочисленного индекса за время, независимое от величины
индекса\footnote{Можно было бы представить память~в виде списка ячеек.
Однако тогда время доступа не было бы независимым от индекса,
поскольку доступ к $n$-му элементу списка требует
$n-1$ операций {\tt cdr}.
}.
Чтобы описать операции с памятью, мы пользуемся двумя элементарными
процедурами Scheme для работы с векторами:

\begin{plainlist}


\item
\index{ru}{элементарные процедуры|{\tt vector-ref}||||} 
{\tt (vector-ref \textit{$\langle$вектор$\rangle$} \index{ru}{vector-ref (элементарная процедура)||||pd|}
\textit{$\langle$n$\rangle$})} возвращает $n$-ый элемент
вектора.

\item
\sloppy
\index{ru}{элементарные процедуры|{\tt vector-set!}||||} 
{\tt (vector-set! \textit{$\langle$вектор$\rangle$}  \index{ru}{vector-set!  (элементарная процедура)||||pd|}
\textit{$\langle$n$\rangle$} \textit{$\langle$значение$\rangle$})} устанавливает
$n$-ый элемент вектора~в указанное значение.
\end{plainlist}
Например, если {\tt v}~--- вектор, то {\tt (vector-ref
v 5)} получает его пятый элемент,~а {\tt (vector-set! v 5
7)} устанавливает значение его пятого элемента равным 7\footnote{Полноты ради, надо было бы указать еще операцию
{\tt make-vector}, которая создает вектора.  Однако~в текущем
приложении мы используем вектора исключительно для моделирования
заранее заданных участков компьютерной памяти.
}.
В памяти компьютера такой доступ можно было бы организовать через
адресную арифметику, сочетая \index{ru}{базовый адрес||base address|||}\index{en}{base address||базовый адрес|||}{\em базовый
адрес} (base address), который указывает на начальное положение вектора в
памяти, с \index{ru}{индекс||index|||}\index{en}{index||индекс|||}{\em индексом} (index), который указывает
смещение определенного элемента вектора.

\paragraph{Представление лисповских данных}


\index{ru}{списковая структура|представленная с помощью векторов||||}
\index{ru}{пара (пары)|представленные с помощью векторов||||}
С помощью списков можно реализовать пары~--- основные
объекты данных, нужные для памяти со списковой структурой.  Представим, что
память разделена на два вектора:  \index{ru}{the-cars|вектор|||p|}{\tt the-cars} и  \index{ru}{the-cdrs|вектор|||p|}
{\tt the-cdrs}.  Списковую структуру мы будем представлять
следующим образом: указатель на пару есть индекс, указывающий внутрь
этих двух векторов. Содержимое элемента {\tt the-cars} с
указанным индексом является {\tt car} пары,~а содержимое
элемента {\tt the-cdrs} с тем же индексом является
{\tt cdr} пары.  Кроме того, нам нужно представление для
объектов помимо пар (например, чисел и символов) и способ отличать
один тип данных от другого.  Есть много способов этого добиться, но
все они сводятся к использованию  
\index{ru}{типизированный указатель||typed pointer|||}\index{en}{typed pointer||типизированный указатель|||}%
\index{ru}{указатель|типизированный|pointer|typed||}\index{en}{pointer|typed|указатель|типизированный||}{\em типизированных
указателей} (typed pointers)~--- то есть понятие <<указатель>>
расширяется и включает~в себя тип данных\footnote{Это~в точности понятие  \index{ru}{данные|помеченные||||п} \index{ru}{помеченные данные|||||п}<<помеченных данных>>, которое
мы ввели~в главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA} для
работы с обобщенными операциями.  Однако здесь типы данных вводятся на
элементарном машинном уровне,~а не конструируются через списки.
}.
Тип данных позволяет системе отличить указатель на пару (который
состоит из метки типа данных <<пара>> и индекса~в вектора памяти) от
указателей на другие типы данных (которые состоят из метки какого-то
другого типа и того, что используется для представления значений этого
типа).  Два объекта данных считаются равными ({\tt eq?}), если
равны указатели на них\footnote{Информация о типе может быть представлена различными
способами,~в зависимости от деталей машины, на которой реализована
Лисп-система.  Эффективность выполнения Лисп-программ будет сильно
зависеть от того, насколько разумно сделан этот выбор, однако
правила проектирования, определяющие, какой выбор хорош,
сформулировать трудно.  Самый простой способ реализации типизированных
указателей состоит~в том, чтобы~в каждом указателе выделить несколько
бит как \index{ru}{поле типа||type field|||п}\index{en}{type field||поле типа|||п}{\em поле типа} (type field) (или 
\index{ru}{тег типа||type tag|||п}\index{en}{type tag||тег типа|||п}{\em метку, тег типа} (type tag)) которое кодирует
\index{ru}{метка типа|||||п}
тип. При этом требуется решить следующие важные вопросы: сколько
требуется битов для поля типа?  Как велики должны быть индексы
векторов?  Насколько эффективно можно использовать элементарные
команды машины для работы с полями типа~в указателях?  Про машины, в
которых имеется специальная аппаратура для эффективной обработки полей
типа, говорят, что они обладают \index{ru}{теговая архитектура||tagged architecture|||п}\index{en}{tagged architecture||теговая архитектура|||п}{\em теговой
архитектурой} (tagged architecture).
}.
На рисунке~\ref{P5.14} показано, как с помощью этого
метода представляется список {\tt ((1 2) 3 4)},~а также
дана его стрелочная диаграмма. Информацию о типах мы
обозначаем через буквенные префиксы.  Например, указатель на пару с
индексом 5 обозначается {\tt p5}, пустой список обозначается
{\tt e0},~а указатель на число 4 обозначается
{\tt n4}. На стрелочной диаграмме мы~в левом нижнем
углу каждой пары ставим индекс вектора, который показывает, где
хранятся {\tt car} и {\tt cdr} пары. Пустые клетки в
{\tt the-cars} и {\tt the-cdrs} могут содержать части
других структур (которые нам сейчас неинтересны).


\begin{cntrfig}
\input{xfig-mod/5-14.eepic}

\bigskip

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
\hline
\tt{Индекс}   & \tt{0} & \tt{1} & \tt{2} & \tt{3} & \tt{4} & \tt{5} & \tt{6} & \tt{7} & \tt{8} & \tt{\dots} \\ \hline
\tt{the-cars} & & \tt{p5} & \tt{n3} & & \tt{n4} & \tt{n1} & & \tt{n2} & & \tt{\dots} \\ \hline
{\tt the-cdrs}& & \tt{p2} & \tt{p4} & & \tt{e0} & \tt{p7} & & \tt{e0} & & \tt{\dots} \\ \hline
\end{tabular}

\caption{Представления списка {\tt ((1 2) 3 4)} 
в виде стрелочной диаграммы и~в виде вектора памяти.}
\label{P5.14}

\end{cntrfig}
Указатель на число, например {\tt n4}, может
состоять из метки, указывающей, что это число, и собственно
представления числа 
4\footnote{\index{ru}{равенство|чисел||||п}\index{ru}{числа|равенство||||п}Решение 
о представлении чисел определяет, можно ли
сравнивать числа через {\tt eq?},\index{ru}{eq? (элементарная процедура)|и равенство чисел|||p|п}
который проверяет
одинаковость указателей. Если указатель содержит само число, то
равные числа будут иметь одинаковые указатели.  Однако если в
указателе содержится индекс ячейки,~в которой хранится само число, то
у равных чисел будут одинаковые указатели только~в том случае, если
нам удастся никогда не хранить одно и то же число~в двух местах.}.
Для того, чтобы работать с числами, не умещающимися
в ограниченном объеме, отводимом под указатель, может иметься особый
тип данных \index{ru}{большое число||bignum|||}\index{en}{bignum||большое число|||}{\em большое число} (bignum), для
которого указатель обозначает список, где хранятся части
числа\footnote{Это представление очень похоже на запись числа~в виде
последовательности цифр, только каждая <<цифра>> является числом между
0 и максимальным значением, которое можно уместить~в указателе.}.

\index{ru}{символ(ы)|представление||||}Символ можно представить как типизированный указатель,
обозначающий последовательность знаков, из которых состоит печатное
представление символа. Эта последовательность создается процедурой
чтения Лиспа, когда строка-представление~в первый раз встречается при вводе.
Поскольку мы хотим, чтобы два экземпляра символа всегда были <<одинаковы>> в
смысле {\tt eq?},
\index{ru}{eq? (элементарная процедура)|реализация для символов|||p|}
\index{ru}{eq? (элементарная процедура)|как равенство указателей|||p|}
а {\tt eq?} должно быть простым
сравнением указателей, нам нужно обеспечить, чтобы процедура чтения,
когда она видит ту же строку второй раз, использовала тот же самый
указатель (к той же последовательности знаков) для представления обоих
вхождений символа.  Ради этого процедура чтения содержит таблицу,
которая по традиции называется \index{ru}{обмассив||obarray|||}\index{en}{obarray||обмассив|||}{\em обмассив} (obarray),
и~в ней хранит все когда-либо встреченные символы.  Когда процедура
видит строку и готова создать символ, она проверяет~в обмассиве,
не было ли уже ранее такой же строки.  Если нет, она строит новый
символ со встретившейся строкой~в качестве имени (типизированный
указатель на последовательность знаков) и включает его~в обмассив.  Если
же процедура уже встречала указанную строку, она возвращает указатель
на символ, хранимый~в обмассиве.  Процесс замены строк печатных знаков
указателями без повторения называется  \index{ru}{символ(ы)|восприятие||||}
\index{ru}{восприятие||interning|||}\index{en}{interning||восприятие|||}{\em восприятием} (interning)
символов.

\paragraph{Реализация элементарных списковых операций}


Имея вышеописанную схему представления, можно заменить
каждую <<элементарную>> списковую операцию регистровой машины одной
или более элементарной векторной операцией.  Мы будем обозначать
векторы памяти двумя регистрами \index{ru}{the-cars|регистр|||p|}{\tt the-cars} и
\index{ru}{the-cdrs|регистр|||p|}
{\tt the-cdrs}, и предположим, что операции
{\tt vector-ref} и {\tt vector-set!} даны как
элементарные.  Кроме того, предположим, что численные операции с
указателями (добавление единицы, индексирование вектора с помощью
указателя на пару и сложение чисел) используют только индексную часть
типизированного указателя.
{\sloppy

}
Например, можно заставить регистровую машину поддерживать
команды

\begin{Verbatim}[fontsize=\small]
(assign \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} (op car) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))\index{ru}{car (элементарная процедура)|реализация через векторы|||p|}

(assign \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} (op cdr) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))\index{ru}{cdr (элементарная процедура)|реализация через векторы|||p|}
\end{Verbatim}
если мы реализуем их, соответственно, как

\begin{Verbatim}[fontsize=\small]
(assign \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} (op vector-ref) (reg the-cars) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))

(assign \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} (op vector-ref) (reg the-cdrs) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))
\end{Verbatim}
Команды

\begin{Verbatim}[fontsize=\small]
(perform (op set-car!) (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg \textit{$\langle$рег\textit{$\langle$2$\rangle$}$\rangle$}))

(perform (op set-cdr!) (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg \textit{$\langle$рег\textit{$\langle$2$\rangle$}$\rangle$}))
\end{Verbatim}
реализуются как

\begin{Verbatim}[fontsize=\small]
(perform 
 (op vector-set!) (reg the-cars) (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))

(perform 
 (op vector-set!) (reg the-cdrs) (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))
\end{Verbatim}
При выполнении {\tt cons} выделяется
неиспользуемый индекс, и аргументы {\tt cons} записываются в
{\tt the-cars} и {\tt the-cdrs}~в ячейках с выделенным
индексом.  Мы предполагаем, что имеется особый регистр
{\tt free},
\index{ru}{free, регистр||||p|}
в котором всегда содержится указатель на следующую
свободную пару, и что мы можем его увеличить и получить следующую
свободную ячейку\footnote{Имеются и другие способы поиска свободной памяти.
Например, можно было бы связать все неиспользуемые пары~в 
\index{ru}{список свободных ячеек||free list|||п}\index{en}{free list||список свободных ячеек|||п}{\em список свободных
ячеек} (free list). Наши свободные ячейки идут подряд, поскольку мы
пользуемся сжимающим сборщиком мусора, как будет описано~в 
разделе~\ref{MAINTAINING-THE-ILLUSION-OF-INFINITE-MEMORY}.
}.
Например, команда

\begin{Verbatim}[fontsize=\small]
(assign \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} (op cons) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}) (reg \textit{$\langle$рег ${}_{\mbox{3}}$$\rangle$}))\index{ru}{cons (элементарная процедура)|реализация через векторы|||p|}
\end{Verbatim}
реализуется как следующая последовательность векторных операций\footnote{В сущности, это реализация {\tt cons} через
{\tt set-car!} и {\tt set-cdr!}, как описано~в 
разделе~\ref{MUTABLE-LIST-STRUCTURE}.  Операция
{\tt get-new-pair}, которая там используется, здесь реализуется
через указатель {\tt free}.
}:

\begin{Verbatim}[fontsize=\small]
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg \textit{$\langle$рег${}_{\mbox{3}}$$\rangle$}))
(assign (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg free))
(assign free (op +) (reg free) (const 1))
\end{Verbatim}
Операция {\tt eq?}

\begin{Verbatim}[fontsize=\small]
(op eq?) (reg \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$}) (reg \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$})
\end{Verbatim}
попросту проверяет равенство всех полей регистров,~а предикаты вроде
{\tt pair?}, 
\index{ru}{pair? (элементарная процедура)|реализация через типизированные указатели|||p|}
{\tt null?}, 
\index{ru}{null? (элементарная процедура)|реализация через типизированные указатели|||p|}
{\tt symbol?} и
\index{ru}{symbol? (элементарная процедура)|реализация через типизированные указатели|||p|}
{\tt number?} 
\index{ru}{number? (элементарная процедура)|реализация через типизированные указатели|||p|}
смотрят только на поле типа.

\paragraph{Реализация стеков}


\index{ru}{стек|представление||||} Хотя наши регистровые машины используют стеки, нам ничего
специально здесь делать не надо, поскольку стеки можно смоделировать
на основе списков.  Стек может быть списком сохраненных значений, на
которые указывает особый регистр {\tt the-stack}.  \index{ru}{save (в регистровой машине)|реализация|||p|}
Таким
образом, {\tt (save \textit{$\langle$рег$\rangle$})} может
реализовываться как

\begin{Verbatim}[fontsize=\small]
(assign the-stack (op cons) (reg \textit{$\langle$рег$\rangle$}) (reg the-stack))
\end{Verbatim}
\index{ru}{restore (в регистровой машине)|реализация|||p|}
Подобным образом, {\tt (restore \textit{$\langle$рег$\rangle$})} можно
реализовать как

\begin{Verbatim}[fontsize=\small]
(assign \textit{$\langle$рег$\rangle$} (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
\end{Verbatim}
а {\tt (perform (op initialize-stack))} реализуется как
\index{ru}{initialize-stack, операция регистровой машины||||p|}

\begin{Verbatim}[fontsize=\small]
(assign the-stack (const ()))
\end{Verbatim}
Все эти операции можно далее расшифровать~в терминах векторных
операций, как показано выше.  Однако~в традиционных компьютерных
архитектурах обычно удобно выделять стек~в виде отдельного вектора.  В
таком случае сохранение на стеке и снятие с него реализуются через
увеличение и уменьшение индекса, указывающего~в этот вектор.
\begin{exercise}{5.20}%%
\label{EX5.20}%
Нарисуйте стрелочную диаграмму и представление~в виде
вектора (как на рисунке~\ref{P5.14}) списка, который
порождается кодом

\begin{Verbatim}[fontsize=\small]
(define x (cons 1 2))
(define y (list x x))
\end{Verbatim}
если вначале указатель {\tt free} равен {\tt p1}. Чему
равно значение {\tt free} после исполнения кода? Какие
указатели представляют значения {\tt x} и {\tt y}?
\end{exercise}
\begin{exercise}{5.21}%%
\label{EX5.21}%
Реализуйте регистровые машины для следующих процедур.
Считайте, что операции с памятью, реализующие списковую
структуру, имеются~в машине как примитивы.

\begin{plainenum}


\item
Рекурсивная {\tt count-leaves}:
\index{ru}{count-leaves|как регистровая машина|||p|(упр.~5.21)}

\begin{Verbatim}[fontsize=\small]
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
\end{Verbatim}

\item
Рекурсивная {\tt count-leaves} с явным
счетчиком:

\begin{Verbatim}[fontsize=\small]
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
\end{Verbatim}
\end{plainenum}
\end{exercise}
\begin{exercise}{5.22}%%
\label{EX5.22}%
В упражнении~\ref{EX3.12} из 
раздела~\ref{MUTABLE-LIST-STRUCTURE} были представлены процедура
{\tt append}, которая добавляет два списка друг к другу и
\index{ru}{append|как регистровая машина|||p|(упр.~5.22)}
получает третий, и процедура {\tt append!}, которая склеивает
\index{ru}{append!|как регистровая машина|||p|(упр.~5.22)}
два списка вместе. Спроектируйте регистровые машины, которые реализуют
каждую из этих процедур.  Предполагайте, что операции с памятью, реализующие списковую
структуру, являются примитивами.
\end{exercise}

\subsection{Иллюзия бесконечной памяти}
\label{MAINTAINING-THE-ILLUSION-OF-INFINITE-MEMORY}


\index{ru}{сборка мусора|||||}
Метод представления, намеченный~в 
разделе~\ref{MEMORY-AS-VECTORS}, решает задачу реализации
списковой структуры при условии, что у нас бесконечное количество
памяти.  В настоящем компьютере у нас~в конце концов кончится
свободное место, где можно строить новые пары\footnote{На самом деле и это может быть неправдой,
поскольку размеры памяти могут стать настолько большими, что свободная
память просто не успеет исчерпаться за время жизни компьютера.
Например,~в году примерно $3 \times 10^{13}$ секунд, так
что если мы будем вызывать {\tt cons} один раз~в микросекунду,
и у нас будет примерно $10^{15}$ ячеек памяти, то мы
построим машину, которая сможет работать 30 лет, пока память не
кончится.  По теперешним понятиям такое количество памяти кажется
абсурдно большим, однако физически оно вполне возможно.  С другой
стороны, процессоры становятся быстрее, и может быть, что в
компьютерах будущего будет по многу процессоров, работающих
параллельно~в единой памяти, так что память можно будет расходовать
намного быстрее, чем мы сейчас предполагаем.
}.
Однако большинство пар, порождаемых во время типичного вычисления,
используются только для хранения промежуточных результатов. После
того, как эти результаты обработаны, пары больше не нужны~--- они
становятся \index{ru}{мусор||garbage|||}\index{en}{garbage||мусор|||}{\em мусором} (garbage).  Например, при
выполнении

\begin{Verbatim}[fontsize=\small]
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
\end{Verbatim}
создается два списка: перечисление и результат его фильтрации.  После
того, как проводится накопление, эти списки больше не нужны, и
выделенную под них память можно освободить.  Если нам удастся
периодически собирать весь мусор, и память будет таким образом
освобождаться приблизительно с той же скоростью, с которой мы строим
новые пары, мы сможем поддерживать иллюзию, что у нас бесконечное
количество памяти.

Для того, чтобы освобождать пары, нужен способ
определять, какие из выделенных пар больше не нужны (в том смысле, что
их содержимое не может уже повлиять на будущее вычисления).  Метод, с
помощью которого мы этого добиваемся, называется \index{ru}{сборка мусора||garbage collection|||}\index{en}{garbage collection||сборка мусора|||}{\em сборка
мусора} (garbage collection).  Сборка мусора основана на наблюдении, что~в каждый
момент при интерпретации Лисп-программы на будущую судьбу вычисления могут
повлиять только те объекты, до которых можно добраться с помощью
какой-нибудь последовательности операций {\tt car} и
{\tt cdr}, начиная с указателей, хранимых~в этот момент в
регистрах машины\footnote{Здесь мы предполагаем, что стек представляется~в виде
списка, как описано~в разделе~\ref{MEMORY-AS-VECTORS}, так
что элементы стека доступны через указатель, хранящейся~в стековом
регистре.}.
Любую ячейку памяти, до которой так добраться нельзя, можно освободить.

Есть множество способов сборки мусора.  Метод, который мы
опишем здесь, называется\index{ru}{сборка мусора|через остановку с копированием|garbage collection|stop-and-copy||}\index{en}{garbage collection|stop-and-copy|сборка мусора|через остановку с копированием||}\index{ru}{сборщик мусора|остановка с копированием||||}
{\em остановка с копированием} (stop-and-copy).  Основная идея состоит~в том, чтобы разделить
память на две половины: <<рабочую память>> и <<свободную память>>.
Когда {\tt cons} строит пары, он это делает~в рабочей памяти.
Когда рабочая память заполняется, проводится сборка мусора: мы отыскиваем
все используемые пары~в рабочей памяти и копируем их в
последовательные ячейки свободной памяти. (Используемые пары ищутся
просмотром всех указателей {\tt car} и {\tt cdr},
начиная с машинных регистров.)  Поскольку мусор мы не копируем,
предполагается, что при этом появится дополнительная свободная память,
где можно выделять новые пары.  Кроме того,~в рабочей памяти
не осталось ничего нужного, поскольку все полезные пары из нее
скопированы~в свободную память.  Таким образом, если мы поменяем роли
рабочей и свободной памяти, мы можем продолжить работу; новые пары
будут выделяться~в новой рабочей памяти (бывшей свободной).  Когда
она заполнится, мы можем скопировать используемые пары из нее~в новую
свободную память (старую рабочую)\footnote{Эта идея была придумана и впервые реализована Минским,
\index{ru}{Минский, Марвин||Marvin Minsky||n|п}\index{en}{Marvin Minsky||Минский, Марвин||n|п}
как часть реализации  \index{ru}{Lisp (Лисп)|на DEC PDP-1||||п}
Лиспа для машины PDP-1~в  \index{ru}{MIT|Исследовательская лаборатория по Электронике||||п}Исследовательской 
лаборатории Электроники~в MIT.  Ее дополнили Феничель и Йохельсон
(Fenichel and Yochelson 1969) для реализации Лиспа в
\index{ru}{Феничель, Роберт||Robert Fenichel||n|п}\index{en}{Robert Fenichel||Феничель, Роберт||n|п}
\index{ru}{Йохельсон, Джером~К.||Jerome~C. Yochelson||n|п}\index{en}{Jerome~C. Yochelson||Йохельсон, Джером~К.||n|п}
системе разделения времени 
\index{ru}{Multics, система разделения времени||Multics time-sharing system|||п}\index{en}{Multics time-sharing system||Multics, система разделения времени|||п}
Multics. Позднее Бейкер 
(Baker 1978)
\index{ru}{Бейкер, Генри~Дж., мл.||Henry~J. Baker Jr.||n|п}\index{en}{Henry~J. Baker Jr.||Бейкер, Генри~Дж., мл.||n|п}
разработал версию для <<реального
времени>>, в которой не требуется останавливать вычисления на время
сборки.  Идею Бейкера расширили Хьюитт, Либерман и Мун 
(Lieberman and Hewitt 1983), использовав то, что часть
структуры более подвижна,~а часть более постоянна.
\index{ru}{Хьюитт, Карл Эдди||Carl Eddie Hewitt||n|п}\index{en}{Carl Eddie Hewitt||Хьюитт, Карл Эдди||n|п}
\index{ru}{Либерман, Генри||Henry Lieberman||n|п}\index{en}{Henry Lieberman||Либерман, Генри||n|п}
\index{ru}{Мун, Дэвид~А.||David~A. Moon||n|п}\index{en}{David~A. Moon||Мун, Дэвид~А.||n|п}


Второй часто используемый метод сборки мусора~--- это
\index{ru}{сборщик мусора|через пометку с очисткой||||п}
\index{ru}{пометка с очисткой||mark-sweep|||п}\index{en}{mark-sweep||пометка с очисткой|||п}
\index{ru}{сборка мусора|через пометку с очисткой|garbage collection|mark-sweep||п}\index{en}{garbage collection|mark-sweep|сборка мусора|через пометку с очисткой||п}{\em пометка с очисткой} (mark-sweep). Он состоит~в том, что все
структуры, доступные из машинных регистров, просматриваются и
помечаются. Затем вся память просматривается, и всякий непомеченный
участок <<вычищается>> как мусор и объявляется свободным.  Полное
обсуждение метода пометки с очисткой можно найти~в 
Allen 1978.
\index{ru}{Аллен, Джон||John Allen||n|п}\index{en}{John Allen||Аллен, Джон||n|п}

В системах с большой памятью, как правило, используется
алгоритм Минского-Феничеля-Йохельсона, поскольку он просматривает
только используемую часть памяти.  Напротив, при
методе пометки с очисткой фаза очистки должна проверять всю память.
Второе преимущество остановки с копированием состоит~в том, что это
\index{ru}{сборщик мусора|сжимающий||||п}
\index{ru}{сжимающий сборщик мусора||compacting     garbage collector|||п}\index{en}{compacting     garbage collector||сжимающий сборщик мусора|||п}
\index{ru}{сборка мусора|сжимающая|garbage collection|compacting||п}\index{en}{garbage collection|compacting|сборка мусора|сжимающая||п}{\em сжимающий} (compacting)
сборщик мусора.  Это означает, что в конце фазы сборки мусора все
используемые данные оказываются в последовательной области памяти, а
весь мусор <<выжат>>. На машинах с виртуальной памятью это может давать
весьма большой выигрыш в производительности, поскольку доступ к сильно
различающимся адресам в памяти может приводить к дополнительной
подкачке страниц.
}.

\paragraph{Реализация сборщика мусора методом остановки с
копированием}


Теперь мы можем с помощью языка регистровых машин описать
алгоритм остановки с копированием более подробно.  Предположим, что
имеется \index{ru}{root, регистр||||p|}регистр {\tt root}, и~в нем хранится указатель на
корневой объект~--- структуру, которая (через перенаправления) указывает на все доступные
данные.  Такой конфигурации можно добиться, если переместить содержимое всех
регистров машины~в заранее выделенный список, на который и будет
указывать {\tt root}, непосредственно перед запуском сборщика
мусора\footnote{Этот список регистров не включает~в себя регистры,
которые используются подсистемой выделения памяти~---
{\tt root}, {\tt the-cars}, {\tt the-cdrs} и еще
несколько регистров, которые будут введены~в этом разделе.}.
Кроме того, мы предполагаем, что помимо текущей рабочей памяти имеется
свободная память,~в которую мы можем копировать используемые данные.
Текущая рабочая память состоит из векторов, базовые адреса которых
хранятся~в регистрах {\tt the-cars}\index{ru}{the-cars|регистр|||p|}
и {\tt the-cdrs}, а
\index{ru}{the-cdrs|регистр|||p|}свободная память доступна через регистры {\tt new-cars}\index{ru}{new-cars, регистр||||p|}
и {\tt new-cdrs}.\index{ru}{new-cdrs, регистр||||p|}

Сборка мусора запускается, когда кончаются
свободные ячейки~в текущей рабочей памяти, то есть когда операция
{\tt cons} пытается сдвинуть указатель {\tt free} за
пределы вектора памяти.  По завершении сборки мусора
указатель {\tt root} будет указывать на новую память, все
объекты, доступные через {\tt root}, будут перемещены~в новую
память,~а указатель {\tt free} будет указывать на место~в новой
памяти, начиная с которого можно выделять новые пары.  Кроме того,
поменяются местами роли рабочей памяти и свободной памяти~---
новые пары будут выделяться~в новой памяти, начиная с места, на которое
показывает {\tt free},~а (предыдущая) рабочая память будет
доступна~в качестве новой памяти для следующей сборки мусора. На
рисунке~\ref{P5.15} показано устройство памяти
непосредственно перед сборкой мусора и сразу после нее.


\begin{cntrfig}
%\begin{tabular}{lll}
%{\tt\bf{the-cars}} & \fbox{смесь полезных данных и мусора} & рабочая память \\
%{\tt\bf{the-cdrs}} & &
%\end{tabular}
%\hspace{4cm}$\uparrow$
%
%\hspace{4cm} свободная 

\input{xfig-mod/5-15.eepic}

%{\small Непосредственно перед сборкой мусора
%смесь полезных данных и мусора
%рабочая память
%свободная память
%
%Сразу после сборки мусора
%освобожденная память
%полезные данные
%свободная область
%новая свободная память
%новая рабочая память}
\caption{Перестройка памяти~в процессе сборки мусора.}
\label{P5.15}
\end{cntrfig}

Состояние процесса сборки мусора управляется содержимым
двух регистров: {\tt free} 
\index{ru}{free, регистр||||p|}
и {\tt scan}.  Оба они
\index{ru}{scan, регистр||||p|}
сначала указывают на начало новой памяти.  При запуске алгоритма пара, на
которую указывает {\tt root}, переносится~в начало новой
памяти. Пара копируется, регистр {\tt root} переставляется в
новое место,~а указатель {\tt free} увеличивается на единицу.
В дополнение к этому~в старом месте, где хранилась пара, делается
пометка, которая говорит, что содержимое перенесено.  Отметка
делается так:~в позицию {\tt car} мы помещаем особое значение,
показывающее, что объект перемещен. (По традиции, такой объект
называется \index{ru}{разбитое сердце||broken heart|||}\index{en}{broken heart||разбитое сердце|||}{\em разбитое
сердце} (broken heart).)\footnote{Термин {\em разбитое сердце} придумал Дэвид
Кресси,\index{ru}{Кресси, Дэвид||David Cressey||n|п}\index{en}{David Cressey||Кресси, Дэвид||n|п}
когда он писал сборщик мусора для  
\index{ru}{диалекты Лиспа|MDL||||п}\index{ru}{MDL|||||п}MDL, диалекта Лиспа,
разработанного~в MIT~в начале 70-х годов.
}
В позицию {\tt cdr} мы помещаем \index{ru}{перенаправляющий адрес||forwarding address|||}\index{en}{forwarding address||перенаправляющий адрес|||}{\em перенаправляющий
адрес} (forwarding address), который указывает на место, куда перемещен объект.

После того, как перемещен корневой объект, сборщик мусора
входит~в основной цикл. На каждом шаге алгоритма регистр
{\tt scan} (вначале он указывает на перемещенный корневой
объект) содержит адрес пары, которая сама перемещена~в новую память, но
{\tt car} и {\tt cdr} которой по-прежнему указывают на
объекты~в старой памяти.  Каждый из этих объектов перемещается, а
затем регистр {\tt scan} увеличивается на единицу.  При
перемещении объекта (например, того, на который указывает
{\tt car} сканируемой пары) мы прежде всего проверяем, не
перемещен ли он уже (об этом нам говорит разбитое сердце~в позиции
{\tt car} объекта).  Если объект еще не перемещен, мы переносим
его~в место, на которое указывает {\tt free}, увеличиваем
{\tt free}, записываем разбитое сердце по старому
местоположению объекта, и обновляем указатель на объект (в нашем
случае, {\tt car} пары, которую мы сканируем) так, чтобы он
показывал на новое место.  Если же объект уже был перемещен, то его
перенаправляющий адрес (он находится~в позиции {\tt cdr}
разбитого сердца) подставляется на место указателя~в сканируемой
паре.  В конце концов все доступные объекты окажутся перемещены и
просканированы.  В этот момент указатель {\tt scan} догонит
указатель {\tt free}, и процесс завершится.

Алгоритм остановки с копированием можно описать как
последовательность команд регистровой машины.  Базовый шаг, состоящий
в перемещении объекта, проделывается подпрограммой
{\tt relocate-old-result-in-new}.  Эта подпрограмма принимает
свой аргумент, указатель на объект, подлежащий перемещению,~в регистре
{\tt old}.
\index{ru}{old, регистр||||p|}
Она перемещает данный объект (по пути обновляя
{\tt free}), помещает указатель на перемещенный объект в
регистр {\tt new}, 
\index{ru}{new, регистр||||p|}
и возвращается, переходя на точку
входа, хранимую~в регистре {\tt relocate-continue}.  В начале
процесса сборки мы с помощью этой подпрограммы перемещаем указатель
{\tt root}, после инициализации {\tt free} и
{\tt scan}. Когда {\tt root} перемещен, мы записываем
новый указатель~в регистр {\tt root} и входим~в основной цикл
сборщика мусора.

\begin{Verbatim}[fontsize=\small]
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
\end{Verbatim}

В основном цикле сборщика мусора нам нужно определить,
есть ли еще подлежащие сканированию объекты.  Для этого мы проверяем,
совпадает ли указатель {\tt scan} с указателем
{\tt free}.  Если указатели равны, значит, все
доступные объекты перемещены, и мы переходим на {\tt gc-flip}.
По этому адресу расположены восстановительные действия, после которых
можно продолжить прерванные вычисления.  Если же еще есть пары,
которые требуется просканировать, мы зовем подпрограмму перемещения
для {\tt car} следующей пары (при вызове мы
помещаем указатель {\tt car}~в регистр
{\tt old}). Регистр {\tt relocate-continue}
устанавливается таким образом, чтобы при возврате мы могли обновить
указатель {\tt car}.

\begin{Verbatim}[fontsize=\small]
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
\end{Verbatim}

На метке {\tt update-car} мы изменяем указатель
{\tt car} сканируемой пары.  После этого мы перемещаем ее
{\tt cdr},~а затем возвращаемся на метку
{\tt update-cdr}.  Наконец, когда {\tt cdr} перемещен и
обновлен, сканирование пары закончено, и мы продолжаем главный цикл.

\begin{Verbatim}[fontsize=\small]
update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
\end{Verbatim}

Подпрограмма {\tt relocate-old-result-in-new}
перемещает объекты следующим образом: если перемещаемый объект (на
него указывает {\tt old}) не является парой, мы возвращаем
указатель на него неизменным (в регистре {\tt new}). (К
примеру, мы можем сканировать пару,~в {\tt car} которой
находится число 4.  Если значение~в {\tt car} представляется
как {\tt n4}, как описано~в 
разделе~\ref{MEMORY-AS-VECTORS}, то нам нужно, чтобы
<<перемещенный>> {\tt car} по-прежнему равнялся
{\tt n4}.)  В противном случае требуется произвести
перемещение.  Если позиция {\tt car} перемещаемой пары содержит
метку разбитого сердца, значит, сама пара уже перенесена, и нам
остается только взять перенаправляющий адрес (из позиции
{\tt cdr} разбитого сердца) и вернуть его~в регистре
{\tt new}.  Если же  регистр {\tt old} указывает на еще
пе перенесенную пару, то мы ее переносим~в первую пустую ячейку новой
памяти (на нее указывает {\tt free}),~а затем строим разбитое
сердце, записывая~в старой ячейке метку разбитого сердца и
перенаправляющий адрес.  Процедура
{\tt relocate-old-result-in-new} хранит {\tt car} или
{\tt cdr} объекта, на который указывает {\tt old}, в
\index{ru}{oldcr, регистр||||p|}
регистре {\tt oldcr}\footnote{Сборщик мусора использует низкоуровневый предикат
{\tt pointer-to-pair?} вместо обыкновенного {\tt pair?},
поскольку~в настоящей системе могут иметься различные объекты, которые с
точки зрения сборщика будут являться парами.  Например,~в системе,
которая соответствует стандарту Scheme IEEE, объект-процедура может
реализовываться особого рода <<парой>>, которая не удовлетворяет
предикату {\tt pair?}.  В нашем имитаторе можно реализовать
{\tt pointer-to-pair?} как {\tt pair?}.
}.

\begin{Verbatim}[fontsize=\small]
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) {\em ; новое место для пары }
  {\em ;; Обновить указатель {\tt free}.}
  (assign free (op +) (reg free) (const 1))
  {\em ;; Скопировать {\tt car} и {\tt cdr}~в новую память.}
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  {\em ;; Построить разбитое сердце.}
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
\end{Verbatim}

В самом конце процесса сборки мусора мы меняем ролями старую и
новую память, обменивая указатели: {\tt cars} меняется с
{\tt new-cars},~а {\tt cdrs} с {\tt new-cdrs}.
Теперь мы готовы запустить следующую сборку, когда память опять
кончится.

\begin{Verbatim}[fontsize=\small]
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
\end{Verbatim}

\section{Вычислитель с явным управлением}
\label{THE-EXPLICIT-CONTROL-EVALUATOR}


В разделе~\ref{DESIGNING-REGISTER-MACHINES} мы
видели, как простые программы на Scheme можно преобразовывать~в описания
регистровых машин.  Теперь мы проделаем такое преобразование с более
сложной программой~--- метациклическим интерпретатором из 
разделов~\ref{THE-CORE-OF-THE-EVALUATOR}--\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM},
который показал нам, как поведение процедур Scheme можно описать через
процедуры {\tt eval} и {\tt apply}.
\index{ru}{вычислитель с явным управлением для Scheme||explicit-control evaluator for Scheme|||}\index{en}{explicit-control evaluator for Scheme||вычислитель с явным управлением для Scheme|||}{\em Вычислитель с явным
управлением} (explicit-control evaluator), который мы разработаем~в этом разделе, демонстрирует,
как механизмы вызова процедур и передачи параметров, используемые в
процессе вычисления, могут быть описаны~в терминах действий,
производимых над регистрами и стеками.  В дополнение к этому
вычислитель с явным управлением может служить реализацией
интерпретатора Scheme, написанной на языке, весьма близком к машинному
языку обыкновенных компьютеров.  Этот вычислитель можно выполнить на
имитаторе регистровых машин из 
раздела~\ref{A-REGISTER-MACHINE-SIMULATOR}.  С другой стороны, его
можно использовать как основу для построения вычислителя Scheme,
написанного на машинном языке, 
\index{ru}{микросхема для Scheme||Scheme chip|||}\index{en}{Scheme chip||микросхема для Scheme|||} 
или даже специализированной машины для
вычисления выражений на Scheme.  На рисунке~\ref{P5.16}
показана такая аппаратная реализация: кремниевый чип, который работает
как вычислитель Scheme.  Проектировщики чипа начали с описания путей
данных и контроллера, подобного вычислителю из этого раздела,~а затем с
помощью программ автоматизированного проектирования построили разводку
интегральной микросхемы\footnote{Информацию о микросхеме и методе ее проектирования можно
найти~в Batali et al. 1982.
\index{ru}{Батали, Джон Дин||John Dean Batali||n|п}\index{en}{John Dean Batali||Батали, Джон Дин||n|п}
}.


\begin{cntrfig}
\includegraphics{chip.ps}
\caption{Реализация вычислителя для Scheme~в виде
кремниевой микросхемы.
\index{ru}{микросхема для Scheme|||||}}
\label{P5.16}

\end{cntrfig}

\paragraph{Регистры и операции}


\index{ru}{вычислитель с явным управлением для Scheme|пути данных||||} 
\index{ru}{вычислитель с явным управлением для Scheme|операции||||}
При проектировании вычислителя с
явным управлением требуется 
указать операции, которые будут использоваться~в нашей
регистровой машине.  Метациклический интерпретатор мы описали,
используя абстрактный синтаксис, с процедурами вроде
{\tt quoted?} и {\tt make-procedure}.  При реализации
регистровой машины мы могли бы развернуть эти процедуры в
последовательности элементарных операций с памятью, работающих со
списковой структурой, и уже эти операции реализовать~в нашей
регистровой машине.  Однако при этом вычислитель получился бы слишком
длинным,~а его структура была бы загромождена мелкими деталями.  Для
большей ясности представления мы будем считать элементарными
операциями регистровой машины синтаксические процедуры из 
раздела~\ref{REPRESENTING-EXPRESSIONS},~а также процедуры для
представления окружений и прочих данных интерпретатора из 
разделов~\ref{EVALUATOR-DATA-STRUCTURES} и 
\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.  Для того, чтобы
полностью описать вычислитель, который можно было бы запрограммировать на
машинном языке низкого уровня или реализовать аппаратно, пришлось бы
заменить эти операции более примитивными на основе реализации
списковой структуры, которую мы описали~в 
разделе~\ref{STORAGE-ALLOCATION-AND-GARBAGE-COLLECTION}.

 \index{ru}{микросхема для Scheme|||||}Наша регистровая машина-вычислитель Scheme имеет стек и
семь \index{ru}{вычислитель с явным управлением для Scheme|регистры||||}регистров: {\tt exp},
{\tt env}, 
\index{ru}{val, регистр||||p|}
{\tt val},
{\tt continue}, {\tt proc}, {\tt argl} и
\index{ru}{unev, регистр||||p|}
{\tt unev}.  В регистре {\tt exp}
\index{ru}{exp, регистр||||p|}
хранится выражение,
подлежащее вычислению,~а~в регистре {\tt env}
\index{ru}{env, регистр||||p|}
окружение, в
котором нужно это вычисление произвести. В конце вычисления
{\tt val} содержит значение, полученное при вычислении
выражения~в указанном окружении.  Регистр 
{\tt continue}
\index{ru}{continue, регистр|в вычислителе с явным управлением|||pd|}
используется для реализации рекурсии, как описано~в 
разделе~\ref{USING-A-STACK-TO-IMPLEMENT-RECURSION}.  (Вычислитель
вызывает сам себя рекурсивно, поскольку вычисление выражения требует
вычисления его подвыражений.)  Регистры
{\tt proc}, {\tt argl} и {\tt unev} используются
\index{ru}{proc, регистр||||p|}%
\index{ru}{argl, регистр||||p|}%
\index{ru}{unev, регистр||||p|}%
при работе с комбинациями.

Мы не будем ни рисовать диаграмму путей данных,
показывающую, как связаны между собой регистры и операции,
ни давать полный список машинных операций.  Эти данные можно получить
из текста контроллера, который будет представлен полностью.

\subsection{Ядро вычислителя с явным управлением}
\label{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}


Центральным элементом вычислителя является
\index{ru}{вычислитель с явным управлением для Scheme|контроллер||||}последовательность команд, расположенная по метке
{\tt eval-dispatch}.  Она соответствует процедуре
{\tt eval} метациклического интерпретатора из 
раздела~\ref{THE-CORE-OF-THE-EVALUATOR}.  Начиная с
{\tt eval-dis\-patch}, контроллер вычисляет выражение, хранящееся
в {\tt exp},~в окружении, которое содержится в
{\tt env}.  Когда вычисление заканчивается, контроллер
переходит на точку входа, которая хранится~в {\tt continue},
а значение выражения при этом находится~в {\tt val}.  Как и
в метациклическом {\tt eval}, структура
{\tt eval-dispatch} представляет собой анализ случаев по
синтаксическому типу выполняемого выражения\footnote{В нашем контроллере анализ случаев написан как
последовательность команд {\tt test} и {\tt branch}.
Можно было бы написать его и~в стиле программирования, управляемого
данными (в реальной системе так, скорее всего, и было бы сделано). При
этом исчезла бы необходимость проводить последовательные проверки, и
легче было бы определять новые типы выражений.  Машина, рассчитанная
на выполнение Лисп-программ, скорее всего, имела бы команду
{\tt dispatch-on-type}, которая бы эффективно выполняла выбор,
управляемый данными.
}.

\begin{Verbatim}[fontsize=\small]
eval-dispatch\index{ru}{eval-dispatch||||pd|}
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
\end{Verbatim}

\paragraph{Вычисление простых выражений}


\index{ru}{вычислитель с явным управлением для Scheme|выражения без подвыражений, подлежащих вычислению||||}
В числах и строках (значением которых являются они сами),
переменных, закавыченных выражениях и выражениях {\tt lambda}
не содержится подлежащих вычислению подвыражений.  В этих случаях
вычислитель попросту помещает нужное значение~в регистр
{\tt val} и продолжает работу с точки, указанной~в регистре
{\tt continue}.  Вычисление простых выражений производится
следующим кодом контроллера:

\begin{Verbatim}[fontsize=\small]
ev-self-eval\index{ru}{ev-self-eval||||pd|}
  (assign val (reg exp))
  (goto (reg continue))
ev-variable\index{ru}{ev-variable||||pd|}
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
ev-quoted\index{ru}{ev-quoted||||pd|}
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
ev-lambda\index{ru}{ev-lambda||||pd|}
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
  (goto (reg continue))
\end{Verbatim}
Обратите внимание, как {\tt ev-lambda} пользуется регистрами
{\tt unev} и {\tt exp} для параметров и тела
лямбда-выражения, которые наряду с окружением~в регистре
{\tt env} требуется передать операции
{\tt make-procedure}.

\paragraph{Вычисление вызовов процедур}


\index{ru}{вычислитель с явным управлением для Scheme|применение процедур||||}
Вызов процедуры описывается \index{ru}{вычислитель с явным управлением для Scheme|комбинации||||}комбинацией, состоящей из
оператора и операндов.  Оператор~--- подвыражение, значением которого
является процедура,~а операнды~--- подвыражения, значения которых
являются аргументами, к которым процедуру следует применить.
Метациклический {\tt eval} при обработке вызовов зовет себя
рекурсивно и вычисляет таким образом все элементы комбинации,~а затем
передает результаты~в {\tt apply}, которая и осуществляет
собственно применение процедуры.  \index{ru}{вычислитель с явным управлением для Scheme|использование стека||||}Вычислитель с явным управлением  
ведет себя точно так же; рекурсивные вызовы осуществляются командами
{\tt goto}, и при этом на стеке сохраняются регистры, значения
которых нужно восстановить после возврата из рекурсивного вызова.
Перед каждым вызовом мы тщательно смотрим, какие именно регистры
требуется сохранить (поскольку их значения потребуются
позже)\footnote{Это важная, но сложная деталь при переводе алгоритмов
из процедурного языка типа Лиспа на язык регистровой машины.  В
качестве альтернативы сохранению только нужных регистров мы могли бы
сохранять их все (кроме {\tt val}) перед каждым рекурсивным
вызовом.  Такая тактика называется 
\index{ru}{стек|кадрированный||||п}
%\index{ru}{кадрированного стека, дисциплина|||||п}
\index{ru}{дисциплина кадрированного стека||framed-stack discipline|||п}\index{en}{framed-stack discipline||дисциплина кадрированного стека|||п}{\em дисциплиной
кадрированного стека} (framed-stack discipline).  Она работает, но при этом сохраняется
больше регистров, чем нужно;~в системе, где стековые операции дороги,
это может оказаться важным.  Кроме того, сохранение регистров,
с ненужными значениями может привести к удлиннению жизни
бесполезных данных, которые~в противном случае освободились бы
при сборке мусора.
}.

В начале обработки процедурного вызова мы вычисляем
оператор и получаем процедуру, которую позже надо будет применить к
вычисленным операндам.  Для того, чтобы вычислить оператор, мы
переносим его~в регистр {\tt exp} и переходим на
{\tt eval-dispatch}.  В регистре {\tt env} уже
находится то окружение,~в котором оператор требуется вычислить.
Однако мы сохраняем {\tt env}, поскольку его значение нам еще
потребуется для вычисления операндов.  Кроме того, мы переносим
операнды~в регистр {\tt unev} и сохраняем его на стеке.
Регистр {\tt continue} мы устанавливаем так, чтобы после
вычисления оператора работа продолжилась с
{\tt ev-appl-did-operator}.  Однако перед этим мы сохраняем
старое значение {\tt continue}, поскольку оно говорит нам, куда
требуется перейти после вычисления вызова.

\pagebreak

\begin{Verbatim}[fontsize=\small]
ev-application\index{ru}{ev-application||||pd|}
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
\end{Verbatim}

После того, как вычислено значение
подвыражения-оператора, мы вычисляем \index{ru}{вычислитель с явным управлением для Scheme|вычисление операндов||||}
операнды комбинации и собираем их 
значения~в список, хранимый~в регистре {\tt argl}.  Прежде
всего мы восстанавливаем невычисленные операнды и окружение.  Мы
заносим пустой список~в {\tt argl} как начальное значение.
Затем заносим~в регистр {\tt proc} процедуру, порожденную
при вычислении оператора.  Если операндов нет, мы напрямую идем в
{\tt apply-dispatch}.  В противном случае сохраняем
{\tt proc} на стеке и запускаем цикл вычисления
операндов\footnote{К процедурам работы со структурой данных вычислителя
из раздела~\ref{EVALUATOR-DATA-STRUCTURES} мы добавляем
следующие процедуры для работы со списками аргументов:

\begin{Verbatim}
(define (empty-arglist) '())\index{ru}{empty-arglist||||pd|п}
(define (adjoin-arg arg arglist)\index{ru}{adjoin-arg||||pd|п}
  (append arglist (list arg)))
\end{Verbatim}
Кроме того, мы проверяем, является ли аргумент~в комбинации последним,
при помощи дополнительной синтаксической процедуры:

\begin{Verbatim}
(define (last-operand? ops)\index{ru}{last-operand?||||pd|п}
  (null? (cdr ops)))
\end{Verbatim}
}: %%FOOTNOTE!

\begin{Verbatim}[fontsize=\small]
ev-appl-did-operator
  (restore unev)                  {\em ; операнды }
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))         {\em ; оператор }
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
\end{Verbatim}

При каждом проходе цикла вычисления аргументов
вычисляется один аргумент, и его значение добавляется к
{\tt argl}.  Для того, чтобы вычислить операнд, мы помещаем его
в регистр {\tt exp} и переходим к {\tt eval-dispatch},
установив предварительно {\tt continue} так, чтобы вычисление
продолжилось на фазе сбора аргументов.  Но еще до этого мы
сохраняем уже собранные аргументы (из {\tt argl}), окружение
(из {\tt env}) и оставшиеся операнды, подлежащие вычислению (из
{\tt unev}).  Вычисление последнего операнда считается особым
случаем и обрабатывается кодом по метке {\tt ev-appl-last-arg}.

\begin{Verbatim}[fontsize=\small]
ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
\end{Verbatim}

После того, как аргумент вычислен, его значение
подсоединяется~в конец списка, который хранится~в {\tt argl}.
Затем операнд убирается из списка невычисленных операндов в
{\tt unev}, и продолжается цикл вычисления аргументов.

\begin{Verbatim}[fontsize=\small]
ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
\end{Verbatim}

Последний аргумент обрабатывается отдельно.  Здесь нет
необходимости сохранять окружение и список невычисленных операндов
перед переходом~в {\tt eval-dispatch}, поскольку после
вычисления последнего операнда они не понадобятся.  Поэтому после
вычисления мы возвращаемся к метке
{\tt ev-appl-ac\-cum-last-arg}, где восстанавливается список
аргументов, на него наращивается новый (последний) аргумент,
восстанавливается сохраненная процедура, и, наконец, происходит
переход к применению процедуры\footnote{Оптимизация при обработке последнего аргумента
известна как \index{ru}{хвостовая рекурсия~в списке аргументов||evlis tail recursion|||п}\index{en}{evlis tail recursion||хвостовая рекурсия~в списке аргументов|||п}{\em хвостовая рекурсия~в списке
аргументов} (evlis tail recursion) (см. Wand 1980).  
\index{ru}{Ванд, Митчелл||Mitchell Wand||n|п}\index{en}{Mitchell Wand||Ванд, Митчелл||n|п}
Можно было бы
особым образом обрабатывать еще и первый аргумент и получить некоторую
дополнительную выгоду.  Это позволило бы отложить инициализацию
{\tt argl} до того времени, когда будет вычислен первый операнд, и
избежать~в этом случае сохранения {\tt argl}.  Компилятор в
разделе~\ref{COMPILATION} проделывает эту оптимизацию.
(Сравните с процедурой {\tt construct-arglist} из 
раздела~\ref{COMPILING-COMBINATIONS}.)
}:

\begin{Verbatim}[fontsize=\small]
ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
\end{Verbatim}

Детали цикла вычисления аргументов определяют 
\index{ru}{порядок вычисления|в вычислителе с явным управлением||||}
порядок,~в котором интерпретатор вычисляет операнды комбинации (то есть справа
налево или слева направо~--- см.~упражнение~\ref{EX3.8}).
Этот порядок оставался неопределенным~в метациклическом
интерпретаторе, который наследует свою управляющую структуру из
нижележащей Scheme, на которой он написан\footnote{Порядок вычисления операндов~в метациклическом
интерпретаторе определяется порядком вычисления аргументов
{\tt cons}~в процедуре {\tt list-of-values} из 
раздела~\ref{THE-CORE-OF-THE-EVALUATOR} 
(см.~упражнение~\ref{EX4.1}).
}.
Поскольку селектор {\tt first-operand} (который используется в
{\tt ev-appl-operand-loop} для последовательного извлечения
операндов из {\tt unev}) реализован как {\tt car}, а
селектор {\tt rest-operands} реализуется как {\tt cdr},
вычислитель с явным управлением будет вычислять операнды комбинации в
порядке слева направо.

\paragraph{Применение процедур}


Точка входа {\tt apply-dispatch} соответствует
процедуре {\tt apply} метациклического интерпретатора.  К тому
времени, когда мы попадаем~в {\tt apply-dispatch},~в регистре
{\tt proc} содержится подлежащая применению процедура,~а в
регистре {\tt argl} список вычисленных аргументов, к которым ее
требуется применить.  Сохраненное значение {\tt continue}
(исходно оно передается подпрограмме {\tt eval-dispatch}, а
затем сохраняется внутри {\tt ev-application}), которое
определяет, куда нам надо вернуться с результатом применения
процедуры, находится на стеке.  Когда вызов вычислен, контроллер
передает управление~в точку входа, указанную~в сохраненном
{\tt continue},~а результат при этом хранится в
{\tt val}.  Подобно метациклическому {\tt apply}, нужно
рассмотреть два случая.  Либо применяемая процедура является
примитивом, либо это составная процедура.

\begin{Verbatim}[fontsize=\small]
apply-dispatch\index{ru}{apply-dispatch||||pd|}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
\end{Verbatim}

\index{ru}{вычислитель с явным управлением для Scheme|элементарные процедуры||||}
Мы предполагаем, что все примитивы реализованы так, что
они ожидают аргументы~в регистре {\tt argl},~а результат
возвращают~в {\tt val}.  Чтобы описать, как машина обрабатывает
примитивы, нам пришлось бы дать последовательность команд, которая
реализует каждый примитив, и заставить {\tt primitive-apply}
переходить к этим командам~в зависимости от содержимого
{\tt proc}.  Поскольку нас интересуют не детали примитивов, а
структура процесса вычисления, мы вместо этого будем просто
использовать операцию {\tt apply-primitive-procedure}, которая
применяет процедуру, содержащуюся~в {\tt proc}, к аргументам,
содержащимся~в {\tt argl}.  Чтобы смоделировать
вычислитель имитатором из 
раздела~\ref{A-REGISTER-MACHINE-SIMULATOR}, мы используем
процедуру {\tt apply-primitive\-procedure}, которая исполняет
процедуру с помощью нижележащей Scheme-системы, как мы это делали и в
метациклическом интерпретаторе из
раздела~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.  После того, как
элементарная процедура вычислена, мы восстанавливаем  регистр
{\tt continue} и переходим на указанную точку входа.

\begin{Verbatim}[fontsize=\small]
primitive-apply  \index{ru}{primitive-apply||||pd|}
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
\end{Verbatim}

Чтобы применить \index{ru}{вычислитель с явным управлением для Scheme|составная процедура||||} составную
процедуру, мы действуем так же, 
как и~в метациклическом интерпретаторе.   Мы строим кадр, который
связывает параметры процедуры с ее аргументами, расширяем этим кадром
окружение, хранимое~в процедуре, и~в этом расширенном окружении
вычисляем последовательность выражений, которая представляет собой
тело процедуры.  Подпрограмма {\tt ev-sequence}, описанная ниже
в разделе~\ref{SEQUENCE-EVALUATION-AND-TAIL-RECURSION},
проводит вычисление последовательности.

\begin{Verbatim}[fontsize=\small]
compound-apply\index{ru}{compound-apply||||pd|}
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
\end{Verbatim}

Подпрограмма {\tt compound-apply}~--- единственное
место~в интерпретаторе, где регистру {\tt env} присваивается
новое значение.  Подобно метациклическому интерпретатору, новое
окружение строится из окружения, хранимого~в процедуре,~а также списка
аргументов и соответствующего ему списка связываемых переменных.

\subsection{Вычисление последовательностей и хвостовая
рекурсия}
\label{SEQUENCE-EVALUATION-AND-TAIL-RECURSION}


\index{ru}{вычислитель с явным управлением для Scheme|последовательности выражений||||}
Сегмент кода вычислителя с явным управлением, начинающийся
с метки {\tt ev-sequence}, соответствует процедуре
{\tt eval-sequence} метациклического интерпретатора.  Он
обрабатывает последовательности выражений~в телах процедур,~а также
явные выражения {\tt begin}.

Явные выражения {\tt begin} обрабатываются так:
последовательность подлежащих выполнению выражений помещается в
{\tt unev}, регистр {\tt continue} сохраняется на стеке,
а затем происходит переход на {\tt ev-sequence}.

\begin{Verbatim}[fontsize=\small]
ev-begin\index{ru}{ev-begin||||pd|}
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
\end{Verbatim}
Неявные последовательности~в телах процедур обрабатываются переходом
на {\tt ev-sequence} из {\tt compound-apply}, причем
{\tt continue}~в этот момент уже находится на стеке, поскольку
он был сохранен~в {\tt ev-application}.

Метки {\tt ev-sequence} и
{\tt ev-sequence-continue} образуют цикл, который по очереди
вычисляет все выражения~в последовательности.  Список невычисленных
пока выражений хранится~в {\tt unev}.  Прежде, чем вычислять
каждое выражение, мы смотрим, есть ли~в последовательности после него еще
выражения, подлежащие вычислению.  Если да, то мы сохраняем список
невычисленных выражений (из регистра {\tt unev}) и окружение, в
котором их надо вычислить (из {\tt env}),~а затем вызываем
{\tt eval-dispatch}, чтобы вычислить выражение.  После того,
как вычисление закончено, два сохраненных регистра восстанавливаются
на метке {\tt ev-sequence-continue}.

Последнее выражение~в последовательности обрабатывается
особым образом, на метке {\tt ev-sequence-last-exp}.  Поскольку
после этого выражения никаких других вычислять не требуется, не нужно
и сохранять {\tt unev} и {\tt env} перед переходом на
{\tt eval-dispatch}.  Значение всей последовательности равно
значению последнего выражения, так что после вычисления последнего
выражения требуется только продолжить вычисление по адресу, который
хранится на стеке (помещенный туда из {\tt ev-application} или
{\tt ev-begin}).  Мы не устанавливаем
{\tt continue} так, чтобы вернуться~в текущее место,
восстановить {\tt continue} со стека и продолжить с хранящейся в
нем точки входа,~а восстанавливаем {\tt continue} со стека
перед переходом на {\tt eval-dispatch}, так что после
вычисления выражения {\tt eval-dispatch} передаст управление по
этому адресу.

\begin{Verbatim}[fontsize=\small]
ev-sequence\index{ru}{ev-sequence|с хвостовой рекурсией|||pd|}
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
\end{Verbatim}

\paragraph{Хвостовая рекурсия}


\index{ru}{вычислитель с явным управлением для Scheme|хвостовая рекурсия||||}
\index{ru}{хвостовая рекурсия|и вычислитель с явным управлением||||}
В главе~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES} 
мы говорили,
что процесс, который описывается процедурой вроде

\begin{Verbatim}[fontsize=\small]
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
\end{Verbatim}
итеративен.  Несмотря на то, что синтаксически процедура рекурсивна
(определена через саму себя), вычислителю нет логической
необходимости сохранять информацию при переходе от одного вызова
{\tt sqrt-iter} к другому\footnote{В 
разделе~\ref{DESIGNING-REGISTER-MACHINES} мы видели, как такие
процессы можно реализовывать с помощью регистровой машины, не имеющей стека; 
состояние машины хранилось в ограниченном количестве регистров.
}. %%HERE! Разобраться со сносками! Подредактировать текст, убрать одну строчку
\index{ru}{хвостовая рекурсия|и метациклический интерпретатор||||}Про вычислитель, который способен вычислить процедуру типа 
{\tt sqrt-iter}, не требуя дополнительной памяти по мере ее
рекурсивных вызовов, говорят, что он обладает свойством 
\index{ru}{вычислитель c хвостовой рекурсией||tail-recursive evaluator|||}\index{en}{tail-recursive evaluator||вычислитель c хвостовой рекурсией|||}% 
\index{ru}{хвостовая рекурсия||tail recursion|||}\index{en}{tail recursion||хвостовая рекурсия|||}{\em хвостовой рекурсии} (tail recursion).
\index{ru}{метациклический интерпретатор для Scheme|наличие хвостовой рекурсии (неизвестно)||||}Метациклическая
реализация вычислителя из 
главы~\ref{METALINGUISTIC-ABSTRACTION} не указывает, обладает ли
вычислитель хвостовой рекурсией, поскольку он наследует механизм
сохранения состояния из нижележащей Scheme.  Однако~в случае
вычислителя с явным управлением мы можем проследить процесс вычисления
и увидеть, когда вызовы процедур приводят к росту информации на
стеке.

Наш вычислитель обладает хвостовой рекурсией, поскольку
при вычислении последнего выражения последовательности мы напрямую
переходим к {\tt eval-dispatch}, никакую информацию не сохраняя
на стеке.  Следовательно, при вычислении последнего выражения
последовательности~--- даже если это рекурсивный вызов (как в
{\tt sqrt-iter}, где выражение {\tt if}, последнего
выражения~в теле процедуры, сводится к вызову {\tt sqrt-iter})
--- не происходит никакого роста глубины стека\footnote{Наша реализация хвостовой рекурсии в
{\tt ev-sequence}~--- вариант хорошо известного метода
оптимизации, используемого во многих компиляторах.  При компиляции
процедуры, которая заканчивается вызовом процедуры, можно заменить
вызов переходом на начало вызываемой процедуры.  Встраивание такой
стратегии~в интерпретатор (как сделано~в этом разделе) единым
образом распространяет эту оптимизацию на весь язык.
}.

Мы использовали тот факт, что сохранять информацию
необязательно.  Если бы мы до этого не додумались, можно было бы реализовать
{\tt eval-sequence} так, что все выражения~в последовательности
обрабатываются одинаково~--- сохранение регистров, вычисление
выражения, возврат с сохранением регистров, и повторение до тех пор,
пока не вычислятся все выражения\footnote{Можно определить {\tt no-more-exps?} как
\begin{Verbatim}
(define (no-more-exps? seq) (null? seq))\index{ru}{no-more-exps?||||pd|п}
\end{Verbatim}
}. %%FOOTNOTE

\begin{Verbatim}[fontsize=\small]
ev-sequence\index{ru}{ev-sequence|без хвостовой рекурсии|||pd|}
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
\end{Verbatim}

Может показаться, что это мелкое изменение в
предыдущем коде для выполнения последовательности: единственная
разница состоит~в том, что мы проходим через цикл
сохранения-восстановления для последнего выражения последовательности
так же, как и для остальных.  Интерпретатор по-прежнему будет
возвращать для всех выражений то же самое значение.  Однако такое
изменение теряет свойство хвостовой рекурсии, поскольку теперь после
вычисления последнего выражения~в последовательности нам придется
возвращаться и отменять (бесполезные) сохранения регистров.  Эти
дополнительные сохранения будут накапливаться~в гнезде рекурсивных
вызовов.  Следовательно, процессы вроде {\tt sqrt-iter}
потребуют памяти пропорционально количеству итераций,~а не
фиксированного объема.  \index{ru}{итеративный процесс|реализованный с помощью вызова процедуры||||}
Такая разница может быть существенна.
Например, при наличии хвостовой рекурсии можно выразить бесконечный
цикл с помощью одного только механизма вызова процедур:

\begin{Verbatim}[fontsize=\small]
(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
\end{Verbatim}
Без хвостовой рекурсии такая процедура рано или поздно исчерпает место
в стеке,~а итерацию придется выражать с помощью какого-то другого механизма
помимо вызовов процедур.

\subsection{Условные выражения, присваивания и определения}
\label{CONDITIONALS-ASSIGNMENTS-AND-DEFINITIONS}


\index{ru}{вычислитель с явным управлением для Scheme|условные выражения||||}
Как и~в метациклическом интерпретаторе, особые формы
обрабатываются путем частичного выполнения частей выражения.  В
выражении {\tt if} нам нужно вычислить предикат,~а затем на основании
его значения решить, требуется нам выполнять следствие или
альтернативу.

Прежде чем вычислять предикат, мы сохраняем само выражение
{\tt if}, поскольку позже из него потребуется извлекать
следствие либо альтернативу.  Кроме того, мы сохраняем окружение,
которое потребуется при вычислении следствия или альтернативы, и
{\tt continue}, который потребуется нам при возврате значения
выражению, ждущему результата {\tt if}.

\begin{Verbatim}[fontsize=\small]
ev-if\index{ru}{ev-if||||pd|}
  (save exp)                    {\em ; сохраняем выражение}
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  {\em ; вычисляем предикат}
\end{Verbatim}

Вернувшись после вычисления предиката, мы смотрим, является
ли его значение истиной или ложью,~в зависимости от этого переносим в
регистр {\tt exp} следствие либо альтернативу, и идем на
{\tt eval-dispatch}.  Заметим, что после восстановления
{\tt env} и {\tt continue} {\tt eval-dispatch}
будет выполняться~в правильном окружении и вернется после вычисления
выражения~в правильное место.

\begin{Verbatim}[fontsize=\small]
ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
\end{Verbatim}

\paragraph{Присваивания и определения}


\index{ru}{вычислитель с явным управлением для Scheme|присваивания||||}
Присваивания обрабатываются по метке
{\tt ev-assignment}, на которую переход происходит из
{\tt eval-dispatch} с выражением-присваиванием~в регистре
{\tt exp}.  Код {\tt ev-assignment} сначала вычисляет
значение присваиваемого выражения,~а затем заносит это значение в
окружение.  Предполагается, что {\tt set-variable-value!}
дана как машинная операция.

\begin{Verbatim}[fontsize=\small]
ev-assignment\index{ru}{ev-assignment||||pd|}
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                  {\em ; сохранить переменную}
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch)) {\em ; вычислить присваиваемое значение}
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{Verbatim}

Подобным образом обрабатываются и \index{ru}{вычислитель с явным управлением для Scheme|определения||||}определения: 

\begin{Verbatim}[fontsize=\small]
ev-definition\index{ru}{ev-definition||||pd|}
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   {\em ; сохранить переменную}
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  {\em ; вычислить значение переменной}
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{Verbatim}
\begin{exercise}{5.23}%%
\label{EX5.23}%
Расширьте вычислитель так, чтобы обрабатывались
\index{ru}{производные выражения~в интерпретаторе|в вычислителе с явным управлением||||(упр.~5.23)}
\index{ru}{вычислитель с явным управлением для Scheme|производные выражения||||(упр.~5.23)}
производные выражения {\tt cond}, {\tt let} и тому
подобные (раздел~\ref{REPRESENTING-EXPRESSIONS}).  Можно
<<сжульничать>> и считать, что синтаксические трансформации вроде
{\tt cond->if} имеются как машинные операции\footnote{На самом деле это не жульничество.  В настоящей
реализации, построенной с нуля, мы бы на
синтаксическом этапе, происходящем раньше собственно выполнения,
интерпретировали при помощи
вычислителя с явным управлением Scheme-программу, которая производит
трансформации исходного кода вроде {\tt cond->if}.
}.
\end{exercise}
\begin{exercise}{5.24}%%
\label{EX5.24}%
Реализуйте {\tt cond} как новую \index{ru}{вычислитель с явным управлением для Scheme|производные выражения||||(упр.~5.24)} особую форму, не сводя его к 
{\tt if}.  Придется организовать цикл, проверяющий
предикаты последовательных ветвей {\tt cond}, пока один не
окажется истинным,~а затем с помощью {\tt ev-sequence}
выполнять действия этой ветви.
\end{exercise}
\begin{exercise}{5.25}%%
\label{EX5.25}%
Измените вычислитель так, чтобы он использовал\index{ru}{вычислитель с явным управлением для Scheme|нормальный порядок вычислений||||(упр.~5.25)}\index{ru}{нормальный порядок вычислений|в вычислителе с явным управлением||||(упр.~5.25)}
нормальный порядок вычислений, на основе ленивого интерпретатора из
раздела~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION}.
\end{exercise}

\subsection{Запуск вычислителя}
\label{RUNNING-THE-EVALUATOR}


\index{ru}{вычислитель с явным управлением для Scheme|запуск||||}
Реализовав вычислитель с явным управлением, мы подходим к
концу сюжета, начатого~в 
главе~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES}~--- построения
все более точных 
\index{ru}{модели вычисления||models of evaluation|||}\index{en}{models of evaluation||модели вычисления|||}
моделей для процесса вычисления.  Мы начали с
относительно неформальной подстановочной модели, затем~в 
главе~\ref{MODULARITY-OBJECTS-AND-STATE} 
расширили ее до модели с
окружениями, позволившей работать с состоянием и его
изменением.  В метациклическом интерпретаторе из
главы~\ref{METALINGUISTIC-ABSTRACTION} мы, используя как язык
саму Scheme, 
сделали  более явной структуру окружений, которые строятся при
вычислении выражения.  Теперь, рассмотрев регистровые машины, мы
внимательнее исследовали механизмы вычислителя для работы с памятью,
передачи аргументов и управления.  На каждом новом уровне нам
приходилось сталкиваться с вопросами и разрешать неясности, которые не
были заметны при предыдущем, менее строгом описании вычислений.  Для
того, чтобы понять поведение вычислителя с явным управлением, мы можем
построить его имитационную модель и рассмотреть ее работу.

\index{ru}{управляющий цикл|в вычислителе с явным управлением||||} 
\index{ru}{вычислитель с явным управлением для Scheme|управляющий цикл||||}
 Введем~в нашу машину-вычислитель управляющий цикл.  Он
играет роль процедуры {\tt driver-loop} из 
раздела~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.  Вычислитель
будет~в цикле печатать подсказку, считывать выражение, выполнять его с
помощью перехода на {\tt eval-dispatch}, и печатать результат.
Следующая группа команд стоит~в начале последовательности команд
контроллера~в вычислителе с явным управлением\footnote{Мы предполагаем, что {\tt read} и различные
операции печати имеются как элементарные машинные операции.  Такое
предположение разумно в целях имитации, но на практике совершенно
нереалистично.  Эти операции чрезвычайно сложны.  На практике они
реализовывались бы с помощью низкоуровневых операций ввода-вывода,
например, посимвольного ввода и вывода печатных знаков на устройство.

Для поддержки операции
{\tt get-global-environment} мы определяем

\begin{Verbatim}
(define the-global-environment (setup-environment))\index{ru}{the-global-environment||||pd|п}

(define (get-global-environment)\index{ru}{get-global-environment||||pd|п}
  the-global-environment)
\end{Verbatim} 
}. %FOOTNOTE!

\begin{Verbatim}[fontsize=\small]
read-eval-print-loop \index{ru}{подсказка|вычислитель  с явным управлением||||} \index{ru}{read-eval-print loop||||pd|}
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
print-result  \index{ru}{print-result||||pd|}
  (perform
   (op announce-output) (const ";;; Значение EC-Eval:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{Verbatim}

\index{ru}{обработка ошибок|в         вычислителе с явным управлением|error         handling|||}\index{en}{error         handling||обработка ошибок|в         вычислителе с явным управлением||}
\index{ru}{вычислитель с явным управлением для Scheme|обработка ошибок||||}
Когда мы сталкиваемся с ошибкой (например, с ошибкой
<<неизвестный тип процедуры>> из {\tt apply-dispatch}), мы
печатаем сообщение об ошибке и возвращаемся~в управляющий
цикл\footnote{Хотелось бы обрабатывать и другие типы ошибок, но
этого не так легко добиться. См.~упражнение~\ref{EX5.30}.
}.

\begin{Verbatim}[fontsize=\small]
unknown-expression-type \index{ru}{unknown-expression-type||||pd|}
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
unknown-procedure-type \index{ru}{unknown-procedure-type||||pd|}
  (restore continue)    {\em ; очистить стек (после {\tt apply-dispatch})}
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))

signal-error \index{ru}{signal-error||||pd|}
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{Verbatim}

Для целей имитации мы каждый раз~в начале прохождения
управляющего цикла инициализируем стек, поскольку после того, как
ошибка (например, неопределенная переменная) прерывает вычисление, он
может не быть пуст\footnote{Можно было бы инициализировать стек только после
ошибок, однако если мы это делаем~в управляющем цикле, оказывается
удобнее следить за производительностью вычислителя, как это описано
ниже.
}.

Если мы соберем все фрагменты кода, представленные в
разделах~\ref{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}--\ref{RUNNING-THE-EVALUATOR},
то можно создать \index{ru}{вычислитель с явным управлением для Scheme|модель машины||||}модель машины-вычислителя, которая запускается
имитатором регистровых машин из раздела~\ref{A-REGISTER-MACHINE-SIMULATOR}.

\begin{Verbatim}[fontsize=\small]
(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
  '(
    read-eval-print-loop
      \textit{$\langle$контроллер машины, как описано выше$\rangle$}
   )))
\end{Verbatim}
Требуется определить процедуры Scheme, имитирующие
операции, которые считаются элементарными~в вычислителе.  Это
те же операции, которые использовались~в метациклическом
интерпретаторе из раздела~\ref{THE-METACIRCULAR-EVALUATOR},
а также несколько дополнительных, определенных~в примечаниях к 
разделу~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}.

\begin{Verbatim}[fontsize=\small]
(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        \textit{$\langle$полный список операций машины-вычислителя$\rangle$}))
\end{Verbatim}

Наконец, мы можем проинициализировать глобальное окружение
и запустить вычислитель:

\begin{Verbatim}[fontsize=\small]
(define the-global-environment (setup-environment))

(start eceval)

\textit{;;; Ввод EC-Eval:}
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
\textit{;;; Значение EC-Eval:}
\textit{ok}

\textit{;;; Ввод EC-Eval:}
(append '(a b c) '(d e f))
\textit{;;; Значение EC-Eval:}
\textit{(a b c d e f)}
\end{Verbatim}

Разумеется, вычисление выражений таким образом занимает
намного больше времени, чем если их вводить напрямую~в Scheme, по
причине многослойной имитации.  Наши выражения выполняются
регистровой машиной-вычислителем с явным управлением, которая
имитируется программой на Scheme, которая,~в свою очередь, выполняется
интерпретатором Scheme.
{\sloppy

}

\paragraph{Отслеживание производительности вычислителя}


\index{ru}{вычислитель с явным управлением для Scheme|отслеживание производительности (использование стека)||||}
\index{ru}{имитация|как инструмент для проектирования машин||||}
Имитационное моделирование может служить мощным
инструментом, помогающим~в реализации вычислителей.  С помощью
имитации легко можно не только исследовать варианты построения
регистровых машин, но и отслеживать производительность имитируемого
вычислителя.  Например, один из важных параметров производительности
состоит~в том, насколько эффективно вычислитель использует стек.
Можно отследить количество стековых операций, которые требуются для
вычисления различных выражений, если взять версию имитатора, которая
собирает статистику по использованию стека 
(раздел~\ref{MONITORING-MACHINE-PERFORMANCE}) и добавить
на точку входа {\tt print-result} дополнительную команду,
распечатывающую эту статистику:

\begin{Verbatim}[fontsize=\small]
print-result  \index{ru}{print-result|с отслеживаемым количеством стековых операций|||p|}
  (perform (op print-stack-statistics)) {\em ; добавленная команда}
  (perform
   (op announce-output) (const ";;; Значение EC-Eval:"))
... {\em ; как и раньше}
\end{Verbatim}
Теперь работа с вычислителем выглядит так:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод EC-Eval:}
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\textit{(total-pushes = 3 maximum-depth = 3)}
\textit{;;; Значение EC-Eval:}
\textit{ok}

\textit{;;; Ввод EC-Eval:}
(factorial 5)
\textit{(total-pushes = 144 maximum-depth = 28)}
\textit{;;; Значение EC-Eval:}
\textit{120}
\end{Verbatim}
Заметим, что управляющий цикл вычислителя на каждом проходе заново
инициализирует стек, так что печатаемая статистика будет относиться
только к стековым операциям, произведенным при выполнении последнего
выражения.
\begin{exercise}{5.26}%%
\label{EX5.26}%
С помощью отслеживания стека исследуйте \index{ru}{вычислитель с явным управлением для Scheme|хвостовая рекурсия||||(упр.~5.26)} \index{ru}{хвостовая рекурсия|и вычислитель с явным управлением||||(упр.~5.26)}хвостовую рекурсию~в нашем вычислителе 
(раздел~\ref{SEQUENCE-EVALUATION-AND-TAIL-RECURSION}).
Запустите вычислитель и определите итеративную процедуру
{\tt factorial} из раздела~\ref{LINEAR-RECURSION-AND-ITERATION}:
\index{ru}{factorial|использование стека, интерпретируемый вариант|||p|(упр.~5.26)}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{Verbatim}
Запустите эту процедуру с несколькими небольшими значениями
$n$.  Для каждого из этих значений запишите максимальную
глубину стека и количество операций сохранения, потребных для
вычисления $n!$.

\begin{plainenum}


\item
Вы увидите, что максимальная глубина стека,
нужная для вычисления $n!$, от $n$ не зависит.
Какова эта глубина?

\item
Составьте на основе своих данных формулу в
зависимости от $n$ числа операций сохранения, необходимых
для вычисления $n!$ для любого $n \ge 1$.
Обратите внимание, что число операций~--- линейная функция от
$n$ и, следовательно, определяется двумя константами.
\end{plainenum}
\end{exercise}
\begin{exercise}{5.27}%%
\label{EX5.27}%
Для сравнения с упражнением~\ref{EX5.26},
изучите поведение следующей процедуры для рекурсивного вычисления
факториала:
\index{ru}{factorial|использование стека, интерпретируемый вариант|||p|(упр.~5.27)}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{Verbatim}
Запуская эту процедуру и отслеживая поведение стека, определите как
функции от $n$ максимальную глубину стека и общее число
сохранений, требуемых для вычисления $n!$, при $n \ge
1$.  (Эти функции также будут линейны.)  Опишите общие
результаты экспериментов, записав~в следующую таблицу соответствующие
выражения как формулы, зависящие от $n$:

\medskip
\begin{tabular}{|l|l|l|}
\hline
                 & Максимальная глубина & Количество сохранений \\
\hline
\parbox{3cm}{Рекурсивный\\ факториал} & &\\
\hline
\parbox{3cm}{Итеративный\\ факториал} & &\\
\hline
\end{tabular}
\medskip
\par\noindent
Максимальная глубина служит мерой объема памяти, используемой
вычислителем при обработке выражения,~а количество сохранений хорошо
коррелирует со временем вычисления. 
\end{exercise}
\begin{exercise}{5.28}%%
\label{EX5.28}%
Измените~в определении  вычислителя
{\tt eval-sequence} так, как описано~в 
разделе~\ref{SEQUENCE-EVALUATION-AND-TAIL-RECURSION}, чтобы
вычислитель перестал обладать \index{ru}{вычислитель с явным управлением для Scheme|хвостовая рекурсия||||(упр.~5.28)}% 
\index{ru}{хвостовая рекурсия|и вычислитель с явным управлением||||(упр.~5.28)}%
хвостовой рекурсией.  Заново проведите
эксперименты из упражнений~\ref{EX5.26} и \ref{EX5.27}
 и покажите, что теперь обе версии процедуры {\tt factorial}
требуют количества памяти, которое линейно зависит от значения аргумента.
\end{exercise}
\begin{exercise}{5.29}%%
\label{EX5.29}%
Проследите за использованием стека~в вычислении чисел
Фибоначчи с помощью древовидной рекурсии:
\index{ru}{fib|древовидно-рекурсивный вариант|||pd|(упр.~5.29)}

\begin{Verbatim}[fontsize=\small]
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{Verbatim}

\begin{plainenum}


\item
Дайте формулу, зависящую от $n$, для
максимальной глубины стека,
\index{ru}{fib|использование стека, интерпретируемый вариант|||p|(упр.~5.29)}
требуемой при вычислении
$\mathop{\rm Fib}(n)$ при $n \ge 2$.  Подсказка: в
разделе~\ref{TREE-RECURSION} мы утверждали, что требуемый
объем памяти линейно зависит от $n$.

\item
Постройте формулу для количества сохранений,
требуемых при вычислении $\mathop{\rm Fib}(n)$, если $n \ge
2$.  Вы увидите, что количество сохранений (которое хорошо
коррелирует со временем исполнения) экспоненциально растет с ростом
$n$.  Подсказка: пусть при вычислении
$\mathop{\rm Fib}(n)$ требуется $S(n)$
сохранений.  Нужно показать, что имеется формула, которая выражает
$S(n)$~в зависимости от $S(n-1)$,
$S(n-2)$ и некоторой фиксированной <<дополнительной>>
константы $k$, независимой от $n$.  Приведите
эту формулу и найдите, чему равно {\tt k}.  Покажите теперь,
что $S(n)$ выражается как $a\mathop{\rm Fib}(n+1) + b$
и укажите значения $a$ и $b$.
{\sloppy

}
\end{plainenum}
\end{exercise}
\begin{exercise}{5.30}%%
\label{EX5.30}%
\index{ru}{обработка ошибок|в вычислителе с явным управлением||||(упр.~5.30)}%
\index{ru}{вычислитель с явным управлением для Scheme|обработка ошибок||||(упр.~5.30)}%
Наш вычислитель отлавливает только два
вида ошибок (и сообщает о них)~--- неизвестные типы выражений и неизвестные типы
процедур.  При других ошибках он будет выпадать из управляющего
цикла.  Когда мы запускаем вычислитель с помощью имитатора
регистровых машин, эти ошибки будут пойманы нижележащей
Scheme-системой.  Это похоже на <<падение>> компьютера  в
случае ошибки пользовательской программы\footnote{К сожалению,~в обычных компиляторных языковых системах, например,
\index{ru}{C (Си)|обработка ошибок||||п} C, это обычное
дело. В  \index{ru}{UNIX (Юникс)|||||п}UNIX${}^{\mbox{\tiny TM}}$ система 
<<кидает дамп>>,~в \index{ru}{DOS/Windows|||||п}
DOS/Windows${}^{\mbox{\tiny TM}}$ впадает в
кататонию.   \index{ru}{Macintosh|||||п} Macintosh${}^{\mbox{\tiny TM}}$, если повезет,
рисует на экране взрывающуюся бомбу и предлагает перегрузиться.
}.
Построить настоящую систему обработки ошибок~--- большой проект, но понимание,
что за вопросы здесь возникают, стоит затраченных усилий.


\begin{plainenum}


\item
При ошибках, возникающих~в процессе вычисления,
например, при попытке получить значение неопределенной переменной,
можно заставить операцию просмотра окружения возвращать особый код
ошибки, который не может служить значением пользовательской
переменной. Тогда вычислитель может проверять этот код и
организовывать переход на {\tt signal-error}.  Найдите в
вычислителе все места, где нужно провести подобные изменения, и
исправьте их.   (Потребуется много работы.)

\item
Значительно тяжелее проблема, которую
представляют ошибки, возникающие~в элементарных процедурах, например,
попытки поделить на ноль или взять {\tt car} символа.  В
профессионально написанной системе высокого качества всякий вызов
примитива проверяется на безопасность внутри процедуры-примитива.
Например, при всяком вызове {\tt car} требуется проверить, что
аргумент~--- пара.  Если аргумент не является парой, вызов вернет
особый код ошибки, который вычислитель может проверить и сообщить об
ошибке.  В нашем имитаторе регистровых машин этого можно было бы
добиться, если бы мы проверяли~в каждой элементарной процедуре
правильность аргументов и при необходимости возвращали
соответствующий код.  В таком случае код {\tt primitive-apply}
мог бы проверять этот код и, если надо, переходить на
{\tt signal-error}.   Постройте такую структуру и заставьте ее
работать.  (Это большой проект.)
\end{plainenum}
\end{exercise}

\section{Компиляция}
\label{COMPILATION}


\index{ru}{компилятор ||compiler|||}\index{en}{compiler||компилятор |||}%
Вычислитель с явным управлением из 
раздела~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}~---  регистровая
машина, контроллер которой исполняет Scheme-программы.  В этом
разделе мы увидим, как выполнять программы на Scheme с помощью
регистровой машины, контроллер которой не является интерпретатором
Scheme.

\index{ru}{вычислитель с явным управлением для Scheme|как универсальная машина||||} \index{ru}{универсальная машина|вычислитель с явным управлением||||} Машина-вычислитель с явным управлением универсальна~--- она
способна выполнить любой вычислительный процесс, который можно описать на
Scheme.  Контроллер вычислителя выстраивает использование своих путей
данных так, чтобы исполнялось нужное вычисление.  Таким образом, пути
данных вычислителя универсальны: они достаточны для того, чтобы
выполнить любое необходимое нам вычисление, если снабдить их
подходящим контроллером\footnote{Это теоретическое утверждение.  Мы не говорим, что пути
данных вычислителя как-то особенно удобны или эффективны для
компьютера общего назначения.  Например, они не слишком хороши для
реализации высокоскоростных вычислений с плавающей точкой или для
вычислений, интенсивно работающих с битовыми векторами.
}.

Коммерческие 
\index{ru}{компьютер общего назначения, как универсальная     машина||general-purpose computer as universal     machine|||}\index{en}{general-purpose computer as universal     machine||компьютер общего назначения, как универсальная     машина|||} 
\index{ru}{универсальная машина|компьютер общего     назначения||||} 
компьютеры общего назначения
представляют собой регистровые машины, построенные на множестве
регистров и операций, составляющем эффективный и удобный набор путей
данных.  Контроллер машины общего назначения~--- это интерпретатор
языка регистровых машин, подобный нашему.  Язык называется  
\index{ru}{внутренний язык машины||native language of machine|||}\index{en}{native language of machine||внутренний язык машины|||}{\em внутренним
языком} (native language) машины, или попросту 
\index{ru}{машинный язык||machine language|||}\index{en}{machine language||машинный язык|||}{\em машинным языком} (machine language).
Программы, написанные на машинном языке~--- это последовательности
команд, использующих пути данных машины.  Например, последовательность
команд вычислителя с явным управлением можно рассматривать как
\index{ru}{вычислитель с явным управлением для Scheme|как программа на машинном языке||||}
программу на машинном языке компьютера общего назначения,~а не как
контроллер специализированной машины-интерпретатора.

\index{ru}{интерпретатор|vs. компилятор||||}
\index{ru}{компилятор|vs. интерпретатор||||}
Есть две стратегии борьбы с разрывом между языками высокого
и низкого уровня.  Вычислитель с явным управлением иллюстрирует
стратегию интерпретации.  Интерпретатор, написанный на внутреннем
языке машины, конфигурирует машину так, что она начинает исполнять
программы на языке (называемом \index{ru}{исходный язык||source language|||}\index{en}{source language||исходный язык|||}{\em исходный
язык} (source language)), который может отличаться от внутреннего языка машины,
производящей вычисление.  Элементарные процедуры исходного языка
реализуются~в виде библиотеки подпрограмм, написанных на внутреннем
языке данной машины.  Интерпретируемая программа (называемая 
\index{ru}{исходная программа||source program|||}\index{en}{source program||исходная программа|||}{\em исходная программа} (source program))
представляется как структура данных.  Интерпретатор просматривает эту
структуру и анализирует исходную программу.  В процессе анализа он
имитирует требуемое поведение исходной программы, вызывая
соответствующие элементарные подпрограммы из библиотеки.

В этом разделе мы исследуем альтернативную стратегию~---
\index{ru}{компиляция||compilation|||}\index{en}{compilation||компиляция|||}{\em компиляцию} (compilation).  Компилятор для данного
исходного языка и данной машины переводит исходную программу в
эквивалентную ей программу (называемую 
\index{ru}{объектная программа||object program|||}\index{en}{object program||объектная программа|||}{\em объектной} (object program)), написанную на
внутреннем языке машины.  Компилятор, который мы реализуем~в этом
разделе, переводит программы, написанные на Scheme, в
последовательности команд, которые подлежат исполнению с помощью путей
данных машины-вычислителя с явным управлением\footnote{\index{ru}{компилятор для Scheme|использование регистров||||п}На самом деле, машина, исполняющая скомпилированный
код, может быть проще, чем машина-интерпретатор, поскольку регистры
{\tt exp} и {\tt unev} мы использовать не будем.  В
интерпретаторе они использовались для хранения невычисленных
выражений.  Однако при использовании компилятора эти выражения
встраиваются~в компилируемый код, который будет выполняться на
регистровой машине.  По той же причине нам не нужны 
\index{ru}{компилятор для Scheme|использование машинных операций||||п} 
машинные операции, 
работающие с синтаксисом выражений.  Однако скомпилированный код будет
использовать некоторые дополнительные машинные операции
(представляющие скомпилированные объекты-процедуры), которых не
было~в машине-вычислителе с явным управлением.
}.

По сравнению с интерпретацией, компиляция может дать
большой выигрыш~в эффективности исполнения программы. Это будет
объяснено ниже, при обзоре компилятора.  С другой стороны,
интерпретатор предоставляет более мощную среду для интерактивной
разработки программы и отладки, поскольку исполняемая исходная
программа присутствует во время выполнения, и ее можно исследовать и
изменять.  В дополнение к этому, поскольку библиотека примитивов
присутствует целиком, во время отладки можно конструировать и
добавлять~в систему новые программы.

Исходя из взаимно дополнительных преимуществ компиляции и
интерпретации, современные среды разработки программ следуют смешанной
стратегии.  Как правило, интерпретаторы Лиспа устроены таким образом,
что интерпретируемые и скомпилированные процедуры могут вызывать друг
друга.  Это позволяет программисту компилировать те части программы,
которые он считает отлаженными, пользуясь при этом преимуществом в
эффективности, предоставляемом компиляцией, но при этом сохранять
интерпретационный режим выполнения для тех частей программы, которые
находятся~в гуще интерактивной разработки и отладки.  В 
разделе~\ref{INTERFACING-COMPILED-CODE-TO-THE-EVALUATOR}, после
того, как компилятор будет разработан, мы покажем, как построить его
взаимодействие с нашим интерпретатором и получить интегрированную
систему разработки, состоящую из компилятора и интерпретатора.

\paragraph{Обзор компилятора}

\index{ru}{компилятор для Scheme|||||}
\index{ru}{компилятор для Scheme|vs. вычислитель с явным управлением||||}
Наш компилятор во многом похож на наш интерпретатор, как
по структуре, так и по функции, которую он осуществляет.
Соответственно, механизмы анализа выражений, используемые
компилятором, будут подобны тем же механизмам для
интерпретатора.  Более того, чтобы упростить взаимодействие
компилируемого и интерпретируемого кода, мы построим компилятор так,
чтобы порождаемый им код следовал тем же соглашениям, что и
интерпретатор:  \index{ru}{компилятор для Scheme|использование регистров||||}окружение будет храниться~в регистре {\tt env},
списки аргументов будут собираться~в {\tt argl}, применяемая
процедура~---~в {\tt proc}, процедуры будут возвращать свое
значение~в {\tt val},~а место, куда им следует вернуться, будет
храниться~в регистре {\tt continue}.  В общем, компилятор
переводит исходную программу~в объектную программу, которая
проделывает,~в сущности, те же самые операции с регистрами, которые
провел бы интерпретатор при выполнении той же самой исходной
программы.

Это описание подсказывает стратегию для реализации
примитивного компилятора: разбирать выражение таким же образом,
как это делает интерпретатор.  Когда мы встречаем команду работы с
регистром, которую интерпретатор выполнил бы при работе с выражением,
мы эту команду не выполняем,~а добавляем к порождаемой нами
последовательности.  Полученная последовательность команд и будет
объектным кодом.  Отсюда видно \index{ru}{эффективность|компиляции||||}\index{ru}{компилятор для Scheme|эффективность||||}
преимущество~в эффективности, которое
компиляция имеет перед интерпретацией.  Каждый раз, когда
интерпретатор выполняет выражение~--- например, {\tt (f 48
96)},~--- он проделывает работу по распознаванию выражения
(определение того, что это вызов процедуры) и проверке, не кончился
ли список операндов (определение того, что операндов два).  В случае с
компилятором выражение анализируется только один раз, когда во время
компиляции порождается последовательность команд.  Объектный код,
порожденный компилятором, содержит только команды, которые вычисляют
оператор и два операнда, собирают список аргументов и применяют
процедуру (из {\tt proc}) к аргументам (из
{\tt argl}).

Это тот же самый вид оптимизации, который мы применяли в
анализирующем интерпретаторе из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}.
\index{ru}{компилятор для Scheme|vs. анализирующий интерпретатор||||}Однако~в случае компиляции имеются дополнительные возможности повысить
эффективность.  Интерпретатор при работе следует процессу,
который обязан быть приложимым к любому выражению языка.  В
противоположность этому, всякий данный сегмент скомпилированного кода
должен вычислять только одно выражение.  Это может приводить к большой
разнице, например, при использовании стека для сохранения регистров.
Интерпретатор, выполняя выражение, должен быть готов к любым
неожиданностям.  При вычислении подвыражения он сохраняет все
регистры, которые понадобятся~в дальнейшем, поскольку~в подвыражении
могут содержаться произвольные действия.  Напротив, компилятор
может пользоваться структурой конкретного выражения и порождать код,
который избегает лишних операций со стеком.
\looseness=1

Рассмотрим~в качестве примера выражение {\tt (f 84
96)}.  Интерпретатор, прежде чем вычислять оператор комбинации,
подготавливается к этому вычислению и сохраняет регистры с
операндами и окружением, чьи значения ему потребуются позже.
Затем интерпретатор вычисляет оператор, получая значение в
{\tt val}, восстанавливает сохраненные регистры, и, наконец,
переносит {\tt val}~в {\tt proc}.  Однако~в данном
конкретном вычислении оператором служит символ
{\tt f}, и его вычисление осуществляется командой
{\tt lookup-variable-value}, которая никаких регистров не
изменяет.  Компилятор, который мы разработаем~в этом разделе,
пользуется этим фактом и порождает код для вычисления оператора
командой

\begin{Verbatim}[fontsize=\small]
(assign proc (op lookup-variable-value) (const f) (reg env))
\end{Verbatim}
Этот код не только избегает ненужных сохранений и восстановлений, но и
записывает значение переменной напрямую~в регистр {\tt proc}, в
то время как интерпретатор сначала получает его~в {\tt val}, а
уж затем переносит~в {\tt proc}.

Кроме того, компилятор может оптимизировать доступ к
среде.  Во многих случаях при анализе кода компилятор может определять, в
каком кадре будет находиться конкретная переменная, и обращаться к
этому кадру напрямую,~а не через поиск
{\tt lookup-variable-value}.  Мы рассмотрим, как реализуется такой
доступ к переменным,~в разделе~\ref{LEXICAL-ADDRESSING}.
До тех пор, впрочем, мы сосредоточим внимание на оптимизациях доступа
к регистрам и стеку, описанным выше.  Имеются и другие виды
оптимизаций, которые может производить компилятор: например,
<<вставка>> кода элементарных операций вместо общего механизма
{\tt apply} (см.~упражнение~\ref{EX5.38}); однако
эти оптимизации мы здесь рассматривать не будем.  В этом разделе наша цель
--- проиллюстрировать процесс компиляции в
упрощенном (но все же интересном) контексте.
\looseness=1

\subsection{Структура компилятора}
\label{STRUCTURE-OF-THE-COMPILER}


\index{ru}{компилятор для Scheme|vs. анализирующий интерпретатор||||}   
\index{ru}{компилятор для Scheme|структура||||} 
В разделе~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION} мы
модифицировали исходный метациклический интерпретатор и отделили
анализ от выполнения.  При анализе каждого выражения порождалась
исполнительная процедура, которая~в качестве аргумента принимала
окружение и проделывала требуемые операции.  В компиляторе мы будем
проводить,~в сущности, такой же анализ.  Однако вместо
исполнительных процедур мы будем порождать последовательности команд,
предназначенных для исполнения на нашей регистровой машине.

Процедура {\tt compile} проводит~в компиляторе
анализ верхнего уровня.  Она соответствует процедуре {\tt eval}
из раздела~\ref{THE-CORE-OF-THE-EVALUATOR}, процедуре
{\tt analyze} из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION} и точке
входа {\tt eval-dis\-patch} вычислителя с явным управлением из
раздела~\ref{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}.
\index{ru}{компилятор для Scheme|процедуры разбора синтаксиса||||}Подобно интерпретаторам, компилятор использует процедуры разбора
синтаксиса выражений из 
раздела~\ref{REPRESENTING-EXPRESSIONS}\footnote{Заметим, однако, что наш компилятор является программой
на Scheme, и для анализа синтаксиса он использует те же процедуры на
Scheme, которые использовал метациклический интерпретатор.  Для
вычислителя с явным управлением мы, наоборот,
предполагали, что эквивалентные синтаксические операции присутствуют
как примитивы~в регистровой машине.  (Разумеется, когда мы имитировали
эту машину на Scheme,~в модели регистровой машины мы
использовали эти же процедуры Scheme.)
}.
Процедура {\tt compile} проводит разбор по случаям на основе
синтаксического типа выражения, подлежащего компиляции.  Для каждого
типа выражения она вызывает специальный \index{ru}{генератор кода||code generator|||}\index{en}{code generator||генератор кода|||}{\em генератор
кода} (code generator).

\begin{Verbatim}[fontsize=\small]
(define (compile exp target linkage)\index{ru}{compile||||pd|}
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Неизвестный тип выражения -- COMPILE" exp))))
\end{Verbatim}

\paragraph{Целевые регистры и типы связи}


{\tt Compile} и вызываемые оттуда \index{ru}{генератор кода|аргументы||||}генераторы кода
принимают, помимо подлежащего компиляции выражения, еще два
аргумента.  Во-первых, 
\index{ru}{целевой регистр||target|||}\index{en}{target||целевой регистр|||}{\em целевой регистр} (target),~в который
компилируемый код должен поместить значение выражения.  Во-вторых,
\index{ru}{тип связи||linkage descriptor|||}\index{en}{linkage descriptor||тип связи|||}{\em тип связи} (linkage descriptor),
который описывает, что код, который получается при компиляции, должен
делать после того, как он закончит выполняться.  Описатель типа связи
может потребовать одного из трех следующих действий:

\begin{plainlist}


\item
продолжить со следующей команды в
последовательности (на это указывает описатель типа связи
{\tt next}),
\index{ru}{next (описатель связи)||||p|}

\item
вернуться из компилируемой процедуры (на это
указывает описатель типа связи {\tt return}), или
\index{ru}{return (описатель связи)||||p|}

\item
перейти на указанную метку (на это указывает
использование метки~в качестве описателя связи).
\end{plainlist}

Например, компиляция выражения {\tt 5} (значение
которого равно ему самому) с целевым регистром {\tt val} и
типом связи {\tt next} должна породить команду

\begin{Verbatim}[fontsize=\small]
(aasign val (const 5))
\end{Verbatim}
Компиляция того же самого выражения с типом связи {\tt return}
должна породить команды

\begin{Verbatim}[fontsize=\small]
(assign val (const 5))
(goto (reg continue))
\end{Verbatim}
В первом случае выполнение продолжится на следующей команде
последовательности.  Во втором мы вернемся из процедуры.  В обоих
случаях значение выражения будет помещено~в целевой регистр
{\tt val}.

\paragraph{Последовательности команд и использование
стека}


Каждый \index{ru}{генератор кода|возвращаемое значение||||}
генератор кода возвращает 
\index{ru}{последовательность команд||instruction sequence|||}\index{en}{instruction sequence||последовательность команд|||}{\em последовательность
команд} (in\-struc\-tion sequence), содержащую порожденный для выражения объектный код.
Порождение кода для составных выражений достигается путем сочетания
более простых сегментов, порожденных генераторами кода для подвыражений, так же, как
вычисление составного выражения проходит через вычисление
подвыражений.

Простейший способ сочетания последовательностей команд
--- процедура под названием {\tt append-instruction-sequences}.
\index{ru}{append-instruction-sequences||||p|}
Она принимает~в качестве
аргументов произвольное число последовательностей команд, которые надо
выполнить одну за другой.  Процедура склеивает их и возвращает
полученную последовательность. ~а именно, если
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$} и
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}~--- последовательности
команд, то вычисление

\begin{Verbatim}[fontsize=\small]
(append-instruction-sequences \textit{$\langle$посл${}_{\mbox{1}}$$\rangle$} \textit{$\langle$посл${}_{\mbox{2}}$$\rangle$})
\end{Verbatim}
вернет последовательность

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}
\end{Verbatim}

\index{ru}{компилятор для Scheme|использование стека||||}Когда требуется сохранять регистры, генераторы кода
используют {\tt pre\-ser\-ving}, 
\index{ru}{preserving||||p|}
более сложный метод сочетания
последовательностей команд.  {\tt Pre\-ser\-ving} принимает три
аргумента: множество регистров и две последовательности, которые
требуется выполнить одна за другой.  Эта процедура склеивает
последовательности таким образом, что содержимое всех регистров из
множества сохраняется во время выполнения первой последовательности,
если оно нужно при выполнении второй.  Таким образом, если первая
последовательность изменяет регистр,~а второй последовательности нужно его исходное
содержимое, {\tt preserving} оборачивает вокруг первой
последовательности команды {\tt save} и {\tt restore}
для этого регистра, прежде чем склеить последовательности.  В
противном случае она просто возвращает склеенные последовательности
команд.  Так, например,

\begin{Verbatim}[fontsize=\small]
(preserving (list \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}) \textit{$\langle$посл${}_{\mbox{1}}$$\rangle$} \textit{$\langle$посл${}_{\mbox{2}}$$\rangle$})
\end{Verbatim}
порождает одну из следующих четырех последовательностей команд, в
зависимости от того, как \textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
и \textit{$\langle$посл${}_{\mbox{2}}$$\rangle$} используют
\textit{$\langle$рег${}_{\mbox{1}}$$\rangle$} и
\textit{$\langle$рег${}_{\mbox{2}}$$\rangle$}:
%%%%!!!!!! Перестроить~в таблицу !!!!!!

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}
\end{Verbatim}
или

\begin{Verbatim}[fontsize=\small]
(save \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
(restore \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}
\end{Verbatim}
или

\begin{Verbatim}[fontsize=\small]
(save \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
(restore \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}
\end{Verbatim}
или

\begin{Verbatim}[fontsize=\small]
(save \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$})
(save \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{1}}$$\rangle$}
(restore \textit{$\langle$рег${}_{\mbox{1}}$$\rangle$})
(restore \textit{$\langle$рег${}_{\mbox{2}}$$\rangle$})
\textit{$\langle$посл${}_{\mbox{2}}$$\rangle$}
\end{Verbatim}

Сочетая последовательности команд с помощью
{\tt preserving}, компилятор избегает лишних операций со
стеком.  Кроме того, при этом забота о том, стоит ли порождать
{\tt save} и {\tt restore}, целиком оказывается
заключенной~в процедуре {\tt preserving} и отделяется от забот,
которые будут нас волновать при написании отдельных генераторов кода.
В сущности, ни одна команда {\tt save} или
{\tt restore} не порождается генераторами кода явно.

В принципе мы могли бы представлять последовательность
команд просто как список отдельных команд.  В таком случае
{\tt append-instruction-se\-quen\-ces} могла бы склеивать
последовательности с помощью обычного {\tt append} для
списков.  Однако тогда {\tt preserving} оказалась бы более
сложной операцией, поскольку ей пришлось бы исследовать каждую
последовательность команд и выяснять, как там используются регистры.
{\tt Preserving} была бы при этом сложной и неэффективной,
поскольку она анализировала бы каждый из своих
аргументов-последовательностей, при том, что сами эти
последовательности могли быть созданы вызовами
{\tt preserving}, и~в этом случае их части были бы уже
проанализированы.  Чтобы избежать такого многократного анализа, мы с
каждой последовательностью команд будем связывать некоторую информацию
о том, как она использует регистры.  При порождении элементарной
последовательности мы будем указывать эту информацию явно, а
процедуры, сочетающие последовательности, будут выводить информацию об
использовании регистров для составной последовательности из
информации, связанной с ее последовательностями-компонентами.

Последовательность команд будет содержать три вида
информации:

\begin{plainlist}


\item
множество регистров, которые должны быть
инициализированы, прежде чем выполняются команды из последовательности
(говорится, что последовательность 
\index{ru}{нужные регистры||needed registers|||}\index{en}{needed registers||нужные регистры|||}{\em нуж\-дает\-ся} (needs)~в этих регистрах),

\item
множество регистров, значения которых
последовательность изменяет, и

\item
сами команды (называемые также 
\index{ru}{предложения||statements|||}\index{en}{statements||предложения|||}{\em предложениями} (statements))~в последовательности.
\end{plainlist}
Мы будем представлять последовательность команд~в виде списка из трех
частей.  Таким образом, конструктор для последовательностей команд
таков:

\begin{Verbatim}[fontsize=\small]
(define (make-instruction-sequence needs modifies statements)\index{ru}{make-instruction-sequence||||pd|}
  (list needs modifies statements))
\end{Verbatim}

Например, последовательность из двух команд, которая ищет
значение переменной {\tt x}~в текущем окружении, присваивает
его {\tt val},~а затем возвращается, требует, чтобы были
проинициализированы регистры {\tt env} и {\tt continue},
и изменяет регистр {\tt val}.  Следовательно, эту
последовательность можно построить так:

\begin{Verbatim}[fontsize=\small]
(make-instruction-sequence '(env continue) '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
\end{Verbatim}

Иногда нам нужно будет строить последовательность без
команд:

\begin{Verbatim}[fontsize=\small]
(define (empty-instruction-sequence)\index{ru}{empty-instruction-sequence||||pd|}
  (make-instruction-sequence '() '() '()))
\end{Verbatim}

Процедуры для сочетания последовательностей команд
приведены~в 
разделе~\ref{COMBINING-INSTRUCTION-SEQUENCES}.
\begin{exercise}{5.31}%%
\label{EX5.31}%
\index{ru}{компилятор для Scheme|использование стека||||(упр.~5.31)}Во время вычисления вызова процедуры вычислитель с явным
управлением всегда сохраняет и восстанавливает регистр
{\tt env} при вычислении оператора, сохраняет и восстанавливает
{\tt env} при вычислении каждого операнда (кроме последнего),
сохраняет и восстанавливает {\tt argl} при вычислении каждого
операнда,~а также сохраняет и восстанавливает {\tt proc} при
вычислении последовательности операндов.  Для каждой из следующих
комбинаций скажите, какие из этих операций {\tt save} и
{\tt restore} излишни и могут быть исключены с помощью
механизма {\tt preserving}:
\index{ru}{preserving||||p|(упр.~5.31)}

\begin{Verbatim}[fontsize=\small]
(f 'x 'y)

((f) 'x 'y)

(f (g 'x) y)

(f (g 'x) 'y)
\end{Verbatim}
\end{exercise}
\begin{exercise}{5.32}%%
\label{EX5.32}%
С помощью механизма {\tt preserving} компилятор
сможет избежать сохранения и восстановления {\tt env} при
вычислении оператора комбинации~в случае, если это символ.  \index{ru}{вычислитель с явным управлением для Scheme|оптимизация||||(упр.~5.32)}Такие
оптимизации можно было бы встроить и~в интерпретатор.  В сущности,
вычислитель с явным управлением из 
раздела~\ref{THE-EXPLICIT-CONTROL-EVALUATOR} уже проводит одну
подобную оптимизацию, поскольку рассматривает комбинацию без операндов
как особый случай.

\begin{plainenum}


\item
Расширьте вычислитель с явным управлением так,
чтобы он как особый случай рассматривал комбинации,~в которых
оператором является символ, и при вычислении таких выражений
использовал это свойство оператора.

\item
Лиза П.~Хакер говорит, что если заставить
интерпретатор рассматривать все больше особых случаев, то можно
включить~в него все оптимизации компилятора, и при этом все
преимущество компиляции пропадет.  Каково Ваше мнение?
\end{plainenum}
\end{exercise}

\subsection{Компиляция выражений}
\label{COMPILING-EXPRESSIONS}


В этом и следующем разделе мы реализуем генераторы кода, на
которые ссылается процедура {\tt compile}.

\paragraph{Компиляция связующего кода}


\index{ru}{компилятор для Scheme|связующий код||||}
В общем случае результат работы каждого генератора кода
будет заканчиваться командами~--- порожденными процедурой
{\tt compile-linkage},~--- которые реализуют требуемый тип
связи.  Если это тип {\tt return}, то нам надо породить команду
{\tt (goto (reg continue))}.  Она нуждается~в регистре
{\tt continue} и никаких регистров не меняет.  Если тип связи
{\tt next}, то никаких дополнительных команд порождать не
надо.  В остальных случаях тип связи~--- переход по метке, и мы
порождаем команду {\tt goto} на эту метку, команду, которая ни~в чем не
нуждается и не изменяет никакие регистры\footnote{ \index{ru}{список|обратная кавычка||||п}
В этой процедуре используется конструкция Лиспа,
называемая \index{ru}{обратная кавычка||backquote|||п}\index{en}{backquote||обратная кавычка|||п}{\em обратная кавычка} (backquote) или
\index{ru}{квазикавычка||quasiquote|||п}\index{en}{quasiquote||квазикавычка|||п}{\em квазикавычка} (quasiquote), с помощью которой
удобно строить списки.  Обратная кавычка перед списком
работает почти так же, как обычная, но при этом все выражения внутри
списка, перед которыми стоит запятая, вычисляются.
\index{ru}{` (обратная кавычка)||||p|п}%
\index{ru}{, (запятая, внутри обратной кавычки)||||p|п}%
\index{ru}{запятая внутри обратной кавычки||comma,     used with backquote|||п}\index{en}{comma,     used with backquote||запятая внутри обратной кавычки|||п}

Например, если значение {\tt linkage} равно
символу {\tt branch25}, то результатом выражения {\tt `((goto (label
,linkage)))} будет список {\tt ((goto (label
branch25)))}.  Подобным образом, если значением {\tt x}
является список {\tt (a b c)}, то {\tt `(1 2 ,(car x))}
дает при вычислении список {\tt (1 2 a)}.
}.

\begin{Verbatim}[fontsize=\small]
(define (compile-linkage linkage)\index{ru}{compile-linkage||||pd|}
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
\end{Verbatim}
Связующий код добавляется к последовательности команд с сохранением
через {\tt preserving} регистра {\tt continue},
поскольку связь {\tt return} нуждается~в этом регистре: если
данная последовательность команд изменяет {\tt continue}, а
связующий код~в нем нуждается, {\tt continue} будет сохранен и
восстановлен.

\begin{Verbatim}[fontsize=\small]
(define (end-with-linkage linkage instruction-sequence)\index{ru}{end-with-linkage||||pd|}
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
\end{Verbatim}

\paragraph{Компиляция простых выражений}


\index{ru}{компилятор для Scheme|самовычисляющиеся выражения||||}
\index{ru}{компилятор для Scheme|кавычки||||} 
\index{ru}{компилятор для Scheme|переменные||||}
Генераторы кода для самовычисляющихся выражений, кавычек
и переменных строят последовательности команд, которые присваивают
нужное значение целевому регистру,~а затем ведут себя~в соответствии с
описателем связи.

\begin{Verbatim}[fontsize=\small]
(define (compile-self-evaluating exp target linkage)\index{ru}{compile-self-evaluating||||pd|}
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))

(define (compile-quoted exp target linkage)\index{ru}{compile-quoted||||pd|}
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))

(define (compile-variable exp target linkage)\index{ru}{compile-variable||||pd|}
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
\end{Verbatim}
Все эти последовательности команд изменяют целевой регистр,~а для
поиска значения переменной требуется регистр {\tt env}.

\index{ru}{компилятор для Scheme|присваивания||||}  \index{ru}{компилятор для Scheme|определения||||}
Присваивания и определения обрабатываются во многом так
же, как~в интерпретаторе. Мы рекурсивно порождаем код, вычисляющий
значение, которое следует присвоить переменной, и присоединяем его к
последовательности из двух команд, которая собственно присваивает
значение переменной или определяет ее,~а затем заносит~в целевой
регистр значение всего выражения (символ {\tt ok}).
Рекурсивная компиляция вызывается с целевым регистром
{\tt val} и типом связи {\tt next}, так что порождаемый
код положит результат~в регистр {\tt val},~а затем продолжит
выполнение с той последовательности, которая идет за ним.  При
объединении кода сохраняется {\tt env}, поскольку для
определения и присваивания переменной требуется окружение,~а код,
вычисляющий значение переменной, может оказаться сложным выражением, которое
изменяет регистры произвольным образом.

\begin{Verbatim}[fontsize=\small]
(define (compile-assignment exp target linkage)\index{ru}{compile-assignment||||pd|}
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)\index{ru}{compile-definition||||pd|}
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
\end{Verbatim}
Двухкомандная последовательность~в конце нуждается~в {\tt env}
и {\tt val} и изменяет свой целевой регистр.  Заметим, что
мы сохраняем~в последовательности {\tt env},  но не
сохраняем {\tt val}, поскольку {\tt get-value-code} для
того и нужна, чтобы поместить~в {\tt val} результат, которым
затем воспользуется эта последовательность.  (На самом деле
сохранение {\tt val} было бы ошибкой, поскольку
тогда сразу после выполнения {\tt get-value-code}
восстановилось бы старое значение {\tt val}.)

\paragraph{Компиляция условных выражений}


\index{ru}{компилятор для Scheme|условные выражения||||}
Код для выражения {\tt if} с указанными целевым
регистром и типом связи имеет форму

\begin{Verbatim}[fontsize=\small]
 \textit{$\langle$скомпилированный код для предиката с целевым регистром{\tt val}} 
 \textit{и типом связи{\tt next}$\rangle$}
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 \textit{$\langle$скомпилированный код для следствия с указанным целевым регистром и} 
 \textit{указанным типом связи либо{\tt after-if}$\rangle$}
false-branch
 \textit{$\langle$скомпилированный код для альтернативы с указанными
 целевым регистром}
 \textit{и типом связи$\rangle$}
after-if
\end{Verbatim}

Для того, чтобы породить этот код, мы компилируем
предикат, следствие и альтернативу,~а затем сочетаем то, что
получилось, с командами, проверяющими значение предиката и со
свежепорожденными метками, которые отмечают истинную ветвь, ложную ветвь и
конец условного выражения\footnote{Просто использовать метки {\tt true-branch},
{\tt false-branch} и {\tt after-if} нельзя, потому
что~в программе может быть больше одного {\tt if}.  Компьютер
\index{ru}{компилятор для Scheme|порождение меток||||п}порождает метки при помощи процедуры {\tt make-label}.  Она
принимает символ~в качестве аргумента и возвращает новый символ, имя
которого начинается с данного.  Например, последовательные вызовы
{\tt (make-label 'a)} будут возвращать {\tt a1},
{\tt a2} и так далее.  Процедуру {\tt make-label} можно
написать аналогично тому, как порождаются новые имена переменных
в языке запросов, а именно:

\begin{Verbatim}
(define label-counter 0)

(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)

(define (make-label name)\index{ru}{make-label||||pd|п}
  (string->symbol \index{ru}{строка|элементарные процедуры||||п} 
    (string-append (symbol->string name)
                   (number->string (new-label-number)))))
\end{Verbatim}
}. %FOOTNOTE
В этом блоке кода нам требуется обойти истинную ветвь, если предикат
ложен.  Единственная небольшая сложность состоит~в том, какой тип
связи нужно указывать для истинной ветви.  Если тип связи условного
выражения {\tt return} или метка, то и истинная, и ложная ветка
будут этот тип и использовать.  Если же тип связи {\tt next},
то истинная ветвь заканчивается переходом, обходящим код для ложной
ветви, на метку, которая стоит~в конце условного выражения.

\begin{Verbatim}[fontsize=\small]
(define (compile-if exp target linkage)\index{ru}{compile-if||||pd|}
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))                    
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
\end{Verbatim}
При вычислении предиката сохраняется {\tt env}, поскольку он
может потребоваться~в истинной и ложной ветке, и
{\tt continue}, поскольку он может потребоваться связующему
коду~в этих ветвях.  Код для истинной и ложной ветви (которые не
выполняются последовательно) склеивается с помощью особого комбинатора
{\tt parallel-instruction-sequences}, описанного~в 
разделе~\ref{COMBINING-INSTRUCTION-SEQUENCES}.

Заметим, что поскольку {\tt cond} является
производным выражением, для его обработки компилятор должен только
запустить преобразование {\tt cond->if},~а затем
скомпилировать получившееся выражение {\tt if}.

\paragraph{Компиляция последовательностей}

\index{ru}{компилятор для Scheme|последовательности выражений||||}
Компиляция последовательностей (тел процедур и явных
выражений {\tt be\-gin}) происходит так же, как их выполнение.
Компилируется каждое из выражений последовательности~--- последнее с
типом связи, который указан для всей последовательности,~а остальные с
типом связи {\tt next} (для того, чтобы потом выполнялись
остальные выражения последовательности).  Последовательности команд
для отдельных выражений склеиваются и образуют единую
последовательность, при этом сохраняются {\tt env}
(необходимый для остатка последовательности) и {\tt continue}
(возможно, требуемый для связи~в конце последовательности).

\begin{Verbatim}[fontsize=\small]
(define (compile-sequence seq target linkage)\index{ru}{compile-sequence||||pd|}
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
\end{Verbatim}

\paragraph{Компиляция выражений {\tt lambda}}


\index{ru}{компилятор для Scheme|\texttt{lambda}-выражения||||}
Выражения {\tt lambda} строят процедуры.
Объектный код для выражения {\tt lambda} должен иметь вид

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$построить процедурный объект и присвоить его целевому регистру$\rangle$}
\textit{$\langle$связь$\rangle$}
\end{Verbatim}
Компилируя выражения {\tt lambda}, мы одновременно
генерируем код для тела процедуры.  Несмотря на то, что во время
построения процедурного объекта тело исполняться не будет, удобно
вставить его~в код сразу после кода для {\tt lambda}.  Если
связь для выражения {\tt lambda}~--- метка или
{\tt return}, никаких сложностей при этом не возникает.  Если
же у нас тип связи {\tt next}, то нужно обойти код для тела
процедуры, использовав связь, которая переходит на метку, вставляемую
сразу вслед за телом.  Таким образом, объектный код принимает вид

\begin{Verbatim}[fontsize=\small]
 \textit{$\langle$построить процедурный объект и присвоить его целевому регистру$\rangle$}
 \textit{$\langle$код для указанной связи$\rangle$} \em{либо} (goto (label after-lambda))
 \textit{$\langle$скомпилированное тело процедуры$\rangle$}
after-lambda
\end{Verbatim}

Процедура {\tt compile-lambda} порождает код,
строящий процедурный объект, вслед за которым идет код тела
процедуры.  Процедурный объект порождается во время выполнения путем
сочетания текущего окружения (окружения,~в котором исполняется
определение) и точки входа для скомпилированного тела процедуры
(свежесгенерированной метки)\footnote{\label{F5.38}
Нам потребуются машинные операции, которые реализуют
структуру данных, представляющую скомпилированные процедуры,
аналогичную структуре для составных процедур, описанной~в 
разделе~\ref{EVALUATOR-DATA-STRUCTURES}:

\begin{Verbatim}
(define (make-compiled-procedure entry env)\index{ru}{make-compiled-procedure||||pd|п}
  (list 'compiled-procedure entry env))

(define (compiled-procedure? proc)\index{ru}{compiled-procedure||||pd|п}
  (tagged-list? proc 'compiled-procedure))

(define (compiled-procedure-entry c-proc) (cadr c-proc))\index{ru}{compiled-procedure-entry||||pd|п}

(define (compiled-procedure-env c-proc) (caddr c-proc))\index{ru}{compiled-procedure-env||||pd|п}
\end{Verbatim}
}.%FOOTNOTE

\begin{Verbatim}[fontsize=\small]
(define (compile-lambda exp target linkage)\index{ru}{compile-lambda||||pd|}
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
\end{Verbatim}
В {\tt compile-lambda} для того, чтобы добавить тело процедуры
к коду {\tt lambda}-выражения, используется специальный комбинатор
{\tt tack-on-instruction\-sequence} 
(раздел~\ref{COMBINING-INSTRUCTION-SEQUENCES}),~а не
обыкновенный {\tt append-instruction\-sequences}, поскольку тело
процедуры не является частью последовательности команд, выполняемой
при входе~в общую последовательность; оно стоит в
последовательности только потому, что его удобно было сюда
поместить.
{\sloppy

}
Процедура {\tt compile-lambda-body} строит код для
тела процедуры.  Этот код начинается с метки для точки входа.  Затем
идут команды, которые заставят машину во время выполнения войти в
правильное окружение для вычисления тела~--- то есть окружение,
где определена процедура, расширенное связываниями формальных
параметров с аргументами, с которыми она вызвана. Затем следует
код для последовательности выражений, составляющих тело процедуры.
Последовательность эта компилируется с типом связи {\tt return}
и целевым регистром {\tt val}, так что она закончится возвратом
из процедуры с результатом~в регистре {\tt val}.

\begin{Verbatim}[fontsize=\small]
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
\end{Verbatim}

\subsection{Компиляция комбинаций}
\label{COMPILING-COMBINATIONS}


\index{ru}{компилятор для Scheme|комбинации||||}
\index{ru}{компилятор для Scheme|применение процедур||||}
Соль процесса компиляции заключается~в компилировании
вызовов процедур.  Код для комбинации, скомпилированный с данными
целевым регистром и типом связи, имеет вид

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$скомпилированный код оператора с целевым регистром{\tt proc} и типом}
\textit{связи {\tt next}$\rangle$}
\textit{$\langle$вычисление операндов и построение списка аргументов в{\tt argl}$\rangle$}
\textit{$\langle$скомпилированный код вызова процедуры с указанными целевым} 
\textit{регистром и типом связи$\rangle$}
\end{Verbatim}
Во время вычисления оператора и операндов может потребоваться
сохранить и восстановить регистры {\tt env}, {\tt proc}
и {\tt argl}.  Заметим, что это единственное место в
компиляторе, где указывается целевой регистр, отличный от
{\tt val}.

Требуемый код порождается процедурой
{\tt compile-application}.  Она рекурсивно компилирует
оператор, порождая код, который помещает подлежащую вызову процедуру в
{\tt proc}, и операнды, порождая код, который по одному
вычисляет операнды процедурного вызова.  Последовательности команд для
операндов собираются (в процедуре {\tt construct-arglist})
вместе с кодом, который строит список аргументов~в регистре
{\tt argl},~а полученный код для порождения списка аргументов
склеивается с кодом вычисления процедуры и кодом, который производит
собственно вызов (он порождается с помощью
{\tt compile-procedure-call}).  При склеивании
последовательностей команд требуется сохранить регистр
{\tt env} на время вычисления оператора (поскольку~в это время
{\tt env} может измениться,~а он еще потребуется во время
вычисления операндов),~а регистр {\tt proc} требуется сохранить
на время построения списка аргументов (при вычислении операндов
{\tt proc} может измениться,~а он потребуется во время
собственно вызова процедуры).  Наконец, все время следует сохранять
{\tt continue}, поскольку этот регистр нужен для связующего
кода.

\begin{Verbatim}[fontsize=\small]
(define (compile-application exp target linkage)\index{ru}{compile-application||||pd|}
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
\end{Verbatim}

Код для построения списка аргументов вычисляет каждый
операнд, помещая результат~в {\tt val},~а затем с помощью
{\tt cons} прицепляет его к списку аргументов, собираемому в
{\tt argl}.  Поскольку мы по очереди нацепляем аргументы на 
{\tt argl} через {\tt cons}, нам нужно начать с
последнего аргумента и закончить первым, чтобы~в получившемся списке
аргументы стояли~в порядке от первого к последнему.  Чтобы не тратить
команду на инициализацию {\tt argl} пустым списком, прежде чем
начать последовательность вычислений, мы строим исходное значение
{\tt argl}~в первом участке кода.  Таким образом, общая форма
построения списка аргументов такова:

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$компиляция последнего операнда с целью {\tt val}$\rangle$}
(assign argl (op list) (reg val))
\textit{$\langle$компиляция следующего аргумента с целью {\tt val}$\rangle$}
(assign argl (op cons) (reg val) (reg argl))
...
\textit{$\langle$компиляция первого аргумента с целью {\tt val}$\rangle$}
(assign argl (op cons) (reg val) (reg argl))
\end{Verbatim}
Нужно сохранять {\tt argl} при вычислении всех операндов, кроме
как~в самом начале (чтобы уже набранные аргументы не потерялись), а
при вычислении всех операндов, кроме как~в самом конце, нужно
сохранять {\tt env} (его могут использовать последующие
вычисления операндов).

Компилировать код для аргументов довольно сложно, поскольку
особым образом обрабатывается первый вычисляемый операнд, и в
различных местах требуется сохранять {\tt argl} и
{\tt env}.  Процедура {\tt construct-arglist} принимает
в качестве аргументов участки кода, которые вычисляют отдельные
операнды.  Если никаких операндов нет вообще, она попросту порождает
команду

\begin{Verbatim}[fontsize=\small]
(assign argl (const ()))
\end{Verbatim}
В остальных случаях она порождает код, инициализирующий
{\tt argl} последним аргументом, и добавляет к нему код,
который по очереди вычисляет остальные аргументы и добавляет их к
{\tt argl}.  Для того, чтобы аргументы обрабатывались от конца
к началу, нам следует обратить список последовательностей кода для
операндов, подаваемый из {\tt compile-application}.

\begin{Verbatim}[fontsize=\small]
(define (construct-arglist operand-codes)\index{ru}{construct-arglist||||pd|}
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
\end{Verbatim}

\paragraph{Применение процедур}


После того, как элементы комбинации вычислены,
скомпилированный код должен применить процедуру из регистра
{\tt proc} к аргументам из регистра {\tt argl}.  Этот
код рассматривает,~в сущности, те же самые случаи, что и процедура
{\tt apply} из метациклического интерпретатора~в 
разделе~\ref{THE-CORE-OF-THE-EVALUATOR} или точка
входа {\tt apply-dispatch} из вычислителя с явным управлением в
разделе~\ref{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}.
Нужно проверить какая процедура применяется~--- элементарная или составная.  В
случае элементарной процедуры используется
{\tt apply-primitive-procedure}; как ведется работа с
составными процедурами, мы скоро увидим.  Код применения процедуры
имеет такую форму:

\begin{Verbatim}[fontsize=\small]
 (test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 \textit{$\langle$код для применения скомпилированной процедуры с указанной целью}
 \textit{ и подходящим типом связи$\rangle$}
primitive-branch
 (assign \textit{$\langle$целевой регистр$\rangle$}
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 \textit{$\langle$связующий код$\rangle$}
after-call
\end{Verbatim}
Заметим, что если выбрана ветвь для скомпилированной процедуры, машина
должна обойти ветвь для элементарной процедуры.  Следовательно, если
тип связи для исходного вызова процедуры был {\tt next},
ветвь для составной процедуры должна использовать связь с переходом на
метку, стоящую после ветви для элементарной процедуры.  (Подобным
образом работает связь для истинной ветви~в {\tt compile-if}.)

\begin{Verbatim}[fontsize=\small]
(define (compile-procedure-call target linkage)\index{ru}{compile-procedure-call||||pd|}
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
\end{Verbatim}
Ветви для элементарных и составных процедур, подобно истинной и ложной
ветвям~в {\tt compile-if}, склеиваются через
{\tt parallel-instruction-sequences},~а не обыкновенной
{\tt append-instruction-sequences}, по\-ско\-льку они не
выполняются последовательно.
\paragraph{Применение скомпилированных процедур}


Код, обрабатывающий применение процедур,~--- наиболее тонко
устроенная часть компилятора, при том, что он порождает очень
короткие последовательности команд.  У скомпилированной процедуры
(порожденной с помощью {\tt compile-lambda}) имеется точка
входа, то есть метка, указывающая, где начинается тело процедуры.
Код, расположенный по этой метке, вычисляет результат, помещая его в
{\tt val},~а затем возвращается, исполняя команду {\tt (goto
(reg continue))}.  Таким образом, если~в качестве связи
выступает метка, мы можем ожидать, что код для вызова скомпилированной
процедуры (порождаемый с помощью {\tt compile-proc-appl}) с
указанным целевым регистром будет выглядеть так:

\begin{Verbatim}[fontsize=\small]
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign \textit{$\langle$целевой регистр$\rangle$} (reg val)) {\em ; включается, если целевой} 
                                     {\em ; регистр не{\tt val}}
 (goto (label \textit{$\langle$связь$\rangle$}))               {\em ; связующий код}
\end{Verbatim}
либо, если тип связи {\tt return}, так:

\begin{Verbatim}[fontsize=\small]
 (save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign \textit{$\langle$целевой регистр$\rangle$} (reg val)) {\em ; включается, если целевой} 
                                     {\em ; регистр не{\tt val}}
 (restore continue)
 (goto (label \textit{$\langle$связь$\rangle$}))               {\em ; связующий код}
\end{Verbatim}
Этот код устанавливает {\tt continue} так, чтобы процедура
вернулась на метку {\tt proc-return},~а затем переходит на
входную точку процедуры.  Код по метке {\tt proc-return}
переносит результат процедуры из {\tt val}~в целевой регистр
(если нужно),~а затем переходит~в место, определяемое типом связи.
(Связь всегда {\tt return} или метка, поскольку процедура
{\tt compile-procedure-call} заменяет связь {\tt next}
для ветви составной процедуры на переход к метке
{\tt after-call}.)

На самом деле, если целевой регистр не равен
{\tt val}, то именно такой код наш компилятор и
породит\footnote{Мы сообщаем об ошибке, если целевой регистр не
{\tt val}, а тип связи {\tt return}, поскольку
единственное место, где мы требуем связи {\tt return}~--- это
компиляция процедур, а по нашему соглашению процедуры возвращают
значение в регистре {\tt val}.
}.
Однако чаще всего целевым регистром является {\tt val}
(единственное место,~в котором компилятор заказывает другой целевой
регистр~--- это когда вычисление оператора имеет целью
{\tt proc}), так что результат процедуры помещается прямо в
целевой регистр, и возвращаться~в особое место, где он копируется,
незачем.  Вместо этого мы упрощаем код, так устанавливая
{\tt continue}, что процедура <<возвращается>> прямо на то
место, которое указано типом связи вызывающего кода:

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$установить \tt{continue} в соответствии с типом вызова$\rangle$}
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{Verbatim}
Если~в качестве связи указана метка, мы устанавливаем
{\tt continue} так, что возврат происходит на эту метку.
(Таким образом,~в приведенной выше {\tt proc-re\-turn}, команда
{\tt (goto (reg continue))}, которой
кончается процедура, оказывается равносильной {\tt (goto (label
\textit{$\langle$связь$\rangle$}))}.)

\begin{Verbatim}[fontsize=\small]
(assign continue (label \textit{$\langle$связь$\rangle$})
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{Verbatim}
Если тип связи у нас {\tt return}, нам вообще ничего не надо
делать с {\tt continue}: там уже хранится нужное место
возврата.  (То есть команда {\tt (goto (reg continue))},
которой заканчивается процедура, переходит прямо туда, куда перешла бы
{\tt (goto (reg-continue))}, расположенная по метке
{\tt proc-return}.)

\begin{Verbatim}[fontsize=\small]
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{Verbatim}

\index{ru}{хвостовая рекурсия|и компилятор||||}При такой реализации типа связи {\tt return} компилятор
 \index{ru}{компилятор для Scheme|порожденный  код, обладающий свойством хвостовой рекурсии||||} 
порождает код, обладающий свойством хвостовой рекурсии.  Вызов
процедуры, если это последнее действие~в теле процедуры, приводит к
простой передаче управления, когда на стек ничего не кладется.

Предположим, однако, что мы реализовали случай вызова
процедуры с типом связи {\tt return} и целевым регистром
{\tt val} так,  как показано выше для случая с целью
не-{\tt val}.  Хвостовая рекурсия оказалась бы уничтожена.
Наша система по-прежнему вычисляла бы то же значение для всех
выражений.  Однако при каждом вызове процедур мы сохраняли бы
{\tt continue},~а после вызова возвращались бы для (ненужного)
восстановления.   В гнезде рекурсивных вызовов эти дополнительные
сохранения накапливались бы\footnote{Казалось бы, заставить \index{ru}{компилятор|хвостовая рекурсия, выделение памяти на стеке и сборка мусора||||п} компилятор порождать код с
хвостовой рекурсией~--- естественная идея.  Однако большинство
компиляторов для распространенных языков, включая C и Паскаль, так не
делают, и, следовательно,~в этих языках итеративный процесс нельзя
представить только через вызовы процедур.  \index{ru}{сборка мусора|и хвостовая рекурсия||||п} 
\index{ru}{выделение стека и хвостовая рекурсия||stack allocation and tail recursion|||п}\index{en}{stack allocation and tail recursion||выделение стека и хвостовая рекурсия|||п}
\index{ru}{хвостовая рекурсия|и сборка мусора||||п}%
Сложность с хвостовой 
рекурсией~в этих языках состоит~в том, что их реализации сохраняют на
стеке не только адрес возврата, но еще и аргументы процедур и
локальные переменные.  Реализации Scheme, описанные~в этой книге,
хранят аргументы и переменные~в памяти и подвергают их сборке мусора.
Причина использования стека для переменных и аргументов~---~в том,
что при этом можно избежать сборки мусора~в языках, которые не требуют
ее по другим причинам, и вообще считается, что так эффективнее.
На самом деле изощренные реализации Лиспа могут хранить аргументы на
стеке, не уничтожая хвостовую рекурсию.  (Описание можно найти в
Hanson 1990\index{ru}{Хансон, Кристофер~П.||Cristopher~P. Hanson||n|п}\index{en}{Cristopher~P. Hanson||Хансон, Кристофер~П.||n|п}.)
Кроме того, ведутся споры о том,
правда ли, что выделение памяти на стеке эффективнее, чем сборка
мусора, но тут результат, кажется, зависит от тонких деталей
архитектуры компьютера. (См.~Appel 1987 и 
Miller and Rozas 1994,
где по этому вопросу высказываются противоположные мнения.)
\index{ru}{Аппель, Эндрю~У.||Andrew~W. Appel||n|п}\index{en}{Andrew~W. Appel||Аппель, Эндрю~У.||n|п}
\index{ru}{Миллер, Джеймс~С.||James~S. Miller||n|п}\index{en}{James~S. Miller||Миллер, Джеймс~С.||n|п}
\index{ru}{Росас, Гильермо Хуан||Guillermo Juan Rozas||n|п}\index{en}{Guillermo Juan Rozas||Росас, Гильермо Хуан||n|п}
}.

При порождении вышеописанного кода для применения
процедуры {\tt com\-pile-proc-appl} рассматривает четыре случая,
в зависимости от того, является ли {\tt val} целевым регистром,
и от того, дан ли нам тип связи {\tt return}.  Обратите внимание:
указано, что эти последовательности команд изменяют все регистры,
поскольку при выполнении тела процедуры регистрам разрешено меняться
как угодно\footnote{Значением переменной {\tt all-regs} является
список имен всех регистров:\index{ru}{компилятор для Scheme|использование регистров||||п}
{\sloppy

}
\begin{Verbatim}
(define all-regs '(env proc val argl continue))\index{ru}{all-regs (компилятор)||||pd|п}
\end{Verbatim}
}. %FOOTNOTE
Заметим, кроме того, что~в случае с целевым регистром 
{\tt val} и типом связи {\tt return} говорится, что
участок кода нуждается~в {\tt continue}: хотя в
этой двухкомандной последовательности {\tt continue} явно не
упоминается, нам нужно знать, что при входе в
скомпилированную процедуру {\tt continue} будет содержать
правильное значение.

\begin{Verbatim}[fontsize=\small]
(define (compile-proc-appl target linkage)\index{ru}{compile-proc-appl||||pd|}
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "Тип связи return, цель не val -- COMPILE"
                target))))
\end{Verbatim}
\subsection{Сочетание последовательностей команд}
\label{COMBINING-INSTRUCTION-SEQUENCES}


\index{ru}{последовательность команд|||||}
В этом разделе~в деталях описывается представление
последовательностей команд и их сочетание друг с другом.  Напомним, что в
разделе~\ref{STRUCTURE-OF-THE-COMPILER} мы решили, что
последовательность представляется~в виде списка, состоящего из
множества требуемых регистров, множества изменяемых регистров, и
собственно кода.  Кроме того, мы будем считать метку
(символ) особым случаем последовательности, которая не требует и не
изменяет никаких регистров.  Таким образом, для определения регистров,
в которых нуждается и которые изменяет данная последовательность, мы
пользуемся селекторами

\begin{Verbatim}[fontsize=\small]
(define (registers-needed s)\index{ru}{registers-needed||||pd|}
  (if (symbol? s) '() (car s)))

(define (registers-modified s)\index{ru}{registers-modified||||pd|}
  (if (symbol? s) '() (cadr s)))

(define (statements s)\index{ru}{statements||||pd|}
  (if (symbol? s) (list s) (caddr s)))
\end{Verbatim}
а для того, чтобы выяснить, нуждается ли последовательность~в регистре
и изменяет ли она его, используются предикаты

\begin{Verbatim}[fontsize=\small]
(define (needs-register? seq reg)\index{ru}{needs-register?||||pd|}
  (memq reg (registers-needed seq)))

(define (modifies-register? seq reg)\index{ru}{modifies-register?||||pd|}
  (memq reg (registers-modified seq)))
\end{Verbatim}
С помощью этих селекторов и предикатов мы можем реализовать все
многочисленные комбинаторы последовательностей команд, которые используются
в тексте компилятора.

Основным комбинатором является
{\tt append-instruction-sequences}.  Он принимает как аргументы
произвольное число последовательностей команд, которые следует
выполнить последовательно,~а возвращает последовательность команд,
предложениями которой служат предложения всех последовательностей, склеенные
вместе.  Сложность состоит~в том, чтобы определить регистры, которые
требуются, и регистры, которые изменяются~в получаемой
последовательности.  Изменяются те регистры, которые изменяются в
какой-либо из подпоследовательностей; требуются те регистры, которые
должны быть проинициализированы прежде, чем можно запустить первую
подпоследовательность (регистры, требуемые первой
подпоследовательностью),~а также регистры, которые требует любая из
оставшихся подпоследовательностей, не измененные
(проинициализированные) одной из подпоследовательностей, идущих перед
ней.
{\sloppy

}
Последовательности сливаются по две процедурой
{\tt append-2-sequences}.  Она берет две последовательности
команд {\tt seq1} и {\tt seq2}, и возвращает
последовательность команд,~в которой предложениями служат предложения
{\tt seq1},~а затем~в конце добавлены предложения
{\tt seq2}. Ее изменяемые регистры~--- те, которые
изменяет либо {\tt seq1}, либо {\tt seq2},~а требуемые
регистры~--- те, что требует {\tt seq1} плюс
те, что требует {\tt seq2} и не изменяет
{\tt seq1}.  (В терминах операций над множествами, новое
множество требуемых регистров является объединением множества
требуемых регистров {\tt seq1} с множественной разностью
требуемых регистров {\tt seq2} и изменяемых регистров
{\tt seq1}.)  Таким образом,
{\tt append-instruction-sequences} реализуется так:

\begin{Verbatim}[fontsize=\small]
(define (append-instruction-sequences . seqs)\index{ru}{append-instruction-sequences||||pd|}
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
\end{Verbatim}

В этой процедуре используются некоторые операции для работы
с множествами, представленными~в виде списков, подобные
(неотсортированному) представлению множеств, описанному~в 
разделе~\ref{EXAMPLE-REPRESENTING-SETS}:

\begin{Verbatim}[fontsize=\small]
(define (list-union s1 s2)\index{ru}{list-union||||pd|}
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))

(define (list-difference s1 s2)\index{ru}{list-difference||||pd|}
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
\end{Verbatim}

Второй основной комбинатор последовательностей команд,
{\tt preserving}, принимает список регистров {\tt regs}
и две последовательности команд {\tt seq1} и {\tt seq2},
которые следует выполнить последовательно.  Он возвращает
последовательность команд, чьи предложения~--- это предложения
{\tt seq1}, за которыми идут предложения {\tt seq2}, с
командами {\tt save} и {\tt restore} вокруг
{\tt seq1}, для того, чтобы защитить регистры из множества
{\tt regs}, изменяемые~в {\tt seq1}, но требуемые в
{\tt seq2}.  Для того, чтобы построить требуемую
последовательность, сначала {\tt preserving} создает
последовательность, содержащую требуемые команды {\tt save},
команды из {\tt seq1} и команды {\tt restore}.  Эта
последовательность нуждается~в регистрах, которые подвергаются
сохранению/восстановлению,~а также регистрах, требуемых
{\tt seq1}. Она изменяет регистры, которые меняет
{\tt seq1}, за исключением тех, которые сохраняются и
восстанавливаются.  Затем эта дополненная последовательность и
{\tt seq2} сочетаются обычным образом.  Следующая процедура
реализует эту стратегию рекурсивно, двигаясь по списку сохраняемых
регистров\footnote{Заметим, что {\tt preserving} зовет
{\tt append} с тремя аргументами.  Хотя определение
\index{ru}{append|с произвольным числом аргументов|||p|п}
{\tt append}, приводимое~в этой книге, принимает только два
аргумента,~в стандарте Scheme имеется процедура
{\tt append}, принимающая любое их количество.
}:

\begin{Verbatim}[fontsize=\small]
(define (preserving regs seq1 seq2)\index{ru}{preserving||||pd|}
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
\end{Verbatim}

Еще один комбинатор последовательностей,
{\tt tack-on-instruction-se\-qu\-ence}, используется в
{\tt compile-lambda} для того, чтобы добавить тело процедуры к
другой последовательности.  Поскольку тело процедуры не находится <<в
потоке управления>> и не должно выполняться как часть общей
последовательности, используемые им регистры никак не влияют на
регистры, используемые последовательностью,~в которую оно включается.
Таким образом, когда мы добавляем тело процедуры к другой
последовательности, мы игнорируем его множества требуемых и изменяемых
регистров.

\begin{Verbatim}[fontsize=\small]
(define (tack-on-instruction-sequence seq body-seq) \index{ru}{tack-on-instruction-sequence||||pd|}
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
\end{Verbatim}

В процедурах {\tt compile-if} и
{\tt compile-procedure-call} используется специальный
комбинатор {\tt parallel-instruction-sequences}, который
склеивает две альтернативные ветви, следующие за тестом.  Эти две
ветви никогда не исполняются одна за другой; при каждом исполнении
теста будет запущена либо одна, либо другая ветвь.  Поэтому регистры,
требуемые во второй ветви, по-прежнему требуются составной
последовательности, даже если первая ветвь их изменяет.
{\sloppy

}
\begin{Verbatim}[fontsize=\small]
(define (parallel-instruction-sequences seq1 seq2)\index{ru}{parallel-instruction-sequences||||pd|}
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
\end{Verbatim}

\subsection{Пример скомпилированного кода}
\label{AN-EXAMPLE-OF-COMPILED-CODE}


\index{ru}{компилятор для Scheme|пример скомпилированного кода||||}
Теперь, когда мы рассмотрели все элементы компилятора,
можно разобрать пример скомпилированного кода и увидеть, как
сочетаются его элементы.  Мы скомпилируем определение рекурсивной
процедуры {\tt factorial} с помощью вызова
{\tt compile}:
\index{ru}{factorial|компиляция|||p|}

\begin{Verbatim}[fontsize=\small]
(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
\end{Verbatim}
Мы указали, что значение выражения {\tt define} требуется
поместить~в регистр {\tt val}.  Нам неважно, что будет делать
скомпилированный код после того, как будет выполнено
{\tt define}, так что выбор {\tt next}~в качестве типа связи
произволен.

Процедура {\tt compile} распознает выражение как
определение, так что она зовет {\tt compile-definition}, чтобы
породить код для вычисления присваиваемого значения (с целью
{\tt val}), затем код для внесения определения~в среду,
затем код, который помещает значение {\tt define} (символ
{\tt ok})~в целевой регистр, и, наконец, связующий код.  При
вычислении значения сохраняется {\tt env}, поскольку этот
регистр требуется, чтобы внести определение~в среду.  Поскольку тип
связи у нас {\tt next}, никакого связующего кода не
порождается.  Таким образом, скелет скомпилированного кода таков:

\begin{Verbatim}[fontsize=\small]
\textit{$\langle$сохранить {\tt env}, если его изменяет код для вычисления значения$\rangle$}
\textit{$\langle$скомпилированный код для значения определения, цель {\tt val}, связь}
\textit{\tt{next$\rangle$}}
\textit{$\langle$восстановить {\tt env}, если он сохранялся$\rangle$}
(perform (op define-variable!)
         (const factorial)
         (reg val)
         (reg env))
(assign val (const ok))
\end{Verbatim}

Выражение, которое нужно скомпилировать, чтобы получить
значение переменной {\tt factorial}~--- это выражение
{\tt lambda}, и значением его является процедура,
вычисляющая факториалы. {\tt Compile} обрабатывает его путем
вызова {\tt compile-lambda}.  {\tt Compile-lambda}
компилирует тело процедуры,  снабжает его меткой как новую точку
входа и порождает команду, которая склеит тело процедуры по новой
метке с окружением времени выполнения и присвоит значение регистру
{\tt val}.  Затем порожденная последовательность перепрыгивает
через скомпилированный код, который вставляется~в этом месте.  Сам код
процедуры начинается с того, что окружение, где процедура определена,
расширяется кадром,~в котором формальный параметр {\tt n}
связывается с аргументом процедуры.  Затем идет собственно тело
процедуры.  Поскольку код для определения значения переменной не
изменяет регистр {\tt env}, команды {\tt save} и
{\tt restore}, которые показаны выше как возможные, не
порождаются.  (В этот момент не выполняется код процедуры по метке
{\tt entry2}, так что детали его работы с {\tt env}
значения не имеют.)  Следовательно, наш скелет скомпилированного кода
становится таким:

\begin{Verbatim}[fontsize=\small]
  (assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  \textit{$\langle$скомпилированный код тела процедуры$\rangle$}
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
\end{Verbatim}

Тело процедуры всегда компилируется (в
{\tt compile-lambda-body}) как последовательность команд с
целевым регистром {\tt val} и типом связи {\tt return}.
В данном случае~в последовательности одно выражение {\tt if}:

\begin{Verbatim}[fontsize=\small]
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
\end{Verbatim}
{\tt Compile-if} порождает код, который сначала  вычисляет
предикат (с целью {\tt val}), затем проверяет его значение и,
если предикат ложен, обходит истинную ветвь.  При вычислении предиката
сохраняются {\tt env} и {\tt continue}, поскольку они
могут потребоваться~в оставшейся части выражения {\tt if}.
Поскольку выражение {\tt if} последнее (и единственное) в
последовательности, составляющей тело процедуры, оно имеет цель
{\tt val} и тип связи {\tt return}, так что и истинная,
и ложная ветви компилируются с целью {\tt val} и типом связи
{\tt return}.  (Это значит, что значение условного выражения,
которое вычисляется одной из его ветвей,  является значением
процедуры.)

\begin{Verbatim}[fontsize=\small]
  \textit{$\langle$сохранить{\tt continue},{\tt env}, если они изменяются предикатом и}
  \textit{требуются в ветвях$\rangle$}
  \textit{$\langle$скомпилированный код предиката, цель{\tt val}, связь{\tt next}$\rangle$}
  \textit{$\langle$восстановить{\tt continue},{\tt env}, если они сохранялись$\rangle$}
  (test (op false?) (reg val))
  (branch (label false-branch4)
true-branch5
  \textit{$\langle$скомпилированный код истинной ветви, цель{\tt val}, связь{\tt return}$\rangle$}
false-branch4
  \textit{$\langle$скомпилированный код ложной ветви, цель{\tt val}, связь{\tt return}$\rangle$}
after-if3
\end{Verbatim}

Предикат {\tt (= n 1)} является вызовом процедуры.
Он ищет~в окружении оператор (символ {\tt =}) и помещает его
значение~в {\tt proc}.  Затем он собирает аргументы~---
{\tt 1} и значение {\tt n},~---~в {\tt argl}.
Затем он проверяет, лежит ли~в {\tt proc} примитив или
составная процедура, и соответствующим образом переходит на ветвь
элементарной или составной процедуры.  Обе ветви приводят к метке
{\tt after-call}.  Требование сохранять регистры при вычислении
оператора и операндов не приводит ни к каким операциям сохранения,
поскольку~в этом случае вычисления не трогают нужные регистры.

\begin{Verbatim}[fontsize=\small]
  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
after-call15
\end{Verbatim}

Истинная ветвь, константа 1, компилируется (с целевым
регистром {\tt val} и типом связи {\tt return}) в

\begin{Verbatim}[fontsize=\small]
  (assign val (const 1))
  (goto (reg continue))
\end{Verbatim}
Код для ложной ветви является еще одним вызовом процедуры, где
процедурой служит значение символа {\tt *},~а аргументами
--- {\tt n} и значение еще одного вызова (вызова
{\tt factorial}).  Каждый из этих вызовов устанавливает
значения {\tt proc} и {\tt argl},~а также свои
собственные ветви для элементарных и составных процедур.  На 
рисунке~\ref{P5.17} показан полный скомпилированный код для
определения процедуры {\tt factorial}.  Заметим, что возможные
команды {\tt save} и {\tt restore} для
{\tt continue} и {\tt env} при вычислении предиката,
указанные выше, на самом деле порождаются, поскольку эти регистры
изменяются во время вызова процедуры~в предикате и нужны для вызова
процедуры и связи {\tt return}~в ветвях.

\begin{figure}[p]
\begin{Verbatim}[fontsize=\small]
{\em ;; построить процедуру и обойти ее тело}
  (assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))

entry2     {\em ; вызовы{\tt factorial} будут попадать сюда}
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env 
          (op extend-environment) (const (n)) (reg argl) (reg env))

{\em ;; начинается собственно тело процедуры}
  (save continue)
  (save env)

{\em ;; вычислить{\tt (= n 1)}}
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call15   {\em ; здесь{\tt val} содержит результат{\tt (= n 1)}}
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  {\em ; вернуть 1 }
  (assign val (const 1))
  (goto (reg continue))

false-branch4
{\em ;; вычислить и вернуть {\tt(* (factorial (- n 1) n))}}
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   {\em ; сохранить процедуру{\tt *}}
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   {\em ; сохранить частичный список аргументов для{\tt *}}
\end{Verbatim}
\caption{Скомпилированный код определения процедуры {\tt factorial}. 
(Продолжение на следующей странице.)}
\addtocounter{figure}{-1}
\end{figure}
\begin{figure}[p]
\begin{Verbatim}[fontsize=\small]
{\em ;; вычислить {\tt(factorial (- n 1))}, еще один аргумент{\tt *}}
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  {\em ; сохранить процедуру{\tt factorial}}

{\em ;; вычислить{\tt (- n 1)}, аргумент{\tt factorial}}
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call6   {\em ; теперь в{\tt val} содержится результат{\tt (- n 1)}}
  (assign argl (op list) (reg val))
  (restore proc)  {\em ; восстановить{\tt factorial}}
{\em ;; применить{\tt factorial}}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call9       {\em ; теперь{\tt val} содержит результат{\tt (factorial (- n 1))}}
  (restore argl)  {\em ; восстановить частичный список аргументов для{\tt *}}
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)  {\em ; восстановить{\tt *}}
  (restore continue)
{\em ;; применить{\tt *} и вернуть}
{\em ;; его результат}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
{\em ;; обратите внимание:} 
{\em ;; скомпилированная процедура здесь зовется}
{\em ;; с хвостовой рекурсией}
\end{Verbatim}
\caption{Скомпилированный код определения процедуры {\tt factorial}.
Продолжение. (Окончание на следующей странице.)}
\addtocounter{figure}{-1}
\end{figure}
\begin{figure}[t]
\begin{Verbatim}[fontsize=\small]
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
{\em ;; присвоить процедуру переменной{\tt factorial}}
  (perform 
   (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))
\end{Verbatim}
\caption{Скомпилированный код определения процедуры {\tt factorial}.
Окончание.}\index{ru}{factorial|компиляция|||p|}
\label{P5.17}
\end{figure}

\begin{exercise}{5.33}%%
\label{EX5.33}%
Рассмотрим следующее определение процедуры для вычисления
факториала, которое незначительно отличается от рассмотренного в
тексте:

\begin{Verbatim}[fontsize=\small]
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
\end{Verbatim}
Скомпилируйте эту процедуру и сравните получившийся код с кодом для
{\tt factorial}.  Объясните обнаруженные различия.  Есть ли
разница~в эффективности программ?
\end{exercise}
\begin{exercise}{5.34}%%
\label{EX5.34}%
\index{ru}{итеративный процесс|vs. рекурсивный процесс||||(упр.~5.34)}%
\index{ru}{рекурсивный процесс|vs. итеративный процесс||||(упр.~5.34)}%
Скомпилируйте итеративную процедуру вычисления факториала:

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{Verbatim}
Прокомментируйте полученный код и покажите существенное различие между
кодом для итеративной и рекурсивной версий {\tt factorial},
благодаря которому один процесс наращивает глубину стека,
а второй выполняется при фиксированной глубине.
\looseness=1
\end{exercise}
\begin{exercise}{5.35}%%
\label{EX5.35}%
При компиляции какого выражения был получен код на
рисунке~\ref{P5.18}?
\end{exercise}
\pagebreak
\begin{figure}[hp]
\begin{Verbatim}[fontsize=\small]
  (assign val (op make-compiled-procedure) (label entry16)
                                           (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) (const (x)) (reg argl) (reg env))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
\end{Verbatim}
\caption{Пример вывода компилятора. См. упражнение \ref{EX5.35}. (Продолжение 
на следующей странице.)}
\end{figure} 
\pagebreak
\addtocounter{figure}{-1}
\begin{figure}[ht]
\begin{Verbatim}[fontsize=\small]
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))
\end{Verbatim}
\caption{Пример вывода компилятора (продолжение).}.
\label{P5.18} %%%РАЗБИТЬ НА ДВЕ СТРАНИЦЫ!
\end{figure}
%\end{exercise}

\begin{exercise}{5.36}%%
\label{EX5.36}%
\samepage
Какой \index{ru}{порядок вычисления|в компиляторе||||(упр.~5.36)}\index{ru}{компилятор для Scheme|порядок вычисления операндов||||(упр.~5.36)}порядок вычисления задает наш компилятор для
операндов комбинации~--- слева направо, справа налево, или какой-либо
иной?  Где~в компиляторе задается этот порядок?  Измените компилятор
так, чтобы он порождал какой-нибудь другой порядок
вычисления. (См. обсуждение порядка вычисления для вычислителя с явным
управлением из 
раздела~\ref{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}.)  Как
смена порядка вычисления операндов влияет на эффективность кода,
который строит список аргументов?
\end{exercise}
\begin{exercise}{5.37}%%
\label{EX5.37}%
Вот один из способов понять, как механизм
{\tt preserving}\index{ru}{preserving||||p|(упр.~5.37)}\index{ru}{компилятор для Scheme|использование стека||||(упр.~5.37)} 
оптимизирует использование стека:
рассмотреть, какие дополнительные операции порождались бы,
если бы мы этот механизм не использовали.  Измените
{\tt preserving} так, чтобы операции {\tt save} и
{\tt restore} порождались всегда.  Скомпилируйте несколько
простых выражений и отметьте ненужные операции со стеком, которые
станут порождаться.  Сравните этот код с тем, который порождается,
если механизм {\tt preserving} присутствует.
\end{exercise}
\begin{exercise}{5.38}%%
\label{EX5.38}%
Наш компилятор тщательно избегает ненужных операций со
стеком, но с точки зрения перевода вызовов элементарных
процедур языка~в операции машины он очень слаб.
Рассмотрим, например, сколько кода порождается для вычисления {\tt (+
a 1)}: код порождает список аргументов~в {\tt argl},
помещает элементарную процедуру сложения (которую он находит через
поиск символа {\tt +}~в окружении)~в {\tt proc}, затем
проверяет, является ли эта процедура элементарной или составной.
Компилятор всегда порождает код этой проверки,~а также код для ветви
элементарной процедуры и ветви составной процедуры (из которых только
одна будет выполняться).  Мы не показали ту часть контроллера, которая
реализует примитивы, но мы предполагаем, что эти команды используют
элементарные арифметические операции~в путях данных машины.
Рассмотрим, насколько меньше кода будет порождаться, если компилятор
сможет вставлять примитивы~в виде 
\index{ru}{явное кодирование элементарных процедур||open coding of primitives|||(упр.~5.38)}\index{en}{open coding of primitives||явное кодирование элементарных процедур|||(упр.~5.38)}{\em явного кода} (open coding)
--- то есть порождать код, который прямо использует эти машинные операции.
Выражение {\tt (+ a 1)} можно было бы скомпилировать~в простую
последовательность вроде\footnote{Здесь мы одним символом {\tt +} обозначаем и
процедуру исходного языка, и машинную операцию.  В общем случае может
не быть однозначного соответствия примитивов исходного языка
примитивам машины.
}

\begin{Verbatim}[fontsize=\small]
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
\end{Verbatim}
В этом упражнении мы расширим компилятор так, чтобы он поддерживал
явное кодирование отдельных примитивов.  При обращениях к этим
примитивам будет порождаться специально написанный код,~а не общий код
для вызова процедуры.  Для того, чтобы поддержать такую работу, мы
дополним машину специальными регистрами для аргументов
{\tt arg1} и {\tt arg2}.  Элементарные арифметические
операции машины будут принимать свои аргументы~в {\tt arg1} и
{\tt arg2}.  Они могут помещать результаты~в {\tt val},
{\tt arg1} или {\tt arg2}.

Компилятор должен уметь распознавать вызов явно
кодируемого примитива~в исходной программе.  Мы дополним
распознаватель~в процедуре {\tt compile}, так, чтобы он узнавал имена
этих примитивов~в дополнение к 
\index{ru}{зарезервированные слова||reserved words|||(упр.~5.38)}\index{en}{reserved words||зарезервированные слова|||(упр.~5.38)}
зарезервированным словам (особым
формам), которые он узна\"ет сейчас\footnote{Вообще говоря, превращение примитивов в
зарезервированные слова~--- плохая идея, потому что тогда пользователь
не может связать эти имена с другими процедурами.  Более того, если мы
добавим зарезервированные слова~в компилятор, который уже
используется, перестанут работать существующие программы, которые
определяют процедуры с такими именами.  Идеи, как можно избежать этой
проблемы, можно найти~в упражнении~\ref{EX5.44}.
}.
Для каждой особой формы~в компиляторе есть свой генератор кода.  В
этом упражнении мы построим семью генераторов кода для явно
кодируемых примитивов.

\begin{plainenum}


\item
В отличие от особых форм, явно кодируемые примитивы
требуют, чтобы их аргументы вычислялись.  Напишите генератор кода
{\tt spread-arguments}, который будут использовать генераторы
явного кода. {\tt Spread-arguments} должен принимать список
операндов и компилировать данные ему операнды, направляя их в
последовательные аргументные регистры.  Заметим, что операнд может
содержать вызов явно кодируемого примитива, так что во время
вычисления операндов придется сохранять аргументные регистры.

\item
Для каждой из элементарных процедур {\tt =},
{\tt *}, {\tt -} и {\tt +} напишите по
генератору кода, который принимает комбинацию, содержащую этот
оператор вместе с целевым регистром и описателем связи, и порождает
код, который раскидывает аргументы по регистрам,~а затем проводит
операцию с данным целевым регистром и указанным типом связи.
Достаточно обрабатывать только выражения с двумя операндами.
Заставьте {\tt compile} передавать управление этим генераторам
кода.

\item
Опробуйте обновленный компилятор на примере с
процедурой {\tt factorial}.  Сравните полученный результат с
результатом, который получается без открытого кодирования.

\item
Расширьте свои генераторы кода для {\tt +} и
{\tt *} так, чтобы они могли обрабатывать выражения с
произвольным числом операндов.  Выражение,~в котором операндов больше
двух, придется компилировать~в последовательность операций, каждая из
которых работает с двумя входами.
\end{plainenum}
\end{exercise}

\subsection{Лексическая адресация}
\label{LEXICAL-ADDRESSING}


\index{ru}{лексическая адресация|||||}%
\index{ru}{компилятор для Scheme|лексическая адресация||||}%
Одна из наиболее часто встречающихся~в компиляторах
оптимизаций связана с поиском переменных.  В нынешнем виде наш
компилятор использует операцию
{\tt lookup-variable-value} машины-вычислителя.  Эта операция
ищет переменную, сравнивая ее со всеми переменными, связанными в
данный момент, и проходя кадр за кадром по окружению, имеющемуся во
время выполнения.  Если кадр глубоко вложен или если имеется много
переменных, этот поиск может оказаться дорогим.  Рассмотрим, например,
задачу поиска значения {\tt x} при вычислении выражения
{\tt (* x y z)} внутри процедуры, возвращаемой при вычислении

\begin{Verbatim}[fontsize=\small]
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
\end{Verbatim}
Поскольку выражение {\tt let}~--- всего лишь синтаксический
сахар для комбинации {\tt lambda}, это выражение равносильно

\begin{Verbatim}[fontsize=\small]
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
\end{Verbatim}
Каждый раз, когда {\tt lookup-variable-value} ищет
{\tt x}, она должна убедиться, что символ {\tt x} не
равен (через {\tt eq?}) ни {\tt y}, ни {\tt z} (в
первом кадре), ни {\tt a}, {\tt b}, {\tt c},
{\tt d}, ни {\tt e} (во втором).  Предположим, временно,
что~в наших программах не используется {\tt define}~--- что
переменные связываются только через {\tt lambda}.  Поскольку в
нашем языке \index{ru}{лексическая сфера действия|и структура окружений||||}лексическая сфера действия, во время выполнения окружение
любого выражения будет иметь структуру, параллельную лексической
структуре программы,~в которой это выражение встречается\footnote{Это не так, если мы разрешаем внутренние определения
и если мы от них не избавляемся. См.~упражнение~\ref{EX5.43}.
}.
Таким образом, компилятор при анализе вышеуказанного
выражения может узнать, что каждый раз, когда процедура применяется,
переменная с именем 
{\tt x} будет найдена на два кадра выше текущего, и~в этом
кадре будет первая.

Мы можем это использовать и ввести новый вид операции
поиска переменной, {\tt lexical-address-lookup},
\index{ru}{lexical-address-lookup||||p|}
который~в качестве аргументов берет окружение и 
\index{ru}{лексическая адресация|лексический адрес||||}
\index{ru}{лексический адрес||lexical address|||}\index{en}{lexical address||лексический адрес|||}{\em лексический адрес} (lexical address), состоящий из
двух чисел: \index{ru}{номер кадра||frame number|||}\index{en}{frame number||номер кадра|||}{\em номера кадра} (frame number), который
показывает, сколько кадров надо пропустить, и 
\index{ru}{смещение||displacement|||}\index{en}{displacement||смещение|||}{\em смещения} (displacement number), которое
показывает, сколько переменных нужно пропустить~в этом
кадре. {\tt Lexical-address-lookup} будет возвращать значение
переменной, которая имеет указанный лексический адрес по отношению к
текущему окружению.  Добавив~в свою машину
{\tt lexical-address-look\-up}, мы можем научить компилятор
порождать код, который обращается к переменным через эту операцию, а
не через {\tt lookup-variable-value}.  Подобным образом,
скомпилированный код может использовать новую операцию
{\tt lexical-address-set!} вместо
{\tt set-variable-value!}.

Для того, чтобы порождать такой код, компилятор должен
уметь определять лексический адрес переменной, ссылку на которую он
намерен скомпилировать.  Лексический адрес переменной зависит от того,
где она находится~в коде.  Например,~в следующей программе адрес
{\tt x}~в выражении \textit{$\langle$e1$\rangle$} есть (2,0)~--- на два
кадра назад и первая переменная~в кадре.  В этом же месте
{\tt y} имеет адрес (0,0),~а {\tt c}~--- адрес (1,2).  В
выражении \textit{$\langle$e2$\rangle$} {\tt x} имеет адрес (1,0),
{\tt y} адрес (1,1),~а {\tt c} адрес (0,2).

\begin{Verbatim}[fontsize=\small]
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) \textit{$\langle$e1$\rangle$})
      \textit{$\langle$e2$\rangle$}
      (+ c d x))))
 3
 4)
\end{Verbatim}

Один из способов породить~в компиляторе код, который
использует лексическую адресацию, состоит~в поддержании структуры
данных, называемой \index{ru}{окружение времени компиляции||compile-time environment|||}\index{en}{compile-time environment||окружение времени компиляции|||}{\em окружение времени
компиляции} (compile-time environment).  Она следит за тем, какие переменные~в каких позициях
и~в каких кадрах будут находиться~в окружении времени выполнения,
когда будет выполняться определенная операция доступа к переменной.
Окружение времени компиляции представляет собой список кадров, каждый
из которых содержит список переменных.  (Разумеется, с переменными не
будет связано никаких значений, поскольку во время компиляции значения
не вычисляются.)  Окружение времени компиляции становится
дополнительным аргументом процедуры {\tt compile} и передается
всем генераторам кода.  Вызов {\tt compile} верхнего уровня
использует пустое окружение времени компиляции.  Когда компилируется
тело {\tt lambda}, {\tt compile-lambda-body} расширяет
это окружение кадром, содержащим параметры процедуры, так что
последовательность, которая является телом, компилируется~в этом
расширенном окружении.  В каждой точке компиляции
{\tt compile-variable} и {\tt compile-assignment}
используют окружение времени компиляции для порождения соответствующих
лексических адресов.

Упражнения с \ref{EX5.39} по 
\ref{EX5.43} описывают, как завершить этот набросок
лексической адресации и включить~в компилятор лексический поиск.  В
упражнении~\ref{EX5.44} описывается еще один способ
использовать окружение времени компиляции.
\begin{exercise}{5.39}%%
\label{EX5.39}%
Напишите процедуру {\tt lexical-address-lookup},
\index{ru}{lexical-address-lookup||||p|(упр.~5.39)}
которая реализует новую операцию поиска.  Она должна брать два
аргумента~--- лексический адрес и окружение времени выполнения,~--- и
возвращать значение переменной, находящейся по указанному лексическому
адресу.  {\tt Lexical-address-lookup} должна сообщать об
ошибке, если значением переменной является символ
{\tt *unassigned*}\footnote{\index{ru}{компилятор для Scheme|уничтожение внутренних определений||||п}Эта модификация~в поиске переменной требуется~в том
случае, если мы реализуем  \index{ru}{прочесывание внутренних определений|в компиляторе||||п} просмотр текста и уничтожение внутренних
определений (упражнение~\ref{EX5.43}).  Чтобы лексическая
адресация работала, их следует уничтожить.
}.
Кроме того, напишите процедуру {\tt lexical-address-set!},
реализующую операцию, которая изменяет значение переменной по
указанному лексическому адресу.
\end{exercise}
\begin{exercise}{5.40}%%
\label{EX5.40}%
Модифицируйте компилятор так, чтобы он поддерживал
\index{ru}{окружение времени компиляции|||||(упр.~5.40)}окружение времени компиляции, как описано выше. ~а именно,
добавьте аргумент-окружение к {\tt compile} и всем генераторам
кода, и расширяйте его~в {\tt compile-lambda-body}.
\end{exercise}
\begin{exercise}{5.41}%%
\label{EX5.41}%
Напишите процедуру {\tt find-variable}, которая в
качестве аргументов принимает переменную и \index{ru}{окружение времени компиляции|||||(упр.~5.41)}окружение времени
компиляции,~а возвращает лексический адрес переменной по отношению к
этому окружению.  Например, во фрагменте программы, который приведен
выше, окружение времени компиляции при обработке выражения
\textit{$\langle$e1$\rangle$} равно {\tt ((y z) (a b c d e) (x y))}.
{\tt Find-variable} должна давать

\begin{Verbatim}[fontsize=\small]
(find-variable 'c '((y z) (a b c d e) (x y)))
\textit{(1 2)}

(find-variable 'x '((y z) (a b c d e) (x y)))
\textit{(2 0)}

(find-variable 'w '((y z) (a b c d e) (x y)))
\textit{not-found}
\end{Verbatim}
\end{exercise}
\begin{exercise}{5.42}%%
\label{EX5.42}%
С помощью {\tt find-variable} из 
упражнения~\ref{EX5.41} перепишите {\tt compile-variable} и
{\tt compile-assignment} так, чтобы они порождали команды
лексической адресации.  В случаях, когда {\tt find-variable}
возвращает {\tt not-found} (то есть, когда переменной нет в
окружении времени компиляции), нужно заставлять генераторы кода
использовать, как и раньше, операции вычислителя для поиска
связывания.  (Единственное место, где может оказаться переменная, не
найденная во время компиляции~--- это глобальное окружение, которое
является частью окружения времени выполнения, но не окружения времени
компиляции\footnote{Для доступа к переменным~в глобальном окружении
нельзя использовать лексические адреса, поскольку эти имена можно
определять и переопределять интерактивно когда угодно.  Если
внутренние определения вычищены, как~в 
упражнении~\ref{EX5.43}, то компилятор видит только определения
верхнего уровня, которые действуют на глобальное окружение.
Компиляция определения не приводит к тому, что определяемое имя
вводится~в окружение времени компиляции.
}. 
Поэтому, если хотите, можете заставить операции вычислителя искать
сразу~в глобальном окружении, которое можно получить с помощью
операции {\tt (op get-global-environment)},~а не~в полном
локальном окружении, которое хранится~в {\tt env}.)  Проверьте
измененный компилятор на нескольких простых примерах, например, на
вложенной комбинации {\tt lambda} из начала этого раздела.
\end{exercise}
\begin{exercise}{5.43}%%
\label{EX5.43}%
\index{ru}{прочесывание внутренних определений|в компиляторе||||(упр.~5.43)}% 
\index{ru}{компилятор для Scheme|уничтожение внутренних определений||||(упр.~5.43)}%
В разделе~\ref{INTERNAL-DEFINITIONS-CH4} мы
показали, что определения внутри блочной структуры не следует
рассматривать как <<настоящие>> {\tt define}.  Вместо этого
тело процедуры следует интерпретировать так, как будто внутренние
переменные, определяемые через {\tt define}, были введены как
обыкновенные переменные {\tt lambda},~а их настоящее значение
было им присвоено через {\tt set!}.  В 
разделе~\ref{INTERNAL-DEFINITIONS-CH4} и 
упражнении~\ref{EX4.16}
показывалось, как можно изменить метациклический интерпретатор и
добиться этого просмотром внутренних определений.  Измените
компилятор так, чтобы он проводил такое же преобразование, прежде чем
компилировать тело процедуры.
\end{exercise}
\begin{exercise}{5.44}%%
\label{EX5.44}%
\index{ru}{явное кодирование элементарных процедур|||||(упр.~5.44)}%
\index{ru}{окружение времени компиляции|и явное кодирование||||(упр.~5.44)}%
В этом разделе мы~в основном говорили о том, как с
помощью окружения времени компиляции порождать лексические адреса.
Однако такие окружения можно использовать и другими способами.
Например,~в упражнении~\ref{EX5.38} мы повысили
эффективность скомпилированного кода путем явного кодирования
элементарных процедур.  Наша реализация обрабатывала имена явно
кодируемых процедур как
\index{ru}{зарезервированные слова|||||(упр.~5.44)} зарезервированные слова.
Если бы какая-либо 
программа переопределяла такое имя, механизм, описанный~в 
упражнении~\ref{EX5.38},  продолжал бы явно кодировать его как
примитив и игнорировал бы новое связывание.  Рассмотрим, например,
процедуру

\begin{Verbatim}[fontsize=\small]
(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
\end{Verbatim}
которая вычисляет линейную комбинацию {\tt x} и
{\tt y}.  Мы могли бы вызвать такую процедуру с аргументами
{\tt +matrix}, {\tt *matrix} и четырьмя матрицами, но
явно кодирующий компилятор по-прежнему вставлял бы код для
{\tt +} и {\tt *}~в {\tt (+ (* a x) (* b y))} как
для примитивов {\tt +} и {\tt *}.  Измените компилятор с
явным кодированием так, чтобы он проверял окружение времени компиляции
и на его основе порождал правильный код для выражений,~в которых
встречаются имена элементарных процедур.  (Код будет работать
правильно, пока программа не применяет к этим именам
{\tt define} или {\tt set!}.)
\end{exercise}

\subsection{Связь скомпилированного кода с вычислителем}
\label{INTERFACING-COMPILED-CODE-TO-THE-EVALUATOR}


\index{ru}{вычислитель с явным управлением для Scheme|модифицированный для скомпилированного кода||||}
\index{ru}{компилятор для Scheme|связь с вычислителем||||}
\index{ru}{компилятор для Scheme|запуск скомпилированного кода||||}
Пока что мы не объяснили, как загружать скомпилированный
код~в ма\-ши\-ну-вычислитель и как его запускать. Предположим, что
машина-вычислитель с явным управлением определена как~в 
разделе~\ref{RUNNING-THE-EVALUATOR} с дополнительными операциями
из примечания \ref{F5.38}.  Мы реализуем процедуру
{\tt compile-and-go},\index{ru}{compile-and-go||||p|}
которая компилирует выражение на Scheme, загружает получившийся код в
машину-вычислитель,~а затем заставляет машину исполнить код~в глобальном
окружении вычислителя, напечатать результат и войти~в управляющий
цикл.  Вычислитель мы изменим так, чтобы интерпретируемые выражения
могли вызывать не только интерпретируемые, но и скомпилированные
процедуры. После этого мы можем поместить скомпилированную процедуру в
машину и вызвать ее с помощью интерпретатора:

\begin{Verbatim}[fontsize=\small]
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
\textit{;;; Значение EC-Eval:}
\textit{ok}

\textit{;;; Ввод EC-Eval:}
(factorial 5)
\textit{;;; Значение EC-Eval:}
\textit{120}
\end{Verbatim}

Для того, чтобы вычислитель мог обрабатывать
скомпилированные процедуры (например, выполнить вызов
{\tt factorial}, как показано выше), нужно изменить код
{\tt apply-dispatch} 
(раздел~\ref{THE-CORE-OF-THE-EXPLICIT-CONTROL-EVALUATOR}),
чтобы он распознавал их (в отличие от составных и элементарных
процедур) и передавал управление прямо во входную точку
скомпилированного кода\footnote{Разумеется, скомпилированные процедуры являются
составными (неэлементарными) точно так же, как и интерпретируемые.
Однако ради совместимости с терминологией, которая используется при
обсуждении вычислителя с явным управлением, мы~в этом разделе будем
считать, что слово <<составная>> означает <<интерпретируемая>> (а не
скомпилированная).
}:

\begin{Verbatim}[fontsize=\small]
apply-dispatch\index{ru}{apply-dispatch|с учетом скомпилированных процедур|||pd|}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))  
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))

compiled-apply\index{ru}{compiled-apply||||pd|}
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
\end{Verbatim}
Обратите внимание на восстановление {\tt continue} в
{\tt compiled-apply}.  Вспомним, что вычислитель был так
устроен, что при выполнении {\tt apply-dis\-patch} продолжение
находилось на вершине стека.  С другой стороны, входная точка
скомпилированного кода ожидает, что продолжение будет находиться в
{\tt continue}, так что этот регистр надо восстановить, прежде
чем передать управление скомпилированному коду.

Для того, чтобы позволить нам запускать скомпилированный
код при запуске вычислителя, мы~в начало машины добавляем команду
{\tt branch}, которая переводит машину на новую точку входа,
если установлен регистр {\tt flag}\footnote{Теперь, когда код вычислителя начинается с
{\tt branch}, нам перед запуском машины всегда нужно
устанавливать значение {\tt flag}.  Для того, чтобы запустить
машину~в обычном управляющем цикле, можно использовать

\begin{Verbatim}
(define (start-eceval)\index{ru}{start-eceval||||pd|п}
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
\end{Verbatim}
}. %FOOTNOTE

\begin{Verbatim}[fontsize=\small]
  (branch (label external-entry)){\em ; переход, если установлен{\tt flag}}
read-eval-print-loop
  (perform (op initialize-stack))
  ...
\end{Verbatim}
{\tt External-entry} предполагает, что при запуске машины
регистр {\tt val} содержит местоположение последовательности
команд, которая помещает результат~в {\tt val} и заканчивается
командой {\tt (goto (reg continue))}.  Запуск машины с этой
точки входа приводит к переходу~в место, куда показывает
{\tt val}, но сначала {\tt continue} устанавливается в
{\tt print-result}, которая распечатает значение
{\tt val}, а затем направится в начало управляющего цикла
вычислителя\footnote{Поскольку скомпилированная процедура является объектом,
который система может попытаться напечатать, нужно еще изменить
системную операцию печати {\tt user-print} (из 
раздела~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}), чтобы она не
пыталась печатать компоненты скомпилированной процедуры:

\begin{Verbatim}
(define (user-print object) \index{ru}{user-print|измененная для скомпилированного кода|||pd|п}
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((compiled-procedure? object)
         (display '<compiled-procedure>))
        (else (display object))))
\end{Verbatim}
}.%FOOTNOTE!

\begin{Verbatim}[fontsize=\small]
external-entry\index{ru}{external-entry||||pd|}
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
\end{Verbatim}

Теперь с помощью следующей процедуры можно скомпилировать
определение, выполнить скомпилированный код и войти в
управляющий цикл, откуда мы можем процедуру оттестировать.  Поскольку
мы хотим, чтобы скомпилированная процедура возвращалась~в место,
указанное {\tt continue}, со значением~в {\tt val}, мы
компилируем выражение с целевым регистром {\tt val} и типом
связи {\tt return}.  Чтобы преобразовать объектный код,
порождаемый компилятором,~в исполняемые команды регистровой
машины-вычислителя, мы пользуемся процедурой {\tt assemble} из
имитатора регистровых машин (раздел~\ref{THE-ASSEMBLER}).
Затем мы устанавливаем {\tt val}, чтобы он указывал на список
команд, устанавливаем {\tt flag}, чтобы вычислитель пошел на
{\tt external-entry}, и запускаем вычислитель.

\begin{Verbatim}[fontsize=\small]
(define (compile-and-go expression)\index{ru}{compile-and-go||||pd|}
  (let ((instructions
         (assemble (statements
                    (compile expression 'val 'return))
                   eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
\end{Verbatim}

Если мы установим  
\index{ru}{компилятор для Scheme|отслеживание производительности (использования стека) скомпилированного кода||||}
отслеживание стека, как~в конце 
раздела~\ref{RUNNING-THE-EVALUATOR}, то сможем исследовать
использование стека скомпилированным кодом:

\begin{Verbatim}[fontsize=\small]
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))

\textit{(total-pushes = 0 maximum-depth = 0)}
\textit{;;; Значение EC-Eval:}
\textit{ok}

\textit{;;; Ввод EC-Eval:}
(factorial 5)
\textit{(total-pushes = 31 maximum-depth = 14)}
\textit{;;; Значение EC-Eval:}
\textit{120}
\end{Verbatim}
 \index{ru}{компилятор для Scheme|отслеживание производительности (использования стека) скомпилированного кода||||}Сравните этот пример с вычислением {\tt (factorial 5)} с
помощью интерпретируемой версии той же самой процедуры, приведенным в
конце раздела~\ref{RUNNING-THE-EVALUATOR}.  В
интерпретируемой версии потребовалось 144 сохранения и максимальная
глубина стека 28.  Это показывает, какую оптимизацию удалось
получить с помощью нашей стратегии компиляции.

\paragraph{Интерпретация и компиляция}


\index{ru}{интерпретатор|vs. компилятор||||} \index{ru}{компилятор|vs. интерпретатор||||}
При помощи программ из этого раздела мы можем проводить
эксперименты с различными стратегиями выполнения: интерпретацией и
компиляцией\footnote{Можно добиться даже большего, если расширить
компилятор так, чтобы скомпилированный код мог вызывать
интерпретируемые процедуры.  См.~упражнение~\ref{EX5.47}.
}.
Интерпретатор поднимает машину до уровня пользовательской программы;
компилятор опускает пользовательскую программу до уровня машинного
языка.  Можно рассматривать язык Scheme (или любой язык
программирования) как согласованную систему абстракций, построенных
поверх машинного языка.  Интерпретаторы хороши для
интерактивной разработки программ и их отладки, поскольку шаги
выполнения программы организованы~в терминах этих абстракций, и,
следовательно, лучше понятны программисту.  Скомпилированный код может
работать быстрее, поскольку шаги выполнения программы организованы в
терминах машинного языка, и компилятор может проводить оптимизации,
которые нарушают абстракции верхнего уровня\footnote{Независимо от стратегии выполнения, мы
сталкиваемся с существенным замедлением, если требуем, чтобы ошибки,
возникающие при выполнении пользовательской программы, были \index{ru}{обработка ошибок|в скомпилированном коде||||п} обнаружены
и отмечены, а не приводили к смерти системы или к неверным результатам
работы.  Например, индексирование за границы массива можно обнаружить, если
перед обращением к массиву проверить правильность индекса.  Однако
затраты на проверку могут быть во много раз больше, чем стоимость
самого обращения, и программисту приходится взвешивать преимущества
скорости и безопасности, когда он решает, нужна ли такая проверка.
Хороший компилятор должен уметь порождать код с проверками, избегать
лишних проверок и позволять программистам управлять количеством и
видами проверок на ошибки~в скомпилированном коде.

Компиляторы для популярных языков
программирования, вроде \index{ru}{C (Си)|обработка        ошибок||||п} C или C++, почти никаких 
проверок~в работающий 
код не помещают, чтобы программы выполнялись как можно быстрее.  В
результате программистам приходится самим проводить проверку на
ошибки.  К сожалению, многие этим пренебрегают, даже~в критических
приложениях, где скорость не является существенным ограничением.  Их
программы ведут бурную и опасную жизнь.  Например, знаменитый
\index{ru}{<<Червь>>~в Интернете||Internet ``worm''|||п}\index{en}{Internet     ``worm''||<<Червь>>~в Интернете|||п}
<<Червь>>, который парализовал Интернет~в 1988 году, использовал то,
что операционная система  \index{ru}{UNIX (Юникс)|||||п}UNIX${}^{\mbox{\tiny TM}}$ не
проверяла переполнение буфера в демоне
{\tt finger}. (См.~Spafford 1989.)
\index{ru}{Спаффорд, Юджин~Г.||Eugene~H. Spafford||n|п}\index{en}{Eugene~H. Spafford||Спаффорд, Юджин~Г.||n|п}
}.

Компиляция и интерпретация также ведут к различным
стратегиям при 
\index{ru}{перенос языка (на новый компьютер)||porting a language|||}\index{en}{porting a language||перенос языка (на новый компьютер)|||} 
переносе языков на новые компьютеры.  Предположим, что
нам надо реализовать Лисп для новой машины.  Одна стратегия будет
состоять~в том, чтобы взять вычислитель с явным управлением из 
раздела~\ref{THE-EXPLICIT-CONTROL-EVALUATOR} и перевести его
команды~в команды новой машины.  Вторая~---~в том, чтобы
начать с компилятора и изменить генераторы кода так, чтобы они
порождали код новой машины.  Вторая стратегия позволяет запускать
на новой машине любую программу на Лиспе, если сначала скомпилировать ее
компилятором, который работает на исходной Лисп-системе,~а затем
связать со скомпилированной версией рабочей библиотеки\footnote{Разумеется, как при интерпретации, так и при
компиляции придется еще реализовать для новой машины управление
памятью, ввод и вывод,~а также все операции, которые мы считали
<<элементарными>> при обсуждении интерпретатора и компилятора.  Один
из способов минимизировать эту работу заключается~в том, чтобы как
можно большее число этих операций написать на Лиспе,~а затем
скомпилировать для новой машины.  В конце концов все сводится к
простому ядру (например, сборка мусора и механизм для применения
настоящих машинных примитивов), которое кодируется для новой машины
вручную.
}.
Более того, мы можем скомпилировать сам компилятор, и, запустив
его на новой машине, компилировать другие программы на
Лиспе\footnote{Такая стратегия приводит к забавным проверкам
корректности компилятора.  Можно, например, сравнить, совпадает ли
результат компиляции программы на новой машине, с помощью
скомпилированного компилятора, с результатом компиляции той же
программы на исходной Лисп-системе.  Поиск причин расхождения~---
занятие интересное, но зачастую довольно сложное, поскольку результат
может зависеть от микроскопических деталей.
}.
Либо же мы можем скомпилировать один из интерпретаторов из 
раздела~\ref{THE-METACIRCULAR-EVALUATOR} и получить интерпретатор,
который работает на новой машине.
\begin{exercise}{5.45}%%
\label{EX5.45}%
\index{ru}{компилятор для Scheme|отслеживание производительности (использования стека) скомпилированного кода||||(упр.~5.45)}Сравнивая статистику операций со стеком, порождаемую
скомпилированным кодом, с такой же статистикой для интерпретатора,
ведущего то же самое вычисление, можно определить, насколько
компилятор оптимизирует работу со стеком, как по скорости (уменьшая
общее число стековых операций), так и по памяти (уменьшая максимальную
глубину стека).  Сравнение той же статистики с результатами работы
специализированной машины, предназначенной для того же вычисления,
дает некоторое представление о качестве компилятора.

\begin{plainenum}

\item
В упражнении~\ref{EX5.27} от Вас
требовалось определить как функцию от $n$ число
сохранений и максимальную глубину стека, которые требуются вычислителю
для того, чтобы получить $n!$ с помощью указанной
факториальной процедуры.  В упражнении~\ref{EX5.14} Вас
просили провести те же измерения для специализированной факториальной
машины, показанной на рисунке~\ref{P5.11}.  Проведите
теперь тот же анализ для скомпилированной процедуры
{\tt factorial}.
\index{ru}{factorial|использование стека, скомпилированный вариант|||p|(упр.~5.45)}

Возьмем отношение числа сохранений в
скомпилированной версии к числу сохранений~в интерпретируемой версии
и проделаем то же для максимальной глубины стека.  Поскольку число
операций и глубина стека при вычислении $n!$ линейно зависят
от $n$, эти отношения должны приближаться к константам при
росте $n$.  Чему равны эти константы?  Найдите также
отношения показателей использования стека~в специализированной
машине к показателям интерпретируемой версии.

Сравните отношения специализированной версии к
интерпретируемой и отношения скомпилированной версии к
интерпретируемой.  Вы должны увидеть, что специализированная машина
работает намного лучше скомпилированного кода, поскольку настроенный
вручную код контроллера должен быть намного лучше, чем результаты
работы нашего рудиментарного компилятора общего назначения.

\item
Можете ли Вы предложить изменения~в компиляторе,
помогающие ему порождать код, который приблизится к показателям
версии, построенной вручную?
\end{plainenum}
\end{exercise}
\begin{exercise}{5.46}%%
\label{EX5.46}%
\index{ru}{компилятор для Scheme|отслеживание производительности (использования стека) скомпилированного кода||||(упр.~5.46)}%
Проведите анализ, подобный анализу из 
упражнения~\ref{EX5.45}, и определите эффективность компиляции для
процедуры Фибоначчи с древовидной рекурсией
\index{ru}{fib|использование стека, скомпилированный вариант|||p|(упр.~5.46)}

\begin{Verbatim}[fontsize=\small]
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{Verbatim}
по сравнению с эффективностью работы специализированной машины
Фибоначчи с рисунка~\ref{P5.12}.  (Измерения
интерпретируемой версии см.~в упражнении~\ref{EX5.29}.)
Для процедуры Фибоначчи время растет в нелинейной зависимости от
$n$; следовательно, отношение числа стековых операций не
будет приближаться к независимому от $n$ пределу.
\end{exercise}
\begin{exercise}{5.47}%%
\label{EX5.47}%
В этом разделе рассказывалось, как модифицировать
вычислитель с явным управлением и позволить интерпретируемому коду
вызывать скомпилированные процедуры.  Покажите, как можно изменить
компилятор и позволить скомпилированным процедурам вызывать не только
элементарные и скомпилированные процедуры, но и интерпретируемые.  При
этом придется изменить {\tt compile-procedure-call} так, чтобы
обрабатывался случай составных (интерпретируемых) процедур.
Проследите, чтобы обрабатывались все те же сочетания
{\tt target} и {\tt linkage}, что и в
{\tt compile-proc-appl}.  Для того, чтобы произвести собственно
применение процедуры, код должен переходить на точку входа
{\tt compound-apply} вычислителя.  На эту метку нельзя напрямую
ссылаться из объектного кода (потому что ассемблер требует, чтобы все
метки, на которые явно ссылается объектный код,~в нем и определялись),
так что придется добавить~в машину-вычислитель специальный регистр
{\tt compapp},~в котором будет храниться эта точка входа, и
команду для его инициализации:

\begin{Verbatim}[fontsize=\small]
  (assign compapp (label compound-apply))
  (branch (label external-entry)){\em ; переход, если установлен \tt{flag}}
read-eval-print-loop
  ...
\end{Verbatim}
Чтобы проверить свой код, для начала определите процедуру
{\tt f}, которая вызывает процедуру {\tt g}.  С помощью
{\tt compile-and-go} скомпилируйте определение {\tt f} и
запустите вычислитель.  Теперь, вводя код для интерпретации,
определите {\tt g} и попробуйте вызвать {\tt f}.
\end{exercise}
\begin{exercise}{5.48}%%
\label{EX5.48}%
Интерфейс {\tt compile-and-go}, реализованный в
этом разделе, неудобен, поскольку компилятор можно вызвать только один
раз (при запуске машины-вычислителя).  Дополните интерфейс между
компилятором и интерпретатором, введя примитив
{\tt compile-and-run},
\index{ru}{compile-and-run||||p|(упр.~5.48)}
который можно будет вызывать из вычислителя с явным управлением так:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод EC-Eval:}
(compile-and-run
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
\textit{;;; Значение EC-Eval:}
\textit{ok}

\textit{;;; Ввод EC-Eval:}
(factorial 5)
\textit{;;; Значение EC-Eval:}
\textit{120}
\end{Verbatim}
\end{exercise}
\begin{exercise}{5.49}%
\label{EX5.49}%
В качестве альтернативы циклу ввод-выполнение-печать
вычислителя с явным уп\-рав\-ле\-ни\-ем, спроектируйте регистровую машину,
которая работала бы~в цикле ввод-ком\-пи\-ля\-ция-выполнение-печать.
А именно, машина должна работать~в цикле, при каждой итерации которого
она считывает выражение, компилирует его, ассемблирует и исполняет
получившийся код, и печатает результат.  В нашей имитируемой среде это
легко устроить, поскольку мы можем заставить {\tt compile} и
{\tt assemble} работать как <<операции регистровой машины>>.
\end{exercise}
\begin{exercise}{5.50}%%
\label{EX5.50}%
\index{ru}{метациклический интерпретатор для Scheme|компиляция||||(упр.~5.50)}%
С помощью компилятора оттранслируйте метациклический
интерпретатор из раздела~\ref{THE-METACIRCULAR-EVALUATOR}
и запустите эту программу через имитатор регистровых машин.  (Чтобы
скомпилировать за раз более одного определения, можно упаковать
определения~в {\tt begin}.)  Получившийся интерпретатор будет
работать очень медленно из-за многочисленных уровней интерпретации,
однако заставить все детали работать~--- полезное упражнение.
\end{exercise}
\begin{exercise}{5.51}%%
\label{EX5.51}%
Разработайте 
рудиментарную \index{ru}{C (Си)|интерпретатор     Scheme, написанный на Си||||(упр.~5.51)} реализацию Scheme на C (или  
на другом низкоуровневом языке по Вашему выбору), переведя на C
вычислитель с явными управлением из 
раздела~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}.  Для того, чтобы
запустить этот код, Вам потребуется предоставить также функции для
выделения памяти и прочую поддержку времени выполнения.
\end{exercise}
\begin{exercise}{5.52}\label{EX5.52}%
\index{ru}{метациклический интерпретатор для Scheme|компиляция||||(упр.~5.52)}%
В качестве обратной \index{ru}{C (Си)|компиляция            процедур Scheme~в            команды Си||||(упр.~5.52)} задачи к
упражнению~\ref{EX5.51}, измените компилятор так, чтобы он
компилировал процедуры Scheme~в последовательности команд C.  Скомпилируйте
метациклический интерпретатор из 
раздела~\ref{THE-METACIRCULAR-EVALUATOR} и получите
\index{ru}{C (Си)|интерпретатор Scheme, написанный на Си||||(упр.~5.52)} 
интерпретатор Scheme, написанный на C.
\end{exercise}
