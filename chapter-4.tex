\chapter{Метаязыковая абстракция}
\label{METALINGUISTIC-ABSTRACTION}%
%\markboth{Глава 4 \qquad Метаязыковая абстракция}{}
\thispagestyle{empty}
\epigraph{

\ldots Именно в словах кроется магия~--- в таких, как
<<абракадабра>>, <<Сезам, откройся>> и проч.,~--- но магические слова
из одной истории перестают быть таковыми в следующей.  Настоящая магия
состоит в том, чтобы понять, когда и для чего слово сработает; трюк в
том, чтобы выучить трюк.

\ldots А слова эти состоят из букв нашего алфавита: пара
дюжин закорючек, которые мы способны черкнуть пером.  Вот где ключ\ldots!
И сокровище тоже, если только мы сумеем его заполучить!  Как
будто\ldots как будто ключ к сокровищу и {\em есть} само
сокровище!\index{ru}{Барт,~Джон||John Barth||n|}\index{en}{John 
Barth||Барт,~Джон||n|}\index{ru}{Лапицкий, Виктор||||n|}}
{Джон Барт. \\ <<Химера>> \\ (Перевод Виктора Лапицкого)}

Исследуя науку проектирования программ, мы видели,
что программисты-эксперты управляют сложностью своих программ при
помощи тех же общих методик, какими пользуются проектировщики всех
сложных систем.  Они сочетают элементарные единицы, получая при этом
составные объекты, с помощью абстракции составных объектов формируют
строительные блоки высших порядков, и при этом с целью сохранения
модульности выбирают наиболее удобный общий взгляд на структуру
системы.  Демонстрируя эти методы, мы использовали Лисп как язык для
описания процессов и для построения вычислительных объектов данных, и
процессы~--- для моделирования сложных явлений реального мира.  Однако по
мере того, как мы сталкиваемся со все более сложными задачами, мы
обнаруживаем, что Лиспа, да и любого заранее заданного языка
программирования, недостаточно для наших нужд. Чтобы эффективнее
выражать свои мысли, постоянно приходится обращаться к новым
языкам.  Построение новых языков является мощной стратегией управления
сложностью в инженерном проектировании; часто оказывается, что можно
расширить свои возможности работы над сложной задачей, приняв новый
язык,  позволяющий нам описывать (а следовательно, и обдумывать)
задачу новым способом, используя элементы, методы их сочетания и
механизмы абстракции, специально подогнанные под стоящие перед нами
проблемы\footnote{Та же самая идея встречается во всех областях техники.
Например, у инженеров-элек\-т\-рон\-щи\-ков существует множество языков для
описания схем.  Два из них~--- это язык электрических
{\em сетей} и язык электрических {\em систем}.  Язык
сетей делает акцент на физическом моделировании устройств в терминах
дискретных электрических элементов.  Элементарными объектами этого
языка являются элементарные электрические компоненты~--- резисторы,
конденсаторы, катушки индуктивности и транзисторы, задаваемые через
физические переменные: напряжение и ток.  Описывая схемы на языке
сетей, инженер озабочен физическими характеристиками своего проекта.
Элементами системного языка, напротив, являются модули обработки
сигнала, например, фильтры и усилители.  Существенно только
функциональное поведение модулей, и сигналами манипулируют безотносительно
к тому, в виде какого напряжения или тока они реализуются физически.
Язык систем построен на языке сетей, в том смысле, что элементы систем
обработки сигнала состоят из электрических схем.  Однако здесь
инженера интересует крупномасштабная организация электрических
устройств, решающая определенную задачу; их физическая совместимость
подразумевается.  Такая послойная организация языков служит еще одним
примером уровневого метода проектирования, проиллюстрированного в
разделе~\ref{EXAMPLE-A-PICTURE-LANGUAGE} на примере языка
описания изображений.}.

Программирование изобилует языками.\index{ru}{машинный язык|vs. 
высокоуровневый язык||||} Есть физические
языки, например, языки машинных кодов для конкретных компьютеров.
Основным вопросом для них является представление данных и управления
через отдельные биты памяти и машинные команды.  Пишущий программы на
машинном языке озабочен тем, чтобы при помощи данной аппаратуры
создать системы и инструменты для эффективной реализации вычисления
при ограниченных ресурсах. \index{ru}{высокоуровневый язык           vs. машинный язык|||||}Языки высокого уровня, возводимые поверх
машинных, скрывают вопросы конкретной реализации данных в виде набора
битов и представления программ как последовательности машинных
команд.  В этих языках присутствуют средства комбинации и
абстракции, например определения функций, которые подходят для более
крупномасштабной организации систем.

\index{ru}{метаязыковая абстракция||metalinguistic 
abstraction|||}\index{en}{metalinguistic abstraction||метаязыковая 
абстракция|||}{\em Метаязыковая абстракция} (metalinguistic abstraction), 
то есть построение новых языков, играет важную роль во всех отраслях
инженерного проектирования.\index{ru}{абстракция|метаязыковая||||}
Для компьютерного программирования она
особенно важна, поскольку в программировании мы можем не только
формулировать новые языки, но и реализовывать их через построение
вычислителей. \index{ru}{вычислитель||evaluator|||}\index{en}{evaluator||вычислитель|||}{\em Вычислитель} (evaluator) (или 
\index{ru}{интерпретатор||interpreter|||}\index{en}{interpreter||интерпретатор|||}{\em интерпретатор} (interpreter)) для языка
программирования~--- это процедура, которая, будучи примененной к
выражению языка, производит действия, необходимые для вычисления этого
выражения.

Без преувеличения можно сказать, что самая основополагающая
идея в программировании такова:

\begin{quote}
Вычислитель, который определяет значение выражений в
языке программирования~--- всего лишь обычная программа.
\end{quote}
С этой мыслью приходит и новое представление о себе самих:
мы начинаем видеть в себе разработчиков языков, а не
просто пользователей языков, придуманных другими.

На самом деле, почти любую программу можно рассматривать как
вычислитель для какого-то языка.  Например, система работы с
многочленами из раздела~\ref{EXAMPLE-SYMBOLIC-ALGEBRA}
заключает в себе правила арифметики многочленов и реализует их в
терминах операций над данными в списочной форме.  Если мы дополним 
эту
систему процедурами для чтения и печати многочленов, то перед нами
окажется ядро специализированного языка для решения задач
символьной математики.  И программа моделирования цифровой логики из
раздела~\ref{A-SIMULATOR-FOR-DIGITAL-CIRCUITS}, и программа
распространения ограничений из 
раздела~\ref{PROPAGATION-OF-CONSTRAINTS} содержат свои
собственные языки, со своими примитивами, средствами их комбинирования
и абстракции.  С этой точки зрения, техника работы с
крупномасштабными компьютерными системами сливается с техникой
создания новых компьютерных языков, и вся 
\index{ru}{информатика||computer science|||}\index{en}{computer 
science||информатика|||}информатика~--- не более (но и не менее), чем 
наука о построении подходящих языков описания.

Сейчас мы начинаем обзор методов, которые позволяют создавать
одни языки на основе других. В этой главе в качестве основы мы будем
использовать Лисп,  \index{ru}{Lisp (Лисп)|удобство для написания 
вычислителей||||}и вычислители будем реализовывать как процедуры 
на Лиспе.  Лисп особенно хорошо подходит для этой задачи благодаря
своей способности представлять символические выражения и обрабатывать
их.  Первый шаг к пониманию того, как реализуются языки, мы сделаем,
построив вычислитель для самого Лиспа.  Язык, реализуемый нашим
интерпретатором, будет подмножеством диалекта Лиспа Scheme, которым мы
пользуемся в этой книге.  Несмотря на то, что интерпретатор, описанный в
этой главе, написан для конкретного диалекта Лиспа, он содержит
основную структуру вычислителя для любого языка, ориентированного на
выражения и предназначенного для написания программ для
последовательной машины.  (На самом деле, глубоко внутри большинства
языковых процессоров содержится маленький интерпретатор <<Лиспа>>.)  Этот
интерпретатор несколько упрощен для удобства и наглядности обсуждения, и
некоторые детали, которые важно было бы включить в Лисп-систему
промышленного качества, здесь были оставлены за рамками изложения.  Тем не 
менее, этот простой интерпретатор способен выполнить большинство программ 
из данной книги.\footnote{Самое важное, чего не хватает в нашем 
интерпретаторе,~---
это механизмов, обрабатывающих ошибки и поддерживающих отладку.  Более
подробное обсуждение вычислителей можно найти в книге 
Friedman, Wand, and Haynes 1992, которая содержит обзор\index{ru}{Фридман, 
Дэниел~П.||Daniel~P. Friedman||n|п}\index{en}{Daniel~P. Friedman||Фридман, 
Дэниел~П.||n|п}\index{ru}{Хейнс, Кристофер~Т.||Christopher~T. 
Haynes||n|п}\index{en}{Christopher~T. Haynes||Хейнс, 
Кристофер~Т.||n|п}\index{ru}{Ванд, Митчелл||Mitchell 
Wand||n|п}\index{en}{Mitchell Wand||Ванд, Митчелл||n|п}
языков программирования на примере последовательности интерпретаторов,
написанных на Scheme.}

Важное преимущество, которое нам дает вычислитель, доступный в виде
программы на Лиспе, состоит в том, что мы можем реализовывать
альтернативные правила вычисления, описывая их как модификации
программы вычислителя.  В частности, мы можем извлечь из этой
способности немалую выгоду, добиваясь более полного контроля над тем, как
в вычислительных моделях реализуется понятие времени. Этому вопросу была
специально посвящена глава~\ref{MODULARITY-OBJECTS-AND-STATE}.  Там мы смягчили
некоторые сложности работы с состоянием и присваиваниями, при помощи
потоков отделив представление времени во внешнем мире от времени
внутри компьютера.  Однако программы, работающие с потоками, иногда
бывали излишне громоздки, поскольку их ограничивал аппликативный порядок
вычисления, принятый в Scheme.  В 
разделе~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION} мы изменим
язык и получим более изящный подход в виде интерпретатора с 
\index{ru}{нормальный порядок вычислений||normal-order 
evaluation|||}\index{en}{normal-order evaluation||нормальный порядок 
вычислений|||}{\em нормальным порядком вычисления} (normal-order 
evaluation).

В разделе~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}
язык меняется более радикально, и выражения получают
не одно единственное значение, а множество.  В этом языке 
\index{ru}{недетерминистские вычисления||non\-de\-ter\-mi\-nis\-tic 
computing|||}\index{en}{nondeterministic computing||недетерминистские 
вычисления|||}{\em недетерминистских
вычислений} (nondeterministic computing) становится естественным порождать 
все возможные значения выражения, а затем искать среди них те, которые 
удовлетворяют определенным ограничениям.  Если описывать это в терминах
вычисления и времени, то время как будто
разветвляется на множество <<возможных будущих>>, и мы ищем среди них
подходящие временные линии.  При работе с недетерминистским интерпретатором
отслеживание множества значений и поиск осуществляются автоматически
встроенными механизмами языка.

В разделе~\ref{LOGIC-PROGRAMMING} мы реализуем язык
\index{ru}{логическое программирование||logic 
programming|||}\index{en}{logic programming||логическое 
программирование|||}{\em логического
программирования} (logic programming), в котором знание выражается в терминах
отношений, а не в терминах вычислений со входами и выходами.  Несмотря
на то, что язык при этом оказывается сильно отличным от Лиспа, как,
впрочем, и от любого привычного языка, мы увидим, что интерпретатор
для языка логического программирования имеет, в сущности, ту же
структуру, что и интерпретатор Лиспа.

\section{Метациклический интерпретатор}
\label{THE-METACIRCULAR-EVALUATOR}%


\index{ru}{метациклический интерпретатор для Scheme|||||}Наш интерпретатор 
Лиспа будет реализован как программа на
Лиспе.  Может показаться, что размышления о выполнении Лисп-программ
при помощи интерпретатора, который сам написан на Лиспе, составляют
порочный круг.  Однако вычисление есть процесс, так что вполне
логично описывать процесс вычисления с помощью Лиспа~--- в конце
концов, это наш инструмент для описания процессов\footnote{Даже с учетом 
этого, остаются важные стороны процесса
вычисления, которые в нашем интерпретаторе не проясняются.  Самая
важная из них~--- точные механизмы того, как одни процедуры вызывают
другие и возвращают значения процедурам, которые их вызвали.  Эти
вопросы мы рассмотрим  в 
главе~\ref{COMPUTING-WITH-REGISTER-MACHINES}, где мы
исследуем процесс вычисления более внимательно, реализуя
вычислитель как простую регистровую машину.}.
Интерпретатор, написанный на языке, который он сам реализует,
называется 
\index{ru}{вычислитель|метациклический||||}\index{ru}{метациклический 
интерпретатор для Scheme||metacircular evaluator for 
Scheme|||}\index{en}{metacircular evaluator for Scheme||метациклический 
интерпретатор для Scheme|||}{\em метациклическим} (metacircular).

\index{ru}{модель вычисления с окружениями|и метациклический 
интерпретатор||||} В сущности,
метациклический интерпретатор является 
\index{ru}{метациклический интерпретатор для Scheme|модель вычислений с 
окружениями||||}формулировкой на языке Scheme модели вычислений
с окружениями, описанной в 
разделе~\ref{THE-ENVIRONMENT-MODEL-OF-EVALUATION}. Напомним, что в этой
модели было две основные части: 

\begin{plainlist}
\item
Чтобы выполнить комбинацию (составное выражение, не
являющееся особой формой), нужно вычислить его подвыражения и затем
применить значение подвыражения-оператора к значениям
подвыражений-операндов.

\item
Чтобы применить составную процедуру к набору
аргументов, нужно выполнить тело процедуры в новом окружении.  Для
того, чтобы построить это окружение, нужно расширить окружение
объекта-процедуры кадром, в котором формальные параметры процедуры
связаны с аргументами, к которым процедура применяется.
\end{plainlist}

Эти два правила описывают сущность процесса вычисления,
основной цикл, в котором выражения, которые требуется выполнить в
окружении, сводятся к процедурам, которые нужно применить к
аргументам, а те, в свою очередь,  сводятся к новым выражениям,
которые нужно выполнить в новых окружениях, и так далее, пока мы не
доберемся до символов, чьи значения достаточно найти в окружении,
и элементарных процедур, которые применяются напрямую 
(см.~рис.~\ref{P4.1})\footnote{Если нам 
дается возможность применять примитивы, то что
остается сделать для реализации интерпретатора?
\index{ru}{метациклический интерпретатор для Scheme|задача||||п}Задача 
интерпретатора состоит не в том, чтобы определить примитивы языка, а в
том, чтобы обеспечить связующие элементы~--- средства комбинирования и
абстракции,~--- которые превращают набор примитивов в язык.  А
именно:

\begin{plainlist}
\item
Интерпретатор позволяет работать с вложенными
выражениями.  Например, чтобы вычислить значение выражения
{\tt (+ 1 6)}, достаточно применения примитивов, но этого
недостаточно для работы с выражением {\tt (+ 1 (* 2 3))}.  Сама
по себе элементарная процедура {\tt +} способна работать только
с числами, и если передать ей аргумент~--- выражение {\tt (* 2
3)}, она сломается.  Одна из важных задач интерпретатора
--- устроить вычисление так, чтобы
{\tt (* 2 3)} свелось к значению 6, прежде чем оно будет
передано {\tt +} как аргумент.

\item
Интерпретатор позволяет использовать
переменные.  Например, элементарная процедура сложения не знает, как
работать с выражениями вроде {\tt (+ x 1)}.  Нам нужен
интерпретатор, чтобы следить за переменными и получать их значения,
прежде чем запускать элементарные процедуры.

\item
Интерпретатор позволяет определять составные
процедуры.  При этом нужно хранить определения процедур, знать, как
эти определения используются при вычислении выражений, и обеспечивать
механизм, который позволяет процедурам принимать аргументы.

\item
Интерпретатор дает особые формы, вычисляющиеся
иначе, чем вызовы процедур.
\end{plainlist}%
}.
Этот цикл вычисления будет построен в виде взаимодействия двух
основных процедур интерпретатора, {\tt eval} и
{\tt apply}, описанных в 
разделе~\ref{THE-CORE-OF-THE-EVALUATOR}
(см.~рис.~\ref{P4.1}).

Реализация интерпретатора будет зависеть от процедур, 
определяющих
\index{ru}{синтаксис||syntax|||}\index{en}{syntax||синтаксис|||}{\em 
синтаксис} (syntax) выполняемых выражений.
\index{ru}{метациклический интерпретатор для Scheme|абстракция 
данных||||}При помощи абстракции данных мы сделаем интерпретатор
независимым от представления языка.  К примеру, вместо того, чтобы
окончательно решать, что присваивание выражается в виде списка, в
котором первым элементом стоит символ {\tt set!}, мы пользуемся
абстрактным предикатом {\tt assignment?}, чтобы распознавать
присваивание, и абстрактными селекторами
{\tt assignment-variable} и {\tt assignment-value},
чтобы обращаться к его частям.  Реализация выражений будет подробно
рассмотрена в разделе~\ref{REPRESENTING-EXPRESSIONS}.
Имеются также операции, описанные в 
разделе~\ref{EVALUATOR-DATA-STRUCTURES}, которые определяют
представление процедур и окружений.  Например,
{\tt make-proce\-dure} порождает составные процедуры, %HERE315
{\tt lookup-variable-value} извлекает значения переменных, а
{\tt apply-primitive-procedure} применяет элементарную
процедуру к указанному списку аргументов.

\begin{cntrfig}
\input{xfig-mod/4-1.eepic}
%{\small процедура, аргументы\\
%выражение, окружение}
\caption{\index{ru}{метациклический интерпретатор для Scheme|цикл \texttt{eval}--\texttt{apply}||||}
Цикл {\tt eval}--{\tt apply}
раскрывает сущность компьютерного языка.}
\label{P4.1}%
\end{cntrfig}

\subsection{Ядро интерпретатора}
\label{THE-CORE-OF-THE-EVALUATOR}%


Процесс вычисления можно описать как взаимодействие двух
процедур: \index{ru}{метациклический интерпретатор для 
Scheme|\texttt{eval} и \texttt{apply}||||}{\tt eval} и {\tt apply}.

\paragraph{Eval}


Процедура {\tt eval}\index{ru}{eval (метациклическая)||||p|}
в качестве аргументов принимает
выражение и окружение. Она относит выражение к одному из возможных
классов и управляет его выполнением. {\tt Eval} построена как
разбор случаев в зависимости от синтаксического
типа выполняемого выражения.  Для того, чтобы процедура была
достаточно общей, определение типа выражения мы формулируем абстрактно,
не связывая себя никакой конкретной 
\index{ru}{метациклический интерпретатор для Scheme|представление 
выражений||||}реализацией различных типов выражений.  Для каждого типа
выражений имеется предикат, который 
распознает этот тип, и абстрактные 
\index{ru}{метациклический интерпретатор для Scheme|абстракция 
данных||||}средства для выбора его частей. Такой 
\index{ru}{абстрактный синтаксис|в метациклическом интерпретаторе|abstract 
syntax|||}\index{en}{abstract syntax||абстрактный синтаксис|в 
метациклическом интерпретаторе||}{\em абстрактный синтаксис} (abstract syntax)
позволяет легко видеть, как можно изменить синтаксис языка и
использовать тот же самый интерпретатор, но только с другим набором
синтаксических процедур.

\medskip
{\em Элементарные выражения}
\begin{plainlist}
\item
 \index{ru}{выражение|самовычисляющееся||||}\index{ru}{самовычисляющееся 
выражение||self-evaluating expression|||}\index{en}{self-evaluating 
expression||самовычисляющееся выражение|||}Для самовычисляющихся
выражений, например, чисел, {\tt eval} возвращает само выражение.

\item
{\tt Eval} должен  находить значения переменных, просматривая окружение.
\end{plainlist}

\medskip

{\em Особые формы}
\begin{plainlist}
\item
Для выражений с кавычкой ({\tt quote}),
{\tt eval} возвращает само закавыченное выражение.

\item
Присваивание переменной (или ее определение) должно
вызвать {\tt eval} рекурсивно, чтобы вычислить новое значение,
которое требуется связать с переменной.  Окружение нужно
модифицировать, изменяя (или создавая) связывание для
переменной.

\item
Выражение {\tt if} требует специальной
обработки своих частей: если предикат истинен, нужно выполнить
следствие; если нет, альтернативу.

\item
Выражение {\tt lambda} требуется
преобразовать в процедуру, пригодную к применению.  Для этого нужно
упаковать параметры и тело {\tt lambda}-выраже\-ния вместе
с окружением, в котором оно вычисляется.

\item
Выражение {\tt begin} требует выполнения
своих подвыражений в том порядке, как они появляются.

\item
Разбор случаев ({\tt cond}) преобразуется во вложенные
выражения {\tt if} и затем вычисляется.
\end{plainlist}

\medskip

{\em Комбинации}
\begin{plainlist}
\item
Для применения процедуры {\tt eval} должна
рекурсивно вычислить операцию и операнды комбинации.  Получившиеся
процедура и аргументы передаются {\tt apply}, которая распоряжается
собственно применением процедуры.
\end{plainlist}

Вот определение {\tt eval}:

\begin{Verbatim}[fontsize=\small]
(define (eval exp env)\index{ru}{eval (метациклическая)||||pd|}
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Неизвестный тип выражения -- EVAL" exp))))
\end{Verbatim}

Ясности ради, {\tt eval} реализована как
\index{ru}{разбор случаев|vs. стиль, управляемый 
данными||||}\index{ru}{программирование, управляемое  данными|vs. разбор 
случаев||||}перебор альтернатив через {\tt cond}.  Недостаток этой 
реализации~--- наша
процедура обрабатывает только несколько указанных типов выражений, и,
не меняя определение {\tt eval}, новые типы добавить нельзя.  В
большинстве реализаций Лиспа распределение выражений по типам сделано
в стиле, управляемом данными.  Это дает пользователю возможность добавлять
новые типы выражений, которые {\tt eval} будет способен
распознать, не меняя само определение {\tt eval}. 
(См.~упражнение~\ref{EX4.3}.)

\paragraph{Apply}


Процедура {\tt apply} принимает два аргумента:
процедуру и список аргументов, к которым ее надо
применить. {\tt Apply} делит процедуры на два класса: для
применения примитивов она зовет {\tt 
apply-primitive-procedure};\index{ru}{apply-primitive-procedure||||p|}
составные процедуры она
применяет, по очереди вычисляя выражения, составляющие тело
процедуры.  Окружение, в котором вычисляется тело составной процедуры,
получается из базового окружения, хранящегося в
процедуре, добалением кадра, где параметры процедуры связываются с
аргументами, к которым процедура применяется.  Вот определение
{\tt apply}:

\begin{Verbatim}[fontsize=\small]
(define (apply procedure arguments)\index{ru}{apply (метациклическая)||||pd|}
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Неизвестный тип процедуры -- APPLY" procedure))))
\end{Verbatim}

\paragraph{Аргументы процедур}

Обрабатывая применение процедуры, {\tt eval} 
получает список аргументов, к которым процедуру надо
применить, при помощи {\tt list-of-values}.  Процедура
{\tt list-of-values} в качестве аргумента берет список
операндов комбинации.  Она вычисляет каждый аргумент и возвращает
список соответствующих значений\footnote{Ветку {\tt application?} в {\tt eval}
можно было бы упростить, используя {\tt map} (и постановив, что
{\tt operands} возвращает список) вместо того, чтобы писать
явным образом процедуру {\tt list-of-values}.  Мы решили не
использовать здесь {\tt map}, чтобы подчеркнуть, что\index{ru}{процедура 
высшего порядка|в метациклическом 
интерпретаторе||||п}\index{ru}{метациклический интерпретатор для 
Scheme|процедура высшего порядка||||п} 
интерпретатор можно написать без обращения к процедурам высших
порядков (а следовательно, его можно написать на языке, в котором нет
таких процедур), притом, что язык, поддерживаемый интерпретатором, содержит
процедуры высших порядков.}.

\begin{Verbatim}[fontsize=\small]
(define (list-of-values exps env)\index{ru}{list-of-values||||pd|}
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
\end{Verbatim}

\paragraph{Условные выражения}

Процедура {\tt eval-if} вычисляет предикатную
часть выражения {\tt if} в данном окружении.  Если результат
истинен, {\tt eval-if} выполняет следствие, если нет, ---
альтернативу:

\begin{Verbatim}[fontsize=\small]
(define (eval-if exp env)\index{ru}{eval-if (метациклическая)||||pd|}
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{Verbatim}

Использование {\tt true?} в {\tt eval-if}
подчеркивает вопрос о связи между 
\index{ru}{метациклический интерпретатор для Scheme|реализуемый язык vs. 
язык реализации||||}реализуемым языком и языком
реализации. Выражение {\tt if-predicate} выполняется в
реализуемом языке, и, следовательно, результат его является значением
этого языка.  Предикат интерпретатора {\tt true?} переводит это
значение в значение, которое может быть проверено выражением
{\tt if} в языке реализации: метациклическое представление
истины может не совпадать с ее представлением в нижележащей Scheme\footnote{В 
нашем случае, язык реализации и реализуемый язык
совпадают.  Размышления о значении {\tt true?} расширяют наше сознание 
безотносительно к материальной сущности истины.\index{ru}{самосознание, 
повышение уровня||expansion of consciousness|||п}\index{en}{expansion of 
consciousness||самосознание, повышение уровня|||п}}.

\paragraph{Последовательности}


Процедура {\tt eval-sequence} вызывается из
{\tt apply} для выполнения последовательности выражений в теле
процедуры, а также из {\tt eval} для обработки
последовательности выражений в выражении {\tt begin}.  Она
принимает в виде аргументов последовательность выражений и окружение,
и выполняет выражения в том порядке, в котором они ей даны.
Возвращаемое значение совпадает со значением последнего выражения.

\begin{Verbatim}[fontsize=\small]
(define (eval-sequence exps env)\index{ru}{eval-sequence||||pd|}
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
\end{Verbatim}

\paragraph{Присваивания и определения}


Следующая процедура обрабатывает присваивание
переменным.  При помощи {\tt eval} она находит значение,
которое требуется присвоить, и передает переменную и получившееся
значение в процедуру {\tt set-variable-value!} для включения в
текущее окружение.

\begin{Verbatim}[fontsize=\small]
(define (eval-assignment exp env)\index{ru}{eval-assignment||||pd|}
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
\end{Verbatim}
Определения переменных обрабатываются сходным образом\footnote{Эта 
реализация {\tt define} не учитывает один
тонкий вопрос в обработке внутренних определений, хотя в большинстве
случаев работает правильно.  В чем состоит проблема и как ее
решить, мы увидим в разделе~\ref{INTERNAL-DEFINITIONS-CH4}.}:

\begin{Verbatim}[fontsize=\small]
(define (eval-definition exp env)\index{ru}{eval-definition||||pd|}
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
\end{Verbatim}
В качестве возвращаемого значения для присваивания или определения мы
выбрали символ {\tt ok}\footnote{Как мы упоминали при введении {\tt define} и
{\tt set!}, их значения в Scheme зависят от реализации~--- то
есть автор реализации имеет право выбрать такое значение, какое он хочет.}.

\begin{exercise}{4.1}\label{EX4.1}%
\index{ru}{метациклический интерпретатор для Scheme|порядок вычисления операндов||||(упр.~4.1)}%
\index{ru}{порядок вычисления|в метациклическом интерпретаторе||||(упр.~4.1)}%
Заметим, что мы не можем сказать, вычисляет ли
метациклический интерпретатор операнды слева направо или справа
налево.  Порядок вычисления наследуется от нижележащего Лиспа: если аргументы
{\tt cons} в процедуре {\tt list-of-values} вычисляются
слева направо, то и операнды в {\tt list-of-values} будут
вычисляться слева направо.  Если же вычисление аргументов {\tt cons}
происходит справа налево, то и {\tt list-of-values} будет
вычислять операнды справа налево.

Напишите версию {\tt list-of-values}, которая
вычисляет операнды слева направо, вне зависимости от порядка
вычислений в нижележащем Лиспе.  Напишите также версию, которая
вычисляет операнды справа налево.
\end{exercise}

\subsection{Представление выражений}
\label{REPRESENTING-EXPRESSIONS}%


\index{ru}{метациклический интерпретатор для Scheme|синтаксис 
интерпретируемого языка||||}\index{ru}{метациклический интерпретатор для 
Scheme|представление выражений||||}Интерпретатор напоминает программу
\index{ru}{метациклический интерпретатор для Scheme|и символьное 
дифференцирование||||}символьного дифференцирования, описанную в
разделе~\ref{EXAMPLE-SYMBOLIC-DIFFERENTIATION}.  Обе программы
работают с символьными выражениями.  В обеих результат
работы с составным выражением определяется рекурсивной обработкой
частей выражения и сочетанием частичных результатов, причем способ
сочетания зависит от типа выражения.  И там, и там мы
использовали 
\index{ru}{абстракция данных|||||}абстракцию данных, чтобы отделить общие 
правила работы от
деталей того, как представлены выражения.  Для программы
дифференцирования это означало, что одна и та же процедура взятия
производной могла работать с алгебраическими выражениями в префиксной,
инфиксной или какой-либо другой записи.  Для интерпретатора это
означает, что синтаксис языка определяется исключительно процедурами,
которые классифицируют выражения и выделяют их части.

Вот описание синтаксиса нашего языка:

\begin{plainlist}
\item
К самовычисляющимся объектам относятся только числа
и строки:

\begin{Verbatim}[fontsize=\small]
(define (self-evaluating? exp) \index{ru}{self-evaluating?||||pd|}
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
\end{Verbatim}

\item
Переменные представляются в виде символов:

\begin{Verbatim}[fontsize=\small]
(define (variable? exp) (symbol? exp)) \index{ru}{variable?||||pd|}
\end{Verbatim}

\item
Выражения с кавычкой имеют форму {\tt (quote
\textit{$\langle$закавыченное-вы\-ра\-же\-ние$\rangle$})}:

\begin{Verbatim}[fontsize=\small]
(define (quoted? exp) \index{ru}{quoted?||||pd|}
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp)) \index{ru}{text-of-quotation||||pd|}
\end{Verbatim}
{\tt Quoted?} определена посредством процедуры
{\tt tagged-list?}, которая распознает списки, начинающиеся с
указанного символа\footnote{В разделе~\ref{QUOTATION} упоминается,
что интерпретатор рассматривает закавыченное 
выражение как список, начинающийся с {\tt quote}, даже если
выражение напечатано через знак кавычки.  Например, выражение
{\tt 'a} будет выглядеть для интерпретатора как {\tt (quote
a)}.  См.~упражнение~\ref{EX2.55}.}:

\begin{Verbatim}[fontsize=\small]
(define (tagged-list? exp tag) \index{ru}{tagged-list?||||pd|}
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
\end{Verbatim}

\item
Присваивания имеют форму 
{\tt (set! \textit{$\langle$переменная$\rangle$} \textit{$\langle$выражение$\rangle$})}:

\begin{Verbatim}[fontsize=\small]
(define (assignment? exp)\index{ru}{assignment?||||pd|}
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))\index{ru}{assignment-variable||||pd|}

(define (assignment-value exp) (caddr exp))\index{ru}{assignment-value||||pd|}
\end{Verbatim}

\item
Определения имеют вид

\begin{Verbatim}[fontsize=\small]
(define \textit{$\langle$переменная$\rangle$} \textit{$\langle$значение$\rangle$})
\end{Verbatim}
или

\begin{Verbatim}[fontsize=\small]
(define (\textit{$\langle$переменная$\rangle$} \textit{$\langle$параметр${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$параметр${}_{\mbox{n}}$$\rangle$})
  \textit{$\langle$тело$\rangle$})
\end{Verbatim}
Вторая форма (стандартное определение процедуры) является
\index{ru}{синтаксический сахар|\texttt{define}||||}синтаксическим сахаром 
для\index{ru}{define (особая форма)|синтаксический сахар|||p|}

\begin{Verbatim}[fontsize=\small]
(define \textit{$\langle$переменная$\rangle$}
  (lambda (\textit{$\langle$параметр${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$параметр${}_{\mbox{n}}$$\rangle$})
    \textit{$\langle$тело$\rangle$}))
\end{Verbatim}
Соответствующие синтаксические процедуры выглядят так:

\begin{Verbatim}[fontsize=\small]
(define (definition? exp)\index{ru}{definition?||||pd|}
  (tagged-list? exp 'define))

(define (definition-variable exp)\index{ru}{definition-variable||||pd|}
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)\index{ru}{definition-value||||pd|}
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
\end{Verbatim}

\item
{\tt Lambda}-выражения являются списками,
которые начинаются с символа {\tt lambda}:

\begin{Verbatim}[fontsize=\small]
(define (lambda? exp) (tagged-list? exp 'lambda))\index{ru}{lambda?||||pd|}

(define (lambda-parameters exp) (cadr exp))\index{ru}{lambda-parameters||||pd|}

(define (lambda-body exp) (cddr exp))\index{ru}{lambda-body||||pd|}
\end{Verbatim}
Мы приводим также конструктор для {\tt lambda}-выражений.  Он
используется в вышеприведенной процедуре
{\tt definition-value}:

\begin{Verbatim}[fontsize=\small]
(define (make-lambda parameters body)\index{ru}{make-lambda||||pd|}
  (cons 'lambda (cons parameters body)))
\end{Verbatim}

\item
Условные выражения начинаются с {\tt if} и
имеют предикат, следствие и (необязательную) альтернативу.  Если в
выражении нет части-альтер\-на\-ти\-вы, мы указываем в ее качестве
{\tt false}\footnote{Значение выражения {\tt if} в случае,
когда предикат ложен, а альтернатива отсутствует, в Scheme не
определено; здесь мы решили сделать его ложным.  Мы будем поддерживать
переменные {\tt true} и {\tt false} в выполняемых
выражениях путем связывания их в глобальном окружении.  
См.~раздел~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.}.

\begin{Verbatim}[fontsize=\small]
(define (if? exp) (tagged-list? exp 'if))\index{ru}{if?||||pd|}

(define (if-predicate exp) (cadr exp))\index{ru}{if-predicate||||pd|}

(define (if-consequent exp) (caddr exp))\index{ru}{if-consequent||||pd|}

(define (if-alternative exp)\index{ru}{if-alternative||||pd|}
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
\end{Verbatim}
Мы предоставляем также конструктор для {\tt if}-выражений.  Его будет
использовать процедура {\tt cond->if} для преобразования
выражений {\tt cond} в выражения {\tt if}:

\begin{Verbatim}[fontsize=\small]
(define (make-if predicate consequent alternative)\index{ru}{make-if||||pd|}
  (list 'if predicate consequent alternative))
\end{Verbatim}

\item
{\tt Begin} упаковывает последовательность
выражений в одно выражение.  В синтаксические операции над
выражениями {\tt begin} мы включаем извлечение самой
последовательности из выражения {\tt begin}, а также селекторы,
которые возвращают первое выражение и остаток выражений в
последовательности\footnote{Эти селекторы для списка выражений, а также
соответствующие им селекторы для списка операндов, не предназначаются для
абстракции данных.  Они введены в качестве мнемонических имен для
основных списковых операций, чтобы легче было понимать вычислитель с
явным управлением из 
раздела~\ref{THE-EXPLICIT-CONTROL-EVALUATOR}.}.

\begin{Verbatim}[fontsize=\small]
(define (begin? exp) (tagged-list? exp 'begin))\index{ru}{begin?||||pd|}

(define (begin-actions exp) (cdr exp))\index{ru}{begin-actions||||pd|}

(define (last-exp? seq) (null? (cdr seq)))\index{ru}{list-exp?||||pd|}

(define (first-exp seq) (car seq))\index{ru}{first-exp||||pd|}

(define (rest-exps seq) (cdr seq))\index{ru}{rest-exps||||pd|}
\end{Verbatim}
Кроме того, мы даем конструктор {\tt sequence->exp} (для
использования в процедуре {\tt cond->if}), который преобразует
последовательность в единое выражение, используя, если надо,
{\tt begin}:

\begin{Verbatim}[fontsize=\small]
(define (sequence->exp seq)\index{ru}{sequence->exp||||pd|}
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))

(define (make-begin seq) (cons 'begin seq))\index{ru}{make-begin||||pd|}
\end{Verbatim}

\item
Вызов процедуры~--- это любое составное
выражение, не попадающее ни в один из перечисленных типов.  Его
{\tt car}~--- это оператор, а {\tt cdr}~--- список операндов:

\begin{Verbatim}[fontsize=\small]
(define (application? exp) (pair? exp))\index{ru}{application?||||pd|}

(define (operator exp) (car exp))\index{ru}{operator||||pd|}

(define (operands exp) (cdr exp))\index{ru}{operands||||pd|}

(define (no-operands? ops) (null? ops))\index{ru}{no-operands?||||pd|}

(define (first-operand ops) (car ops))\index{ru}{first-operand||||pd|}

(define (rest-operands ops) (cdr ops))\index{ru}{rest-operands||||pd|}
\end{Verbatim}
\end{plainlist}

\paragraph{Производные выражения}


\index{ru}{метациклический интерпретатор для Scheme|производные 
выражения||||}\index{ru}{метациклический интерпретатор для Scheme|особые 
формы как производные выражения||||}\index{ru}{особая форма|как 
производное выражение в  интерпретаторе||||}Некоторые особые формы языка 
можно определить через
выражения, включающие другие особые формы, вместо того, чтобы
задавать их напрямую. Как пример рассмотрим
{\tt cond}, который можно реализовать как гнездо выражений
{\tt if}.  Например, задачу вычисления выражения

\begin{Verbatim}[fontsize=\small]
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
\end{Verbatim}
можно свести к задаче вычисления следующего выражения, состоящего из
форм {\tt if} и {\tt begin}:

\begin{Verbatim}[fontsize=\small]
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero)
               0)
        (- x)))
\end{Verbatim}
Такая реализация обработки {\tt cond} упрощает интерпретатор,
поскольку она уменьшает количество особых форм, для которых требуется
явно описывать процесс вычисления.

Мы включаем в интерпретатор синтаксические процедуры,
которые определяют доступ к частям выражения {\tt cond}, а
также процедуру {\tt cond->if}, которая преобразует выражения
{\tt cond} в выражения {\tt if}. Анализ случаев
начинается с {\tt cond} и состоит из списка ветвей-вариантов вида
предикат-действие. Вариант считается умолчательным, если его предикатом
является символ {\tt else}\footnote{Значение выражения {\tt cond}, когда все
предикаты ложны, а вариант по умолчанию {\tt else}
отсутствует, в языке Scheme не определено; здесь мы решили сделать его
ложным.}.

\begin{Verbatim}[fontsize=\small]
(define (cond? exp) (tagged-list? exp 'cond))\index{ru}{cond?||||pd|}

(define (cond-clauses exp) (cdr exp))\index{ru}{cond-clauses||||pd|}

(define (cond-else-clause? clause)\index{ru}{cond-else-clause?||||pd|}
  (eq? (cond-predicate clause) 'else))

(define (cond-predicate clause) (car clause))\index{ru}{cond-predicate||||pd|}

(define (cond-actions clause) (cdr clause))\index{ru}{cond-actions||||pd|}

(define (cond->if exp)\index{ru}{cond->if||||pd|}
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)\index{ru}{expand-clauses||||pd|}
  (if (null? clauses)
      'false                          {\em ; нет ветви{\tt else}}
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "Ветвь ELSE не последняя -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
\end{Verbatim}

Выражения (вроде {\tt cond}), которые мы желаем
реализовать через синтаксические преобразования, называются 
\index{ru}{производные выражения в интерпретаторе||derived 
expressions|||}\index{en}{derived expressions||производные выражения в 
интерпретаторе|||}{\em производными} (derived expressions). Выражения
{\tt let} также являются производными 
(см.~упражнение~\ref{EX4.6})\footnote{Практические
Лисп-системы предоставляют механизм, который
дает пользователю возможность добавлять новые производные выражения и
определять их значения через синтаксические преобразования,
не внося изменений в вычислитель.  Такое преобразование, определяемое
пользователем, называется 
\index{ru}{макрос||macro|||п}\index{en}{macro||макрос|||п}{\em макрос} 
(macro).  Добавить простой механизм для определения макросов легко,
однако в получающемся языке возникают сложные проблемы конфликта
имен.  Множество исследований посвящено поиску механизмов
определения макросов, в которых такие проблемы не возникают. См.,
например,
Kohlbecker 1986, Clinger and Rees 1991
и Hanson 1991.\index{ru}{Кольбеккер, Юджин Эдмунд, мл.||Eugene Edmund 
Kohlbecker Jr.||n|п}\index{en}{Eugene Edmund Kohlbecker Jr.||Кольбеккер, 
Юджин Эдмунд, мл.||n|п}\index{ru}{Клингер, Уильям||William 
Clinger||n|п}\index{en}{William Clinger||Клингер, 
Уильям||n|п}\index{ru}{Рис, Джонатан~А.||Jonathan~A. 
Rees||n|п}\index{en}{Jonathan~A. Rees||Рис, 
Джонатан~А.||n|п}\index{ru}{Хансон, Кристофер~П.||Cristopher~P. 
Hanson||n|п}\index{en}{Cristopher~P. Hanson||Хансон, Кристофер~П.||n|п}}.

\begin{exercise}{4.2}%
\label{EX4.2}%
\index{ru}{метациклический интерпретатор для Scheme|комбинации (применение 
процедур)||||(упр.~4.2)}Хьюго Дум хочет переупорядочить ветви
{\tt eval} так, чтобы ветвь для вызова процедур располагалась
перед веткой для присваивания. Он утверждает, что при этом интерпретатор
станет эффективнее: поскольку в программах обычно больше вызовов
процедур, чем присваиваний, определений и~т.~д., его усовершенствованный
{\tt eval} обычно будет рассматривать меньше вариантов, чем
исходный, при распознавании типа выражения.
 
\begin{plainenum}
\item
Что за ошибка содержится в плане Хьюго? (Подсказка:
что сделает его интерпретатор с выражением {\tt (define x 3)}?)

\item
\index{ru}{метациклический интерпретатор для Scheme|синтаксис 
интерпретируемого языка||||(упр.~4.2)}Хьюго расстроен, что его план не 
сработал.  Он готов пойти на любые жертвы, чтобы позволить интерпретатору
распознавать вызовы процедур до того, как он проверяет все остальные
типы выражений.  Помогите ему, изменив синтаксис интерпретируемого
языка так, чтобы вызовы процедур начинались с символа
{\tt call}.  Например, вместо {\tt (factorial 3)} нам
теперь придется писать {\tt (call factorial 3)}, а вместо
{\tt (+ 1 2)}~--- {\tt (call + 1 2)}.
\end{plainenum}
\end{exercise}

\begin{exercise}{4.3}%
\label{EX4.3}%
Перепишите {\tt eval}
\index{ru}{программирование, управляемое данными|в метациклическом 
интерпретаторе||||(упр.~4.3)}\index{ru}{eval (метациклическая)|управляемая 
данными|||p|(упр.~4.3)}\index{ru}{метациклический интерпретатор для 
Scheme|\texttt{eval}, управляемая данными||||(упр.~4.3)}так, чтобы 
диспетчеризация происходила в стиле, управляемом данными.
Сравните результат с 
дифференцированием, управляемым данными, из 
упражнения~\ref{EX2.73}. (Можно использовать {\tt car}
составного выражения в качестве типа этого выражения, так как это
хорошо сочетается с синтаксисом, реализованным в этом разделе.)
\end{exercise}

\begin{exercise}{4.4}%
\label{EX4.4}%
Вспомним определения 
\index{ru}{метациклический интерпретатор для Scheme|особые 
формы||||(упр.~4.4)}особых форм {\tt and} и {\tt or} из
главы~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES}:

\begin{plainlist}
\item
{\tt and:} выражения вычисляются слева
\index{ru}{and (особая форма)|без подвыражений|||p|(упр.~4.4)}направо.  
Если значение какого-то из них оказывается ложным,
возвращается ложь; оставшиеся выражения не вычисляются.  Если все
выражения оказываются истинными, возвращается значение последнего из
них.  Если нет ни одного выражения, возвращается истина.

\item
{\tt or:} выражения вычисляются слева
\index{ru}{or (особая форма)|без подвыражений|||p|(упр.~4.4)}направо.  
Если значение какого-то из них оказывается истинным, возвращается это 
значение; оставшиеся выражения не вычисляются.  Если 
все выражения оказываются ложными, или нет ни одного выражения,
возвращается ложь.
\end{plainlist}
Введите {\tt and} и {\tt or} в качестве новых особых
форм интерпретатора, определив соответствующие синтаксические
процедуры и процедуры выполнения {\tt eval-and} и
{\tt eval-or}. В качестве альтернативы покажите, как можно
реализовать {\tt and} и {\tt or} в виде производных
выражений.
\end{exercise}

\begin{exercise}{4.5}\label{EX4.5}%
\sloppy
\index{ru}{cond (особая форма)|вариант синтаксиса ветвей|||pd|(упр.~4.5)}%
\index{ru}{ветвь {\tt cond}|дополнительный синтаксис||||(упр.~4.5)}%
\index{ru}{метациклический интерпретатор для Scheme|особые формы||||(упр.~4.5)}%
В языке Scheme есть дополнительная 
разновидность синтаксиса
вариантов {\tt cond}, {\tt (\textit{$\langle$про\-вер\-ка$\rangle$}~=>~\textit{$\langle$потребитель$\rangle$})}.  Если результат вычисления
\textit{$\langle$проверки$\rangle$} оказывается истинным значением, то
вычисляется \textit{$\langle$потребитель$\rangle$}.  Его значение должно быть
одноместной процедурой; эта процедура вызывается со значением
\textit{$\langle$проверки$\rangle$} в качестве аргумента, и результат этого
вызова возвращается как значение выражения
{\tt cond}. Например,
\sloppy

\begin{Verbatim}[fontsize=\small]
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
\end{Verbatim}
имеет значение 2.  Измените обработку {\tt cond} так, чтобы она
поддерживала этот расширенный синтаксис.
\end{exercise}

\begin{exercise}{4.6}%
\label{EX4.6}%
\index{ru}{метациклический интерпретатор для Scheme|особые формы||||(упр.~4.6)}%
Выражения {\tt let} производны, поскольку
\samepage

\begin{Verbatim}[fontsize=\small]
(let ((\textit{$\langle$пер${}_{\mbox{1}}$$\rangle$}\textit{$\langle$выр${}_{\mbox{1}}$$\rangle$}) ... (\textit{$\langle$пер${}_{\mbox{n}}$$\rangle$}\textit{$\langle$выр${}_{\mbox{n}}$$\rangle$}))
  \textit{$\langle$тело$\rangle$})
\end{Verbatim}
эквивалентно

\begin{Verbatim}[fontsize=\small]
((lambda (\textit{$\langle$пер${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$пер${}_{\mbox{n}}$$\rangle$})
   \textit{$\langle$тело$\rangle$})
 \textit{$\langle$выр${}_{\mbox{1}}$$\rangle$}
 ...
 \textit{$\langle$выр${}_{\mbox{n}}$$\rangle$})
\end{Verbatim}
Напишите синтаксическое преобразование {\tt let->combination},
которое сводит вычисление {\tt let}-выражений к вычислению
комбинаций указанного вида, и добавьте соответствующую ветку для
обработки {\tt let} к {\tt eval}.
\end{exercise}

\begin{exercise}{4.7}%
\label{EX4.7}%
\index{ru}{метациклический интерпретатор для Scheme|особые 
формы||||(упр.~4.7)}Особая форма {\tt let*}
\index{ru}{let* (особая форма)||||pd|(упр.~4.7)}\index{ru}{особые 
формы|\texttt{let*}||||(упр.~4.7)}подобна {\tt let}, но только связывания 
переменных в {\tt let*}
происходят последовательно, и каждое следующее связывание происходит в
окружении, где видны все предыдущие.  Например,

\begin{Verbatim}[fontsize=\small]
(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))
\end{Verbatim}
возвращает значение 39.  Объясните, каким образом
можно переписать выражение {\tt let*}
в виде набора вложенных выражений {\tt let}, и
напишите процедуру {\tt let*->nes\-ted-lets}, которая проделывает
это преобразование.  Если мы уже реализовали {\tt let}
(упражнение~\ref{EX4.6}) и хотим теперь расширить
интерпретатор так, чтобы он обрабатывал {\tt let*}, достаточно
ли будет добавить в {\tt eval} ветвь, в которой действием
записано

\begin{Verbatim}[fontsize=\small]
(eval (let*->nested-lets exp) env)
\end{Verbatim}
или нужно явным образом преобразовывать {\tt let*} в набор
непроизводных выражений?
\end{exercise}

\begin{exercise}{4.8}%
\label{EX4.8}%
\index{ru}{let (особая форма)|именованный|||pd|(упр.~4.8)}%
\index{ru}{именованный \texttt{let} (особая форма)||named {\tt let}||d|(упр.~4.8)}%
\index{en}{named {\tt let}||именованный \texttt{let} (особая форма)||d|(упр.~4.8)}%
\index{ru}{особые формы|именованный \texttt{let}||||(упр.~4.8)}%
<<Именованный {\tt let}>>~--- это вариант
\index{ru}{метациклический интерпретатор для Scheme|особые 
формы||||(упр.~4.8)}{\tt let}, который имеет вид

\begin{Verbatim}[fontsize=\small]
(let \textit{$\langle$переменная$\rangle$} \textit{$\langle$связывание$\rangle$} \textit{$\langle$тело$\rangle$})
\end{Verbatim}
\textit{$\langle$Связывание$\rangle$} и \textit{$\langle$тело$\rangle$} такие 
же, как и в
обычном {\tt let}, но только \textit{$\langle$переменная$\rangle$}
связана в \textit{$\langle$теле$\rangle$} с процедурой, у которой тело
\textit{$\langle$тело$\rangle$}, а имена параметров~--- переменные в
\textit{$\langle$связываниях$\rangle$}.  Таким образом, можно неоднократно
выполнять \textit{$\langle$тело$\rangle$}, вызывая процедуру по имени
\textit{$\langle$переменная$\rangle$}.  Например, итеративную процедуру для
порождения чисел Фибоначчи (раздел~\ref{TREE-RECURSION})
можно переписать при помощи именованного {\tt let} как

\begin{Verbatim}[fontsize=\small]
(define (fib n)\index{ru}{fib|с именованным \texttt{let}|||pd|(упр.~4.8)}
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
\end{Verbatim}
Измените преобразование {\tt let->combination} из 
упражнения~\ref{EX4.6} так, чтобы оно поддерживало именованный
{\tt let}.
\end{exercise}

\begin{exercise}{4.9}%
\label{EX4.9}%
\index{ru}{метациклический интерпретатор для Scheme|особые 
формы||||(упр.~4.9)}Во многих языках имеются
\index{ru}{циклические конструкции|реализация в метациклическом 
интерпретаторе||||(упр.~4.9)}различные конструкции для
построения циклов, например, {\tt do}, {\tt for},
{\tt while} и {\tt until}.  В Scheme итеративные
процессы можно выразить через обычные вызовы процедур, так что особые
конструкции не дают никакого существенного выигрыша в вычислительной
мощности.  С другой стороны, часто они удобны.  Придумайте
какие-нибудь конструкции для итерации, дайте примеры их
использования и покажите, как их реализовать в виде производных
выражений.
\end{exercise}

\begin{exercise}{4.10}%
\label{EX4.10}%
При помощи 
\index{ru}{метациклический интерпретатор для Scheme|абстракция 
данных||||(упр.~4.10)}абстракции данных мы смогли написать
процедуру {\tt eval} так, что она не зависит от конкретного
\index{ru}{метациклический интерпретатор для Scheme|синтаксис 
интерпретируемого языка||||(упр.~4.10)}синтаксиса интерпретируемого языка.  
Чтобы проиллюстрировать это свойство,
разработайте новый синтаксис для Scheme, изменив процедуры из
этого раздела и ничего не трогая в {\tt eval} и
{\tt apply}.
\end{exercise}

\subsection{Структуры данных интерпретатора}
\label{EVALUATOR-DATA-STRUCTURES}%

Помимо внешнего синтаксиса выражений, реализация
интерпретатора дол\-жна определить также внутренние структуры данных, с
которыми она работает во время выполнения программы, в частности,
представление процедур и окружений, а также истинных и ложных
значений.

\paragraph{Проверка предикатов}

\index{ru}{метациклический интерпретатор для Scheme|представление истины и 
лжи||||}В условных выражениях мы воспринимаем в качестве истины
все, кроме специального ложного объекта {\tt false}.

\begin{Verbatim}[fontsize=\small]
(define (true? x)\index{ru}{true?||||pd|}
  (not (eq? x false)))

(define (false? x)\index{ru}{false?||||pd|}
  (eq? x false))
\end{Verbatim}

\paragraph{Представление процедур}

\index{ru}{метациклический интерпретатор для Scheme|представление 
процедур||||}Работая с примитивами, мы предполагаем, что у нас есть
следующие процедуры:

\begin{plainlist}
\item
%\begin{Verbatim}[fontsize=\small]
{\small (apply-primitive-procedure \textit{$\langle$процедура$\rangle$} \textit{$\langle$аргументы$\rangle$})}
%\end{Verbatim}

\index{ru}{apply-primitive-procedure||||p|}применяет данную элементарную 
процедуру к значениям аргументов из
списка \textit{$\langle$аргументы$\rangle$} и возвращает результат вызова.

\item
%\begin{Verbatim}[fontsize=\small]
{\small (primitive-procedure? \textit{$\langle$процедура$\rangle$})  \index{ru}{primitive-procedure?||||p|}}
%\end{Verbatim}

проверяет, является ли \textit{$\langle$процедура$\rangle$} элементарной.
\end{plainlist}
Эти механизмы работы с элементарными процедурами подробнее описаны в
разделе~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.

Составная процедура строится из параметров, т\'ела процедуры
и окружения при помощи конструктора {\tt make-procedure}:

\begin{Verbatim}[fontsize=\small]
(define (make-procedure parameters body env)\index{ru}{make-procedure||||pd|}
  (list 'procedure parameters body env))

(define (compound-procedure? p)\index{ru}{compound-procedure?||||pd|}
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))\index{ru}{procedure-parameters||||pd|}

(define (procedure-body p) (caddr p))\index{ru}{procedure-body||||pd|}

(define (procedure-environment p) (cadddr p))\index{ru}{procedure-environment||||pd|}
\end{Verbatim}

\paragraph{Действия над окружениями}

\index{ru}{метациклический интерпретатор для Scheme|действия над 
окружениями||||}Интерпретатору нужно иметь несколько операций,
действующих над окружениями.  Как объясняется в 
разделе~\ref{THE-ENVIRONMENT-MODEL-OF-EVALUATION}, окружение
представляет собой последовательность кадров, а каждый кадр является
таблицей связываний, соотносящих переменные с их значениями.  Для
работы с окружениями мы используем следующие операции:

\begin{plainlist}
\sloppy
\item
{\tt (lookup-variable-value \textit{$\langle$переменная$\rangle$} \textit{$\langle$окружение$\rangle$})} \index{ru}{lookup-variable-value||||p|} 
возвращает зна\-че\-ние, связанное с 
символом \textit{$\langle$переменная$\rangle$}
в \textit{$\langle$окружении$\rangle$}, либо сообщает об ошибке, если переменная
не связана.

\item
{\tt (extend-environment \textit{$\langle$переменные$\rangle$} \textit{$\langle$значения$\rangle$} \textit{$\langle$исх-окр$\rangle$})} \index{ru}{extend-environment||||p|}
возвращает новое окружение, состоящее 
из нового кадра, в котором 
символы из списка \textit{$\langle$переменные$\rangle$} связаны с
соответствующими элементами списка \textit{$\langle$значения$\rangle$}, а
объемлющим окружением является окружение \textit{$\langle$исх-окр$\rangle$}.

\item
{\tt (define-variable! \textit{$\langle$переменная$\rangle$} \textit{$\langle$значение$\rangle$} \textit{$\langle$окружение$\rangle$})}%
\index{ru}{define-variable!||||p|} добавляет к первому кадру \textit{$\langle$окружения$\rangle$} новое
связывание, которое сопоставляет \textit{$\langle$пе\-ре\-мен\-ной$\rangle$}
\textit{$\langle$значение$\rangle$}.

\item
{\tt (set-variable-value! \textit{$\langle$переменная$\rangle$} \textit{$\langle$значение$\rangle$} \textit{$\langle$окружение$\rangle$})} \index{ru}{set-variable-value!||||p|} 
изменяет связывание \textit{$\langle$переменной$\rangle$} в
\textit{$\langle$окружении$\rangle$} так, что в дальнейшем ей будет соответствовать
\textit{$\langle$значение$\rangle$}, либо сообщает об ошибке, если переменная не
связана.
\end{plainlist}

\index{ru}{метациклический интерпретатор для Scheme|представление 
окружений||||}Чтобы реализовать все эти операции, мы представляем
окружение в виде списка кадров.  Объемлющее окружение живет в
{\tt cdr} этого списка. Пустое окружение~--- это просто пустой
список.

\begin{Verbatim}[fontsize=\small]
(define (enclosing-environment env) (cdr env))\index{ru}{enclosing-environment||||pd|}

(define (first-frame env) (car env))\index{ru}{first-frame||||pd|}

(define the-empty-environment '())\index{ru}{the-empty-environment||||pd|}
\end{Verbatim}
Каждый кадр в окружении представляется в виде пары списков: список
переменных, связанных в кадре, и список значений\footnote{В нижеследующем 
коде кадры не являются настоящей
абстракцией данных: {\tt set-variable-value!} и
{\tt define-variable!} явным образом изменяют значения в кадре
при помощи {\tt set-car!}.  Назначение процедур работы с кадрами ---
сделать код операций над окружениями простым для чтения.}.

\begin{Verbatim}[fontsize=\small]
(define (make-frame variables values)\index{ru}{make-frame||||pd|}
  (cons variables values))

(define (frame-variables frame) (car frame))\index{ru}{frame-variables||||pd|}
(define (frame-values frame) (cdr frame))\index{ru}{frame-values||||pd|}

(define (add-binding-to-frame! var val frame)\index{ru}{add-binding-to-frame!||||pd|}
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
\end{Verbatim}

Чтобы расширить окружение новым кадром, который связывает
переменные со значениями, мы порождаем кадр, который состоит из списка
переменных и списка значений, и присоединяем его к окружению.  Если
количество переменных и количество значений не совпадают, сообщаем
об ошибке.

\begin{Verbatim}[fontsize=\small]
(define (extend-environment vars vals base-env)\index{ru}{extend-environment||||pd|}
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Получено слишком много аргументов" vars vals)
          (error "Получено слишком мало аргументов" vars vals))))
\end{Verbatim}

Чтобы найти переменную в окружении, мы просматриваем
список переменных в первом кадре.  Если находим нужную переменную,
то возвращаем соответствующий элемент списка значений.  Если мы не
находим переменную в текущем кадре, то ищем в объемлющем окружении, и
так далее.  Если мы добираемся до пустого окружения, нужно сообщить об
ошибке <<неопределенная переменная>>.

\begin{Verbatim}[fontsize=\small]
(define (lookup-variable-value var env)\index{ru}{lookup-variable-value||||pd|}
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Несвязанная переменная" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{Verbatim}

Чтобы присвоить переменной новое значение в указанном
окружении, мы ищем переменную, точно так же, как в
{\tt lookup-variable-value}, и изменяем соответствующее
значение, когда его находим.

\begin{Verbatim}[fontsize=\small]
(define (set-variable-value! var val env) \index{ru}{set-variable-value!||||pd|}
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Несвязанная переменная -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{Verbatim}

Чтобы определить переменную, мы просматриваем первый
кадр в поисках связывания для нее, и изменяем связывание, если его
удается найти (так же, как в {\tt set-variable-value!}).  Если
связывания не существует, мы присоединяем его к первому кадру.

\begin{Verbatim}[fontsize=\small]
(define (define-variable! var val env)\index{ru}{define-variable!||||pd|}
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
\end{Verbatim}

Описанный здесь метод~--- только один из многих способов
представления окружений.  Поскольку мы при помощи 
\index{ru}{метациклический интерпретатор для Scheme|абстракция 
данных||||}абстракции данных 
отделили конкретную  реализацию от остальных частей интерпретатора,
при желании мы можем сменить представление окружений.
(См.~упражнение~\ref{EX4.11}.) В Лисп-системе промышленного
качества быстрота операций над окружениями~--- особенно обращения к
переменной~--- очень сильно влияет на общую производительность.
Представление, описанное здесь, при всей своей концептуальной простоте
неэффективно и, скорее всего, его не стали бы использовать в
рабочей системе\footnote{Недостаток этого представления (как и варианта
из упражнения~\ref{EX4.11}) состоит в том, что вычислителю
может понадобиться просматривать слишком много кадров, чтобы найти
связывание конкретной переменной. (Такой подход называется
\index{ru}{связывание|глубокое|binding|deep||п}\index{en}{binding|deep|связывание|глубокое||п}{\em 
глубокое связывание} (deep binding).)
Один из способов избежать такой потери производительности~---
использовать стратегию под названием 
\index{ru}{лексическая адресация||lexical 
addressing|||п}\index{en}{lexical addressing||лексическая 
адресация|||п}{\em лексическая адресация} (lexical addressing),
которая обсуждается в 
разделе~\ref{LEXICAL-ADDRESSING}.}.

\begin{exercise}{4.11}%
\label{EX4.11}%
Вместо того, чтобы представлять кадр в виде списка
списков, его можно представить как список связываний, где каждое
связывание является парой из имени и значения.  Перепишите операции с
окружениями в соответствии с этим альтернативным представлением.
\end{exercise}

\begin{exercise}{4.12}%
\label{EX4.12}%
Процедуры {\tt set-variable-value!},
{\tt define-variable!} и {\tt lookup-variable-va\-lue}
можно выразить посредством более абстрактных процедур для просмотра
структуры окружений.  Определите абстракции, которые фиксируют
общую схему поведения, и с их помощью перепишите эти три процедуры.
\end{exercise}

\begin{exercise}{4.13}%
\label{EX4.13}%
Scheme позволяет создавать новые связывания через
{\tt define}, но не дает никакого способа избавиться от
связывания.  Реализуйте в интерпретаторе особую форму
{\tt make-unbound!}, которая изымает связывание данного символа
из окружения, в котором {\tt make-unbound!} выполняется.
Задача определена не до конца.  Например, нужно ли удалять связывания
в других кадрах, кроме первого?  Дополните спецификацию и объясните
свой выбор вариантов.
\end{exercise}

\subsection{Выполнение интерпретатора как программы}
\label{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}%

\index{ru}{вычисление|модели||||}\index{ru}{метациклический интерпретатор 
для Scheme|запуск||||}Написав интерпретатор, мы получаем в руки описание
(выраженное на Лиспе) процесса вычисления лисповских выражений.
Одно из преимуществ наличия описания в виде программы в том,
что эту программу можно запустить.  У нас внутри Лиспа есть работающая
модель того, как сам Лисп вычисляет выражения.  Она может служить
средой для экспериментов с правилами вычисления, и дальше в этой главе
мы такими экспериментами и займемся.

Программа-вычислитель в конце концов сводит выражения
к применению \index{ru}{метациклический интерпретатор для 
Scheme|элементарные процедуры||||}элементарных процедур.  Следовательно, 
единственное, что
нам требуется для запуска интерпретатора,~--- создать механизм,
который обращается к нижележащей Лисп-системе и моделирует вызовы
элементарных процедур.

Нам нужно иметь связывание для каждого имени элементарной
процедуры, чтобы, когда {\tt eval} выполняет вызов примитива, у
него был объект, который можно передать в {\tt apply}.  Поэтому
мы выстраиваем 
\index{ru}{глобальное окружение|в метациклическом 
интерпретаторе||||}\index{ru}{метациклический интерпретатор для 
Scheme|глобальное окружение||||}глобальное окружение,
связывающее особые объекты с именами элементарных процедур, которые
могут появляться в вычисляемых 
нами выражениях.  Кроме того, глобальное окружение включает связывания
для символов 
\index{ru}{метациклический интерпретатор для Scheme| \texttt{true} и 
\texttt{false}||||}{\tt true} и {\tt false}, так что их можно
использовать как переменные в вычисляемых выражениях.

\begin{Verbatim}[fontsize=\small]
(define (setup-environment) \index{ru}{setup-environment||||pd|}
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))

(define the-global-environment (setup-environment))  \index{ru}{the-global-environment||||pd|}
\end{Verbatim}

Как именно мы представляем объекты-элементарные процедуры,
не имеет значения.  Требуется только, чтобы их можно было распознавать
и применять, вызывая процедуры
{\tt primitive-procedure?} и
{\tt apply-primitive-procedure}. Мы решили представлять
примитивы в виде списка, начинающегося с символа
{\tt primitive} и содержащего процедуру нижележащего Лиспа,
которая реализует данный примитив.

\begin{Verbatim}[fontsize=\small]
(define (primitive-procedure? proc)  \index{ru}{primitive-procedure?||||pd|}
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc)) \index{ru}{primitive-implementation||||pd|}
\end{Verbatim}

{\tt Setup-environment} получит имена и реализации
элементарных процедур из списка\footnote{Любую процедуру, 
определенную в нижележащем Лиспе, можно
использовать как примитив для метациклического интерпретатора.  Имя
примитива, установленного в интерпретаторе, не обязательно должно
совпадать с именем его реализации в нижележащем Лиспе; здесь имена
одни и те же потому, что метациклический интерпретатор реализует саму
Scheme.  Так, например, мы могли бы написать в списке
{\tt primitive-procedures} что-нибудь вроде {\tt (list 'first
car)} или {\tt (list 'square (lambda (x) (* x x)))}.}.

\begin{Verbatim}[fontsize=\small]

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        {\em другие примитивы}
        ))

(define (primitive-procedure-names)  \index{ru}{primitive-procedure-names||||pd|}
  (map car
       primitive-procedures)) 

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))  \index{ru}{primitive-procedure-objects||||pd|}
       primitive-procedures))
\end{Verbatim}

Чтобы вызвать элементарную процедуру, мы просто применяем
про\-це\-ду\-ру-реализацию к аргументам, используя нижележащую
Лисп-систему\footnote{\index{ru}{apply (метациклическая)|vs. элементарная 
\texttt{apply}|||p|п}{\tt Apply-in-underlying-scheme}~--- это
процедура {\tt apply}, которой мы пользовались в предыдущих
главах.  Процедура {\tt apply} метациклического интерпретатора
(раздел~\ref{THE-CORE-OF-THE-EVALUATOR}) имитирует работу
этого примитива.  Наличие двух процедур с одинаковым
именем ведет к технической проблеме при запуске интерпретатора,
поскольку определение {\tt apply} метациклического
интерпретатора загородит определение примитива.  Можно избежать этого,
переименовав метациклический {\tt apply}, и избавиться таким образом от
конфликта с именем элементарной процедуры.  Мы же вместо этого приняли решение
сохранить ссылку на исходный {\tt apply}, выполнив

\begin{Verbatim}
(define apply-in-underlying-scheme apply)
\end{Verbatim}
прежде, чем определили {\tt apply} в интерпретаторе. Теперь мы
можем обращаться к исходной версии {\tt apply} под другим
именем.}.

\begin{Verbatim}[fontsize=\small]
(define (apply-primitive-procedure proc args)\index{ru}{apply-primitive-procedure||||pd|}
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
\end{Verbatim}

\index{ru}{управляющий цикл|в метациклическом 
интерпретаторе||||}\index{ru}{метациклический интерпретатор для 
Scheme|управляющий цикл||||}Для удобства работы с
метациклическим интерпретатором мы организуем 
\index{ru}{управляющий цикл||driver loop|||}\index{en}{driver 
loop||управляющий цикл|||}{\em управляющий цикл} (driver loop),
который моделирует цикл чтения-выполнения-печати нижележащей
Лисп-системы.  Этот цикл печатает 
\index{ru}{подсказка||prompt|||}\index{en}{prompt||подсказка|||}{\em 
подсказку} (prompt), считывает входное выражение,
вычисляет это выражение в глобальном окружении и распечатывает
результат.  Перед каждым результатом мы помещаем 
\index{ru}{подсказка вывода||output prompt|||}\index{en}{output 
prompt||подсказка вывода|||}{\em подсказку вывода} (output prompt), чтобы 
отличить значение выражения от всего прочего, что может быть
напечатано\footnote{Элементарная процедура \index{ru}{элементарные 
процедуры|{\tt read}||||п} \index{ru}{read (элементарная  
процедура)||||pd|п}{\tt read} ожидает ввода от пользователя и возвращает 
ближайшее полное выражение, которое он
напечатает.  Например, если пользователь напечатает {\tt (+ 23
x)}, результатом {\tt read} будет трехэлементный список
из символа {\tt +}, числа 23 и символа {\tt x}.  Если
пользователь введет {\tt 'x}, результатом {\tt read}
будет двухэлементный список из символа {\tt quote} и символа
{\tt x}.\index{ru}{' (одинарная кавычка)|и \texttt{read}|||p|п} 
\index{ru}{quote (особая форма)|и \texttt{read}|||p|п}}.

\begin{Verbatim}[fontsize=\small]
(define input-prompt ";;; Ввод M-Eval:") \index{ru}{подсказка|метациклический интерпретатор||||}
(define output-prompt ";;; Значение M-Eval:")

(define (driver-loop)\index{ru}{driver-loop|для метациклического интерпретатора|||pd|}
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))

(define (prompt-for-input string)  \index{ru}{prompt-for-input||||pd|}
  (newline) (newline) (display string) (newline))

(define (announce-output string)\index{ru}{announce-output||||pd|}
  (newline) (display string) (newline))
\end{Verbatim}
Мы пользуемся специальной процедурой вывода {\tt user-print},
чтобы не печатать окружение составных процедур, которое может быть
очень длинным списком, и даже может содержать циклы.

\begin{Verbatim}[fontsize=\small]
(define (user-print object) \index{ru}{user-print||||pd|}
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
\end{Verbatim}

Теперь для запуска интерпретатора нам остается только
проинициализировать глобальное окружение и войти в управляющий цикл.
Вот пример работы интерпретатора:

\begin{Verbatim}[fontsize=\small]
(define the-global-environment (setup-environment))

(driver-loop)

\textit{;;; Ввод M-Eval:}
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))

\textit{;;; Значение M-Eval:}
\textit{ok}

\textit{;;; Ввод M-Eval:}
(append '(a b c) '(d e f))
\textit{;;; Значение M-Eval:}
\textit{(a b c d e f)}
\end{Verbatim}

\begin{exercise}{4.14}%
\label{EX4.14}%
Ева Лу Атор и Хьюго Дум экспериментируют с
метациклическим интерпретатором каждый по отдельности.  Ева вводит
определение {\tt map} и запускает несколько тестовых программ с
его использованием.  Они замечательно работают.  Хьюго, со своей
стороны, ввел системную версию {\tt map} как примитив
метациклического интерпретатора.  Когда он пытается его выполнить, все
ломается самым ужасным образом.  Объясните, почему у Хьюго
{\tt map} не работает, а у Евы работает.
\end{exercise}

\subsection{Данные как программы}
\label{DATA-AS-PROGRAMS}%

\index{ru}{данные|как программы||||}\index{ru}{программа|как 
данные||||}При рассмотрении программы на Лиспе, вычисляющей
лисповские выражения, может быть полезна аналогия.  Одна из возможных
точек зрения на значение программы состоит в том, что программа описывает
\index{ru}{программа|как абстрактная машина||||}абстрактную (возможно, 
бесконечно большую) машину.  Рассмотрим,
например, знакомую нам программу для вычисления 
факториалов:\index{ru}{factorial|как абстрактная машина|||p|}

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{Verbatim}
Можно считать эту программу описанием машины, которая
содержит узлы для вычитания, умножения и проверки на равенство,
двухпозиционный переключатель и еще одну факториал-машину.
(Факториал-машина получается бесконечной, поскольку она содержит
другую факториал-машину внутри себя.)  На 
рисунке~\ref{P4.2} изображена потоковая диаграмма факториал-машины,
которая показывает, как спаяны ее части.


\begin{cntrfig}
\input{xfig-mod/4-2.eepic}
\caption{Программа вычисления факториала,
изображенная в виде абстрактной машины.}
\label{P4.2}%
\end{cntrfig}


\begin{cntrfig}
\input{xfig-mod/4-3.eepic}
\caption{Вычислитель, моделирующий факториальную
машину.}
\label{P4.3}%

\end{cntrfig}

Подобным образом, мы можем рассматривать вычислитель как
\index{r4}{вычислитель|как абстрактная машина||||}особого рода машину, 
которой подается в виде сырья описание другой машины.
Обработав свои входные данные, вычислитель перестраивает себя так,
чтобы моделировать описываемую машину.  Например, если мы скормим
вычислителю определение {\tt factorial}, как показано на
рисунке~\ref{P4.3}, он сможет считать
факториалы.

С этой точки зрения, наш вычислитель-интерпретатор выглядит
как 
\index{ru}{вычислитель|как универсальная 
машина||||}\index{ru}{универсальная машина||universal 
machine|||}\index{en}{universal machine||универсальная машина|||}{\em 
универсальная машина} (universal machine).
Она имитирует другие машины, представленные в виде
Лисп-программ\footnote{То, что машины описаны на языке Лисп,
несущественно. Если дать нашему интерпретатору программу на Лиспе,
которая ведет себя как вычислитель для какого-нибудь другого языка,
скажем, Си, то вычислитель для Лиспа будет имитировать вычислитель для Си,
который, в свою очередь, способен сымитировать любую машину, описанную
в виде программы на Си.  Подобным образом, написание интерпретатора
Лиспа на Си порождает программу на Си, способную выполнить любую
программу на Лиспе.  Главная идея здесь состоит в том, что любой
вычислитель способен имитировать любой другой.  Таким образом,
понятие <<того, что в принципе можно вычислить>> (если не принимать во
внимание практические вопросы времени и памяти, потребной для
вычисления), независимо от языка компьютера и выражает глубинное
понятие  
\index{ru}{вычислимость||computability|||п}\index{en}{computability||вычислимость|||п}{\em 
вычислимости} (computability).  Это впервые
было ясно показано Аланом М.~Тьюрингом (1912-1954),\index{ru}{Тьюринг, 
Алан~М.||Alan~M. Turing||n|п}\index{en}{Alan~M. Turing||Тьюринг, Алан~М.||n|п}
чья статья 1936
года заложила основы теоретической 
\index{ru}{информатика|||||п}информатики. В этой статье Тьюринг
представил простую модель вычислений,~--- теперь известную как 
\index{ru}{машина Тьюринга||Turing machine|||п}\index{en}{Turing 
machine||машина Тьюринга|||п}{\em машина Тьюринга} (Turing machine),~--- и 
утверждал, 
что любой <<эффективный процесс>> выразим в виде программы для такой
машины. (Этот аргумент известен как 
\index{ru}{Ч\"ерча-Тьюринга тезис||Church-Turing 
thesis|||п}\index{en}{Church-Turing thesis||Ч\"ерча-Тьюринга 
тезис|||п}{\em тезис Чёрча-Тьюринга} (Church-Turing thesis).)
Затем Тьюринг реализовал универсальную машину, т.~е. машину Тьюринга,
которая работает как вычислитель для программ машин Тьюринга.  При
помощи этой схемы рассуждений он показал, что существуют коррекно
поставленные задачи, которые не могут быть решены машиной Тьюринга
(см.~упражнение~\ref{EX4.15}), а следовательно не могут
быть сформулированы в виде <<эффективного процесса>>.  Позднее Тьюринг
внес фундаментальный вклад и в развитие практической информатики.
Например, ему принадлежит идея 
\index{ru}{программа|структурирование  с помощью 
подпрограмм||||п}структурирования программ с помощью 
подпрограмм общего назначения.  Биографию Тьюринга можно найти в 
Hodges 1983.\index{ru}{Ходжес, Эндрю||Andrew Hodges||n|п}\index{en}{Andrew 
Hodges||Ходжес, Эндрю||n|п}}.
Это замечательное устройство.  Попробуйте представить себе аналогичный
вычислитель для электрических схем.  Это была бы схема, которой на
вход поступает сигнал, кодирующий устройство какой-то другой
схемы, например, фильтра.  Восприняв этот вход, наша схема-вычислитель
стала бы работать как фильтр, соответствующий описанию.  Такая
универсальная электрическая схема имеет почти невообразимую
сложность.  Удивительно, что интерпретатор программ~--- сам по себе
программа довольно простая\footnote{Некоторые считают странным, что 
вычислитель,
реализованный с помощью относительно простой процедуры, способен
имитировать программы, более сложные, чем он сам.  Существование
универсальной машины-вычислителя~--- глубокое и важное свойство
вычисления. 
\index{ru}{рекурсии теория||recursion theory|||п}\index{en}{recursion 
theory||рекурсии теория|||п}{\em Теория рекурсии} (recursion theory),
отрасль математической логики, занимается логическими пределами
вычислимости.  В прекрасной книге Дугласа Хофштадтера <<Гёдель,
Эшер, Бах>> (Hofstadter 1979) исследуются\index{ru}{Хофштадтер, 
Дуглас~Р.||Douglas~R. Hofstadter||n|п}\index{en}{Douglas~R. 
Hofstadter||Хофштадтер, Дуглас~Р.||n|п} некоторые из этих идей.}.

Еще одна замечательная черта интерпретатора заключается в
том, что он служит мостом между объектами данных, которыми
манипулирует язык программирования, и самим языком.  Представим себе,
что работает программа интерпретатора (реализованная на Лиспе), и что
пользователь вводит выражения в интерпретатор и рассматривает
результаты.  С точки зрения пользователя, входное выражение вроде
{\tt (* x x)} является выражением языка программирования,
которое интерпретатор должен выполнить. Однако с точки зрения
интерпретатора это всего лишь список (в данном случае, список из трех
символов: {\tt *}, {\tt x} и {\tt x}), с которым
нужно работать по ясно очерченным правилам.

Нас не должно смущать, что программы пользователя являются
данными для интерпретатора.  На самом деле, иногда бывает удобно
игнорировать это различие и, предоставляя пользовательским программам
доступ к {\tt eval}, давать пользователю возможность явным
образом вычислить объект данных как выражение Лиспа.  Во многих диалектах
Лиспа имеется элементарная процедура {\tt eval},\index{ru}{eval 
(элементарная процедура)||||pd|}
которая в виде
аргументов берет выражение и окружение, и вычисляет выражение в
указанном окружении\footnote{Предупреждение: эта процедура {\tt eval}~--- не то
же самое, что процедура {\tt eval},\index{ru}{eval (метациклическая)|vs. 
элементарная \texttt{eval}|||p|п}
реализованная нами в
разделе~\ref{THE-CORE-OF-THE-EVALUATOR}, потому что она
работает с {\em настоящими} окружениями, а не с искусственными
структурами окружений, которые мы построили в 
разделе~\ref{EVALUATOR-DATA-STRUCTURES}. С этими
настоящими окружениями пользователь не может работать, как с обычными
списками; к ним нужно обращаться через {\tt eval} или
другие специальные операции.  Подобным образом, элементарная процедура
{\tt apply}, упомянутая раньше, не то же самое, что
метациклическая {\tt apply}, поскольку она использует настоящие
процедуры Scheme, а не объекты-процедуры, которые мы конструировали в
разделах~\ref{EVALUATOR-DATA-STRUCTURES} и
\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.}.
Таким образом, как

\begin{Verbatim}[fontsize=\small]
(eval '(* 5 5) user-initial-environment)
\end{Verbatim}
так и

\begin{Verbatim}[fontsize=\small]
(eval (cons '* (list 5 5)) user-initial-environment)
\end{Verbatim}
возвращают результат 25\footnote{\index{ru}{MIT 
Scheme|\texttt{eval}||||п}Реализация MIT Scheme имеет процедуру
{\tt eval},\index{ru}{eval (элементарная процедура)|MIT 
Scheme|||pd|п}\index{ru}{элементарные процедуры|{\tt eval} {\em (нс)}||||п}
а также символ 
\index{ru}{MIT 
Scheme|\texttt{user-initial-environment}||||п}\index{ru}{user-initial-environment||||pd|п}{\tt 
user-initial-environment}, связанный с исходным
окружением, в котором вычисляются выражения.}.

\begin{exercise}{4.15}%
\label{EX4.15}%
Если даны одноаргументная процедура {\tt p} и
объект {\tt a}, то говорят, что {\tt p}
\index{ru}{остановки проблема||halting 
problem|||(упр.~4.15)}\index{en}{halting problem||остановки 
проблема|||(упр.~4.15)}<<останавливается>> на {\tt a}, если выражение {\tt (p
a)} возвращает значение (а не печатает сообщение об ошибке или
выполняется вечно).  Покажите, что невозможно написать процедуру
{\tt halts?}, которая бы точно определяла для любой процедуры
{\tt p} и любого объекта {\tt a}, останавливается ли
{\tt p} на {\tt a}.  Используйте следующее рассуждение:
если бы имелась такая процедура {\tt halts?}, можно было бы
написать следующую программу:

\begin{Verbatim}[fontsize=\small]
(define (run-forever) (run-forever))

(define (try p)
  (if (halts? p p)
      (run-forever)
      'halted))
\end{Verbatim}
Теперь рассмотрите выражение {\tt (try try)} и покажите, что
любое возможное завершение (остановка или вечное выполнение) нарушает
требуемое поведение {\tt halts?}\footnote{Хотя здесь мы предположили, что
{\tt halts?} получает процедурный объект, заметим, что
рассуждение остается в силе даже в том случае, когда на вход подается текст
процедуры и ее окружение.  В этом и состоит знаменитая \index{ru}{теорема 
об остановке||Halting Theorem|||п}\index{en}{Halting Theorem||теорема об 
остановке|||п}{\em теорема об остановке} (Halting Theorem) 
Тьюринга,\index{ru}{Тьюринг, Алан~М.||Alan~M. 
Turing||n|п}\index{en}{Alan~M. Turing||Тьюринг, Алан~М.||n|п} в которой 
был дан первый пример 
\index{ru}{вычислимость|||||п}\index{ru}{невычислимость||noncomputability|||п}\index{en}{noncomputability||невычислимость|||п}{\em 
невычислимой} (non-computable) задачи, т.~е. корректно
поставленного задания, которое невозможно выполнить с помощью
вычислительной процедуры.}.
\end{exercise}

\subsection{Внутренние определения}
\label{INTERNAL-DEFINITIONS-CH4}%

Наша модель вычислений с окружениями и метациклический
интерпретатор выполняют определения по очереди, расширяя кадр
окружения на одно определение за раз.  Это особенно удобно для
диалоговой разработки программы, когда программисту нужно свободно
смешивать вызовы процедур с определениями новых процедур.  Однако
если мы внимательно поразмыслим над 
\index{ru}{внутренние определения|сфера действия 
имени||||}\index{ru}{область действия переменной|внутренняя 
\texttt{define}||||}внутренними определениями, с помощью которых реализуется
\index{ru}{блочная структура|||||}блочная структура (введенная в
разделе~\ref{PROCEDURES-AS-BLACK-BOX-ABSTRACTIONS}), 
то мы увидим, что
пошаговое расширение окружения~--- одно имя за другим~--- может оказаться не
лучшим способом определения локальных переменных.

Рассмотрим процедуру с внутренними определениями, например

\begin{Verbatim}[fontsize=\small]
(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
   \textit{$\langle$остаток тела {\tt f}$\rangle$})
\end{Verbatim}
Здесь нам хочется, чтобы имя {\tt odd?} в теле процедуры
{\tt even?} ссылалось на процедуру {\tt odd?}, которая
определена позже, чем {\tt even?}.  Область действия имени
{\tt odd?}~--- это все тело {\tt f}, а не только та его
часть, которая лежит за точкой внутри {\tt f}, где
определяется {\tt odd?}.  В самом деле, ели заметить, что
сама {\tt odd?} определена с помощью {\tt even?}~--- так что
{\tt even?} и {\tt odd?} являются взаимно рекурсивными
процедурами,~--- то становится ясно, что единственная удовлетворительная
интерпретация двух {\tt define}~--- рассматривать их
так, как будто {\tt even?} и {\tt odd?} были добавлены
в окружение одновременно.  В общем случае, сферой действия локального
имени является целиком тело процедуры, в котором вычисляется
{\tt define}.

В нынешнем виде интерпретатор будет вычислять
вызовы {\tt f} правильно, но причина этого <<чисто случайная>>:
поскольку определения внутренних процедур расположены в
начале, никакие их вызовы не вычисляются, пока они все не
определены.  Следовательно, к тому времени, когда выполняется
{\tt even?}, {\tt odd?} уже определена.  Фактически,
последовательный механизм вычисления дает те же результаты, что и
механизм, непосредственно реализующий одновременное определение,
для всякой процедуры, где внутренние определения стоят в начале тела,
а вычисление выражений для определяемых переменных не использует ни
одну из этих переменных.  (Пример процедуры, которая не удовлетворяет этим
требованиям, так что последовательное определение не равносильно
одновременному, можно найти в 
упражнении~\ref{EX4.19}.)\footnote{Нежелание зависеть в программах от
этого механизма вычисления побудило нас написать <<администрация 
ответственности не
несет>> в примечании  \ref{F1.28} в 
главе~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES}.\index{ru}{внутренние 
определения|ограничения||||п}
Настаивая на
том, чтобы внутренние определения стояли в начале тела и не использовали
друг друга во время вычисления самих определений, стандарт IEEE Scheme
дает авторам реализаций некоторую свободу при выборе механизма
вычисления этих определений.  Выбор того или иного правила вычисления
может показаться мелочью, которая влияет только на интерпретацию
<<плохих>> программ.  Однако в 
разделе~\ref{LEXICAL-ADDRESSING} мы увидим, что через
переход к модели с
одновременным определением внутренних переменных можно избежать
некоторых досадных трудностей, которые бы в противном случае
возникли при написании компилятора.}

Однако имеется простой способ обрабатывать определения
так, чтобы у локально определенных имен оказалась действительно общая
сфера действия,~--- достаточно лишь создать все будущие внутренние
переменные текущего окружения, прежде чем начнется
вычисление какого-либо из выражений, возвращающих значение.  Можно это
сделать, например, путем синтаксического преобразования
{\tt lambda}-выражений.  Прежде чем выполнять тело выражения
{\tt lambda}, мы 
\index{ru}{внутренние определения|прочесывание и 
уничтожение||||}\index{ru}{прочесывание внутренних определений||scanning 
out internal definitions|||}\index{en}{scanning out internal 
definitions||прочесывание внутренних определений|||}<<прочесываем>> его и 
уничтожаем все
внутренние определения.  Локально определенные переменные будут
созданы через {\tt let}, а затем получат значения посредством
присваивания.  Например, процедура

\begin{Verbatim}[fontsize=\small]
(lambda \textit{$\langle$переменные$\rangle$}
  (define u \textit{$\langle$e1$\rangle$})
  (define v \textit{$\langle$e2$\rangle$})
  \textit{$\langle$e3$\rangle$})
\end{Verbatim}
преобразуется в

\begin{Verbatim}[fontsize=\small]
(lambda \textit{$\langle$переменные$\rangle$}
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u \textit{$\langle$e1$\rangle$})
    (set! v \textit{$\langle$e2$\rangle$})
    \textit{$\langle$e3$\rangle$}))
\end{Verbatim}
где {\tt *unassigned*}~--- специальный символ, который при
поиске переменной вызывает сообщение об ошибке, если программа
пытается использовать значение переменной, которой ничего еще не
присвоено.

Альтернативная стратегия поиска внутренних определений
показана в уп\-раж\-не\-нии~\ref{EX4.18}.  В отличие от
преобразования, продемонстрированного только что, она навязывает программисту
следующее ограничение: значение каждой определяемой переменной должно 
вычисляться
без обращения к значениям других определяемых
переменных\footnote{Стандарт IEEE Scheme допускает различные стратегии
реализации. В нем говорится, что программист обязан подчиняться этому
ограничению, но реализация может его не проверять.  Некоторые
реализации Scheme, включая 
\index{ru}{MIT Scheme|внутренние определения||||п}MIT Scheme, используют 
преобразование, показанное выше.  В таких
реализациях будут работать некоторые 
из программ, которые это ограничение нарушают.}.

\begin{exercise}{4.16}\label{EX4.16}%
В этом упражнении мы реализуем только что описанный метод
обработки внутренних определений.  Мы предполагаем, что интерпретатор
поддерживает {\tt let} (см.~уп\-ра\-ж\-нение~\ref{EX4.6}).

\begin{plainenum}
\item

Измените процедуру
{\tt lookup-variable-value} 
\index{ru}{lookup-variable-value|при исключенных внутренних 
определениях|||p|(упр.~4.16)}(раздел~\ref{EVALUATOR-DATA-STRUCTURES}) так, 
чтобы она, обнаруживая
в качестве значения символ {\tt *unassigned*}, сообщала
об ошибке.

\item
Напишите процедуру  \index{ru}{scan-out-defines||||p|(упр.~4.16)}{\tt 
scan-out-defines},
которая берет тело процедуры и возвращает его эквивалент без
внутренних определений, выполняя описанное нами преобразование.

\item
Вставьте {\tt scan-out-defines} в
интерпретатор, либо в {\tt make-procedure}, либо в
{\tt pro\-ce\-dure-body}.  Какое из этих мест лучше? Почему?
\sloppy
\end{plainenum}
\end{exercise}

\begin{exercise}{4.17}%
\label{EX4.17}%
Нарисуйте диаграммы окружения, которое находится в силе в момент выполнения
выражения \textit{$\langle$e3$\rangle$} из процедуры выше по тексту, и
сравните его устройство при последовательной обработке определений и
при описанном выше преобразовании.
Откуда в преобразованной программе берется дополнительный кадр?
Объясните, почему это различие никогда не отражается на поведении
корректных программ.  Придумайте, как заставить интерпретатор
реализовать правило <<одновременной>> сферы действия для внутренних
определений без создания дополнительного кадра.
\end{exercise}

\begin{exercise}{4.18}%
\label{EX4.18}%
Рассмотрим альтернативную стратегию обработки
определений, которая переводит пример из текста в

\begin{Verbatim}[fontsize=\small]
(lambda \textit{$\langle$переменные$\rangle$}
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a \textit{$\langle$e1$\rangle$})
          (b \textit{$\langle$e2$\rangle$}))
      (set! u a)
      (set! v b))
    \textit{$\langle$e3$\rangle$}))
\end{Verbatim}
Здесь {\tt a} и {\tt b} представляют новые имена
переменных, созданные интерпретатором, которые не встречаются в
пользовательской программе.  Рассмотрим процедуру {\tt solve}
из раздела~\ref{STREAMS-AND-DELAYED-EVALUATION}:

\begin{Verbatim}[fontsize=\small]
(define (solve f y0 dt) \index{ru}{solve|с прочесанными внутренними определениями|||pd|(упр.~4.18)}
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{Verbatim}
Будет ли эта процедура работать, если внутренние определения
преобразуются так, как предлагается в этом упражнении?  А если так,
как в тексте раздела?  Объясните.
\end{exercise}

\begin{exercise}{4.19}%
\label{EX4.19}%
Бен Битобор, Лиза П.~Хакер и Ева Лу Атор спорят о том,
каким должен быть результат выражения

\begin{Verbatim}[fontsize=\small]
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
\end{Verbatim}
Бен говорит, что следует действовать согласно последовательному
правилу для {\tt define}: {\tt b} равно 11, затем
{\tt a} определяется как 5, так что общий результат равен 16.
Лиза возражает, что взаимная рекурсия требует правила одновременной
сферы действия для внутренних определений и нет причин
рассматривать имена процедур отдельно от прочих имен.  То есть
она выступает за механизм, реализованный в 
упражнении~\ref{EX4.16}.  При этом {\tt a} оказывается не
определено в момент, когда вычисляется {\tt b}.  Следовательно,
по мнению Лизы, процедура должна выдавать ошибку.  Ева не согласна с
обоими.  Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение {\tt a} должно использоваться
при вычислении {\tt b}.  Следовательно, по мнению Евы,
{\tt a} должно равняться 5, {\tt b} должно быть 15, а
общий результат 20.  Какую из этих точек зрения Вы поддерживаете (если у
Вас нет своей четвертой)?  Можете ли Вы придумать способ реализации
внутренних определений, который бы работал так, как предлагает
Ева\footnote{Авторы MIT Scheme согласны с Лизой, и вот почему: в
принципе права Ева~--- определения следует рассматривать как
одновременные.  Однако придумать универсальный эффективный механизм, который
вел бы себя так, как она требует, кажется трудным.  Если же такого
механизма нет, то лучше порождать ошибку в сложных случаях параллельных
определений (мнение Лизы), чем выдавать неверный ответ (как хочет
Бен).}?
\end{exercise}

\begin{exercise}{4.20}%
\label{EX4.20}%
Поскольку внутренние определения выглядят
последовательными, а на самом деле параллельны, некоторые предпочитают
их вовсе избегать и вместо этого пользуются особой формой
{\tt letrec}. {\tt Letrec}\index{ru}{letrec (особая 
форма)||||pd|(упр.~4.20)}\index{ru}{особые 
формы|\texttt{letrec}||||(упр.~4.20)} выглядит так же, как
{\tt let}, поэтому неудивительно, что переменные в нем
связываются одновременно и имеют одинаковую для всех сферу действия.
Можно переписать процедуру-пример {\tt f} из текста без
внутренних определений, но при этом в точности с тем же значением, так:

\begin{Verbatim}[fontsize=\small]
(define (f x)
  (letrec ((even?
            (lambda (n)
              (if (= n 0)
                  true
                  (odd? (- n 1)))))
           (odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (even? (- n 1))))))
    \textit{$\langle$остаток тела {\tt f}$\rangle$}))
\end{Verbatim}
Выражение {\tt letrec} имеет вид

\begin{Verbatim}[fontsize=\small]
(letrec ((\textit{$\langle$пер${}_{\mbox{1}}$$\rangle$} \textit{$\langle$выр${}_{\mbox{1}}$$\rangle$}) ... (\textit{$\langle$пер${}_{\mbox{n}}$$\rangle$} \textit{$\langle$выр${}_{\mbox{n}}$$\rangle$}))
  \textit{$\langle$тело$\rangle$})
\end{Verbatim}
и является вариантом {\tt let}, в котором выражения
\textit{$\langle$выр${}_{\mbox{k}}$$\rangle$}, устанавливающие
начальные значения для переменных
\textit{$\langle$пер${}_{\mbox{k}}$$\rangle$}, вычисляются в окружении,
которое включает все связывания {\tt letrec}. Это делает возможным
рекурсию между связываниями, к примеру, взаимную рекурсию
{\tt even?} и {\tt odd?} в последнем примере, или
вычисление \index{ru}{факториал|с 
\texttt{letrec}||||(упр.~4.20)}факториала 10 через

\begin{Verbatim}[fontsize=\small]
(letrec ((fact
          (lambda (n)
            (if (= n 1)
                1
                (* n (fact (- n 1)))))))
  (fact 10))
\end{Verbatim}

\begin{plainenum}


\item
Реализуйте {\tt letrec} как производное
выражение, переводя выражение {\tt letrec} в выражение
{\tt let}, как показано в тексте раздела или в 
упражнении~\ref{EX4.18}.  То есть переменные {\tt letrec}
должны создаваться в {\tt let}, а затем получать значение через
{\tt set!}.

\item
Хьюго Дум совсем запутался во всех этих
внутренних определениях.  Ему кажется, что если кому-то не нравятся
{\tt define} внутри процедуры, то пусть пользуются обычным
{\tt let}.  Покажите, чт\'о в его рассуждениях неверно. Нарисуйте
диаграмму, показывающую окружение, в котором выполняется
\textit{$\langle$остаток тела {\tt f}$\rangle$} во время вычисления
выражения {\tt (f 5)}, если {\tt f} определена как в
этом упражнении.  Нарисуйте диаграмму окружений для того же
вычисления, но только с {\tt let} на месте {\tt letrec}
в определении {\tt f}.
\end{plainenum}
\end{exercise}

\begin{exercise}{4.21}%
\label{EX4.21}%
Как ни удивительно, интуитивная догадка Хьюго (в
упражнении~\ref{EX4.20}) оказывается верной.
\index{ru}{рекурсивная процедура|построение без 
\texttt{define}||||(упр.~4.21)}Действительно, можно
строить рекурсивные процедуры без использования {\tt letrec} (и
даже без {\tt define}), только способ это сделать намного
тоньше, чем казалось Хьюго.
\index{ru}{факториал|без \texttt{letrec} и 
\texttt{define}||||(упр.~4.21)}Следующее выражение вычисляет факториал 10 с
помощью рекурсивной процедуры\footnote{В этом примере показан 
программистский трюк,
позволяющий формулировать рекурсивные процедуры без помощи
{\tt define}.  Самый общий прием такого рода называется 
\index{ru}{Y-оператор||Y operator|||п}\index{en}{Y 
operator||Y-оператор|||п}{\em Y-оператор} (Y operator), и с его помощью 
можно реализовать
рекурсию в <<чистом $\lambda$-исчислении>>. (Подробности о лямбда-исчислении
можно найти в Stoy 1977,
\index{ru}{Стой, Джозеф~Э.||Joseph~E. Stoy||n|п}\index{en}{Joseph~E. 
Stoy||Стой, Джозеф~Э.||n|п}а демонстрацию $Y$-оператора
на Scheme в Gabriel 1988.)\index{ru}{Гэбриел, Ричард~П.||Richard~P. 
Gabriel||n|п}\index{en}{Richard~P. Gabriel||Гэбриел, Ричард~П.||n|п}}:

\begin{Verbatim}[fontsize=\small]
((lambda (n)
   ((lambda (fact)
      (fact fact n))
    (lambda (ft k)
      (if (= k 1)
          1
          (* k (ft ft (- k 1)))))))
 10)
\end{Verbatim}

\begin{plainenum}


\item
Проверьте, что это выражение на самом деле считает факториалы
(вычисляя его).  Постройте аналогичное выражение для
вычисления чисел Фибоначчи.

\item
Рассмотрим следующую процедуру, включающую
взаимно рекурсивные внутренние определения:

\begin{Verbatim}[fontsize=\small]
(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
  (even? x))
\end{Verbatim}
Восстановите пропущенные фрагменты так, чтобы получилось альтернативное
определение {\tt f}, где нет ни внутренних определений,
ни {\tt letrec}:

\begin{Verbatim}[fontsize=\small]
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$})))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$} \textit{$\langle$??$\rangle$})))))
\end{Verbatim}
\end{plainenum}
\end{exercise}

\subsection{Отделение синтаксического анализа от выполнения}
\label{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}%


\index{ru}{метациклический интерпретатор для 
Scheme|эффективность||||}\index{ru}{анализирующий интерпретатор||analyzing     
evaluator|||}\index{en}{analyzing     evaluator||анализирующий 
интерпретатор|||}\index{ru}{эффективность|вычисления||||}\index{ru}{метациклический 
интерпретатор для Scheme|анализирующая 
версия||||}\index{ru}{синтаксический анализ, отделение от выполнения|в 
метациклическом интерпретаторе||||}Написанный нами интерпретатор прост, но 
очень неэффективен,
потому что синтаксический анализ выражений перемешан в нем с их
выполнением.  Таким образом, сколько раз выполняется программа,
столько же раз анализируется ее синтаксис.  Рассмотрим, например,
вычисление {\tt (factorial 4)}, если дано следующее определение
факториала:

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{Verbatim}

Каждый раз, когда вызывается {\tt factorial},
интерпретатор должен определить, что тело процедуры является условным
выражением, и извлечь его предикат.  Только после этого он может
вычислить предикат и поступить в соответствии с его значением.
Каждый раз, когда вычисляется выражение {\tt (* (factorial (- n 1))
n)} или подвыражения {\tt (factorial (- n 1))} и {\tt (-
n 1)}, интерпретатор должен произвести анализ случаев внутри
{\tt eval}, выяснить, что выражение является вызовом процедуры,
а также извлечь его оператор и операнды.  Такой анализ недёшев.
Проделывать его многократно~--- неразумно.\-


Можно преобразовать интерпретатор так, чтобы синтаксический
анализ проводился только один раз, и повысить таким образом
эффективность работы\footnote{Такое преобразование является неотъемлемой частью
процесса компиляции, который мы рассмотрим в 
главе~\ref{COMPUTING-WITH-REGISTER-MACHINES}.  Джонатан Рис
написал для проекта T интерпретатор Scheme с похожей структурой приблизительно в
1982 голу (Rees and Adams 1982).  Марк Фили 
(Feeley 1986, см. также 
Feeley and Lapalme 1987) независимо изобрел этот метод в
своей дипломной работе.\index{ru}{Адамс, Норман~И.,~IV||Norman I. Adams 
IV||n|п}\index{en}{Norman I. Adams IV||Адамс, 
Норман~И.,~IV||n|п}\index{ru}{Рис, Джонатан~А.||Jonathan~A. 
Rees||n|п}\index{en}{Jonathan~A. Rees||Рис, 
Джонатан~А.||n|п}\index{ru}{Фили, Марк||Marc Feeley||n|п}\index{en}{Marc 
Feeley||Фили, Марк||n|п}\index{ru}{Лапальм, Ги||Guy 
Lapalme||n|п}\index{en}{Guy Lapalme||Лапальм, Ги||n|п}}.
Мы разбиваем процедуру {\tt eval}, которая принимает выражение и
окружение, на две части.  {\tt Analyze} берет только
выражение.  Она выполняет синтаксический анализ и возвращает новую
{\em исполнительную} процедуру (execution 
procedure).\index{ru}{исполнительная процедура|в анализирующем  
вычислителе||||}\index{ru}{исполнительная процедура||execution 
procedure|||}\index{en}{execution procedure||исполнительная процедура|||} 
В этой процедуре упакована работа, которую придется 
проделать при выполнении выражения.  Исполнительная процедура берет в
качестве аргумента окружение и завершает вычисление.  При этом
экономится работа, потому что {\tt analyze} будет для каждого
выражения вызываться только один раз, а исполнительная процедура,
возможно, многократно.

После разделения анализа и выполнения {\tt eval}
превращается в

\begin{Verbatim}[fontsize=\small]
(define (eval exp env)\index{ru}{eval (метациклическая)|анализирующий вариант|||pd|}
  ((analyze exp) env))
\end{Verbatim}

Результатом вызова {\tt analyze} является
исполнительная процедура, которая применяется к окружению.  {\tt Analyze}
содержит тот же самый анализ, который делал исходный {\tt eval}
из раздела~\ref{THE-CORE-OF-THE-EVALUATOR}, однако
процедуры, между которыми мы выбираем, только анализируют, а не
окончательно выполняют выражение.

\begin{Verbatim}[fontsize=\small]
(define (analyze exp)\index{ru}{analyze|метациклическая|||pd|}
  (cond ((self-evaluating? exp) 
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Неизвестный тип выражения -- ANALYZE" exp))))
\end{Verbatim}

Вот самая простая из процедур анализа, которая обрабатывает
самовычисляющиеся выражения.  Ее результатом является исполнительная
процедура, которая игнорирует свой аргумент-окружение и просто
возвращает само выражение:\index{ru}{analyze-\ldots|метациклические|||p|}

\begin{Verbatim}[fontsize=\small]
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
\end{Verbatim}

В случае кавычки мы можем добиться
некоторого выигрыша, извлекая закавыченное выражение только один раз
на стадии анализа, а не на стадии выполнения.

\begin{Verbatim}[fontsize=\small]
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
\end{Verbatim}

Поиск переменной нужно проводить на стадии выполнения,
поскольку при этом требуется знать окружение\footnote{Есть,
впрочем, важная часть поиска переменной, которую
все-таки {\em можно} осуществить во время синтаксического анализа.
Как мы покажем в разделе~\ref{LEXICAL-ADDRESSING}, можно
определить позицию в структуре окружения, где будет находиться
нужное значение, и таким образом избежать необходимости
искать в окружении элемент, который соответствует переменной.}.

\begin{Verbatim}[fontsize=\small]
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
\end{Verbatim}

Анализ присваивания, {\tt analyze-assignment}, также
должен отложить само присваивание до времени выполнения, когда будет в
наличии окружение.  Однако возможность (рекурсивно) проанализировать выражение
{\tt assignment\-value} %HERE342
сразу, на стадии анализа,~--- это большой выигрыш в эффективности,
поскольку теперь это выражение будет анализироваться только однажды.
То же верно и для определений:

\begin{Verbatim}[fontsize=\small]
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))

(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
\end{Verbatim}

Для условных выражений мы извлекаем и анализируем
предикат, следствие и альтернативу на стадии анализа.

\begin{Verbatim}[fontsize=\small]
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))
\end{Verbatim}

При анализе выражения {\tt lambda} также достигается
значительный выигрыш в эффективности: тело {\tt lambda}
анализируется только один раз, а процедура, получающаяся в результате
выполнения {\tt lambda}, может применяться многократно.

\begin{Verbatim}[fontsize=\small]
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
\end{Verbatim}

Анализ последовательности выражений (в {\tt begin}
или в теле {\tt lambda}-вы\-ра\-же\-ния) более 
сложен\footnote{См.~упражнение~\ref{EX4.23}, в котором
объясняются некоторые подробности обработки по\-сле\-до\-ва\-тель\-нос\-тей.}.
Каждое выражение в последовательности анализируется, и для каждого получается
исполнительная процедура. Эти исполнительные процедуры комбинируются в одну
общую исполнительную процедуру, которая принимает в качестве аргумента
окружение и последовательно вызывает каждую из частичных исполнительных
процедур, передавая ей окружение как аргумент.

\begin{Verbatim}[fontsize=\small]
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Пустая последовательность -- ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{Verbatim}

Для вызова процедуры мы анализируем оператор и операнды и
строим исполнительную процедуру, которая вызывает исполнительную процедуру
оператора (получая при этом объект-процедуру, которую следует
применить) и исполнительные процедуры операндов (получая аргументы).
Затем мы все это передаем в {\tt execute-application}, аналог
{\tt apply} из раздела~\ref{THE-CORE-OF-THE-EVALUATOR}. 
{\tt Execute-application} отличается от {\tt apply} тем,
что тело составной процедуры уже проанализировано, так что нет нужды в
дальнейшем анализе.  Вместо этого мы просто вызываем исполнительную
процедуру для тела, передавая ей расширенное окружение.

\begin{Verbatim}[fontsize=\small]
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
                           (map (lambda (aproc) (aproc env))
                                aprocs)))))

(define (execute-application proc args)\index{ru}{execute-application|метациклическая|||pd|}
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))))
        (else
         (error
          "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
          proc))))
\end{Verbatim}

В нашем новом интерпретаторе используются те же структуры
данных, синтаксические процедуры и вспомогательные процедуры времени
выполнения, что и в 
разделах~\ref{REPRESENTING-EXPRESSIONS},
\ref{EVALUATOR-DATA-STRUCTURES} и
\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}.

\begin{exercise}{4.22}%
\label{EX4.22}%
\index{ru}{анализирующий интерпретатор|\texttt{let}||||(упр.~4.22)}Расширьте интерпретатор из этого 
раздела так, чтобы он
поддерживал {\tt let}. (См.~уп\-раж\-нение~\ref{EX4.6}.)
\end{exercise}

\begin{exercise}{4.23}%
\label{EX4.23}%
Лиза~П.~Хакер не понимает, зачем делать
{\tt analyze-sequence} такой сложной.  Все остальные процедуры
анализа~--- простые трансформации соответствующих вычисляющих процедур
(или ветвей {\tt eval}) из
раздела~\ref{THE-CORE-OF-THE-EVALUATOR}.  Лиза ожидала,
что {\tt analyze-se\-quence} будет выглядеть 
так:\index{ru}{analyze-\ldots|метациклические|||p|(упр.~4.23)}

\begin{Verbatim}[fontsize=\small]
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) ((car procs) env))
          (else ((car procs) env)
                (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Пустая последовательность -- ANALYZE"))
    (lambda (env) (execute-sequence procs env))))
\end{Verbatim}
Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше
работы по вычислению последовательности во время анализа.  В Лизиной
исполнительной процедуре вызовы частичных исполнительных процедур, вместо
того, чтобы быть встроенными, перебираются в цикле.  В результате,
хотя отдельные выражения в последовательности оказываются
проанализированы, сама последовательность анализируется во время
выполнения.

Сравните две версии {\tt analyze-sequence}.
Рассмотрите, например, обычный случай (типичный для тел процедур),
когда в последовательности только одно выражение.  Какую работу будет
делать исполнительная процедура, предложенная Лизой?  А процедура из
текста раздела?  Как соотносятся эти две процедуры в случае
последовательности из двух выражений?
\end{exercise}

\begin{exercise}{4.24}%
\label{EX4.24}%
Спроектируйте и проведите несколько экспериментов, чтобы
сравнить скорость исходного метациклического вычислителя и его версии из
этого раздела.  С помощью результатов этих опытов оцените долю
времени, которая тратится на анализ и на собственно выполнение в
различных процедурах.
\end{exercise}

\section{Scheme с вариациями: ленивый интерпретатор}
\label{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION}%


\index{ru}{задержанные вычисления|в ленивом 
интерпретаторе||||}\index{ru}{встроенный язык, использование в разработке     
языков||embedded language|||}\index{en}{embedded language||встроенный 
язык, использование в разработке     языков|||}\index{ru}{ленивый 
интерпретатор|||||}\index{ru}{язык программирования|строение||||}Теперь, 
имея в своем распоряжении интерпретатор, выраженный в виде
программы на Лиспе, мы можем экспериментировать с различными
вариантами строения языка, просто модифицируя этот интерпретатор.  В
самом деле, часто изобретение нового языка начинается с того, что пишут
интерпретатор, который встраивает новый язык в существующий язык
высокого уровня.  Например, если нам хочется обсудить какую-то деталь
предлагаемой модификации Лиспа с другим членом Лисп-сообщества, мы можем
предъявить ему интерпретатор, в котором эта модификация
реализована.  Тогда наш адресат может поэкспериментировать с новым интерпретатором
и послать в ответ свои замечания в виде дальнейших модификаций.
Реализация на высокоуровневой основе не только упрощает проверку и
отладку вычислителя; такое встраивание к тому же позволяет
разработчику 
слизывать\footnote{\index{ru}{слизывание||snarfing|||п}\index{en}{snarfing||слизывание|||п}Слизывать 
({\em snarf}): <<Брать, в особенности
большой документ или файл, с целью использовать с разрешения владельца
или без оного>>. Пролизывать ({\em snarf down}): <<Слизывать,
иногда с дополнительным значением восприятия, переработки или
понимания>>. (Эти определения были слизаны из 
Steele et al. 1983.\index{ru}{Стил, Гай Льюис мл.||Guy Lewis Steele 
Jr.||n|п}\index{en}{Guy Lewis Steele Jr.||Стил, Гай Льюис мл.||n|п}
См. также Raymond 1993.)\index{ru}{Рэймонд, Эрик||Eric 
Raymond||n|п}\index{en}{Eric Raymond||Рэймонд, Эрик||n|п}}
черты языка-основы, как наш встроенный интерпретатор Лиспа
использовал примитивы и структуру управления нижележащего Лиспа.
Только позже (да и то не всегда) разработчику приходится
брать на себя труд построения полной реализации на низкоуровневом
языке или в аппаратуре.  В этом разделе и следующем мы изучаем
некоторые вариации на тему Scheme, которые значительно увеличивают ее
выразительную силу.

\subsection{Нормальный порядок вычислений и аппликативный порядок 
вычислений}
\label{NORMAL-ORDER-AND-APPLICATIVE-ORDER}%


\index{ru}{нормальный порядок вычислений|vs. аппликативный порядок||||}В 
разделе~\ref{THE-ELEMENTS-OF-PROGRAMMING},
где мы начали обсуждение моделей вычисления, мы указали, что Scheme~--- язык с  
\index{ru}{аппликативный порядок вычислений|vs. нормальный 
порядок||||}\index{ru}{нормальный порядок вычислений|vs. аппликативный 
порядок||||}\index{ru}{язык программирования|с аппликативным порядком 
вычислений|language|applicative-order||}\index{en}{language|applicative-order|язык 
программирования|с аппликативным порядком вычислений||}{\em  аппликативным 
порядком вычисления} (applicative-order language), а 
именно, что все аргументы процедур в Scheme вычисляются в момент
вызова. Напротив, в языках с 
\index{ru}{язык программирования|с нормальным порядком 
вычислений|language|normal-order||}\index{en}{language|normal-order|язык 
программирования|с нормальным порядком вычислений||}{\em нормальным порядком
вычисления} (normal-order language) вычисление аргументов процедур 
задерживается до
момента,  когда действительно возникает нужда в их значениях. Если
вычисление аргументов процедур откладывается как можно дольше
(например, до того момента, когда они требуются какой-либо
\index{ru}{ленивое вычисление||lazy evaluation|||}\index{en}{lazy 
evaluation||ленивое вычисление|||}элементарной процедуре),  то говорят о 
{\em ленивом вычислении} (lazy
evaluation)\footnote{Терминологическая разница между выражениями
<<ленивый>> и <<нормальный порядок вычислений>> несколько размыта.  Обычно
<<ленивый>> относится к механизмам конкретных интерпретаторов, а
<<нормальный порядок>> к семантике языков независимо от способа
реализации.  Однако разделение здесь не жесткое, и часто эти термины
употребляются как синонимы.}.
Рассмотрим процедуру

\begin{Verbatim}[fontsize=\small]
(define (try a b)
  (if (= a 0) 1 b))
\end{Verbatim}
Выполнение {\tt (try 0 (/ 1 0))} в Scheme приводит к ошибке.
При ленивых вычислениях никакой ошибки не возникнет.  Вычисление
выражения даст результат 1, поскольку к аргументу {\tt (/ 1 0)}
обращаться не понадобится.

Примером использования ленивых вычислений может служить
процедура {\tt unless}:

\begin{Verbatim}[fontsize=\small]
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
\end{Verbatim}
которую можно использовать в выражениях вроде

\begin{Verbatim}[fontsize=\small]
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0")
               0))
\end{Verbatim}
В аппликативном языке это не будет работать, потому что и обычное
значение, и значение исключения будут выполнены еще до вызова {\tt unless} 
(См.~упражнение~\ref{EX1.6}).  Преимущество ленивых
вычислений в том, что некоторые процедуры, например, та же
{\tt unless}, могут выполнять полезные действия, даже если
вычисление некоторых их аргументов способно привести к ошибке или
бесконечному циклу.

Если тело процедуры начинает выполняться прежде, чем
вычисляется ее аргумент, то процедура называется 
\index{ru}{нестрогая процедура||non-strict 
procedure|||}\index{en}{non-strict procedure||нестрогая процедура|||}{\em 
нестрогой} (non-strict)\index{ru}{процедура|нестрогая||non-strict||}
по этому аргументу.  Если же
аргумент вычисляется прежде, чем происходит вход в процедуру, то
процедура называется \index{ru}{строгая 
процедура||procedure|strict||}\index{en}{procedure|strict|строгая 
процедура|||}{\em строгой} (strict)
по этому аргументу\footnote{Термины <<строгий>> и <<нестрогий>> означают, в
сущности, то же самое, что <<аппликативный>> и <<нормальный>> порядок
вычислений, но только они относятся к отдельным процедурам и их
аргументам, а не к языку в целом.  На конференциях по языкам
программирования можно услышать, как кто-нибудь говорит: <<В языке
\index{ru}{Hassle (Закавыка)|||||п}Hassle
с нормальным порядком вычислений есть несколько строгих
примитивов.  Остальные процедуры принимают аргументы через ленивое
вычисление>>.}.
В чисто аппликативном языке все процедуры строги по всем своим
аргументам.  В языке с чисто нормальным порядком вычислений все
составные процедуры нестроги по всем своим аргументам, а элементарные
процедуры могут быть и такими, и такими.  Бывают также языки 
(см.~упражнение~\ref{EX4.31}), 
которые дают программисту возможность явно
обозначать строгость определяемых им процедур.

Яркий пример процедуры, которой может быть полезно
оказаться нестрогой,~--- это {\tt cons} (и вообще почти любой
конструктор структур данных).  Можно производить полезные вычисления,
составлять из элементов структуры данных и работать с ними, даже если
значения элементов неизвестны.  Вполне имеет смысл задача, например,
посчитать длину списка, не зная значений его отдельных элементов.  В
разделе~\ref{STREAMS-AS-LAZY-LISTS} мы развиваем эту идею
и реализуем потоки из главы~\ref{MODULARITY-OBJECTS-AND-STATE} в виде списков,
составленных из нестрогих {\tt cons}-пар.

\begin{exercise}{4.25}%
\label{EX4.25}%
Предположим, что мы (в обычной Scheme с аппликативным
порядком вычислений) определяем {\tt unless} как показано выше,
а затем определяем {\tt factorial} через {\tt unless}:

\begin{Verbatim}[fontsize=\small]
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
\end{Verbatim}
Что произойдет, если мы попытаемся вычислить {\tt (factorial
5)}?  Будут ли наши определения работать в языке с нормальным
порядком вычислений?
\end{exercise}

\begin{exercise}{4.26}%
\label{EX4.26}%
Бен Битобор и Лиза П.~Хакер расходятся во мнениях
о важности ленивых вычислений для реализации конструкций вроде
{\tt unless}.  Бен указывает, что при аппликативном порядке
{\tt unless} можно реализовать как  \index{ru}{процедура|vs.  особая 
форма||||(упр.~4.26)}\index{ru}{особая форма|vs. 
процедура||||(упр.~4.26)}особую форму.  Лиза
отвечает, что в таком случае {\tt unless} будет просто
синтаксисом, а не процедурой, которую можно использовать в сочетании с
процедурами высших порядков.  Проясните детали в обеих позициях.
Покажите, как реализовать {\tt unless} в виде производного
выражения (вроде {\tt cond} или {\tt let}), и
приведите пример ситуации, когда имеет смысл, чтобы
{\tt unless} была процедурой, а не особой формой.
\end{exercise}

\subsection{Интерпретатор с ленивым вычислением}
\label{AN-INTERPRETER-WITH-LAZY-EVALUATION}%


В этом разделе мы реализуем язык с нормальным порядком
вычислений, который отличается от Scheme только тем, что все составные
процедуры по всем аргументам нестроги.  Элементарные процедуры
по-прежнему будут строгими.  Совсем несложно, модифицируя
интерпретатор из раздела \ref{THE-CORE-OF-THE-EVALUATOR}, добиться, чтобы
интерпретируемый язык вел себя таким образом.  Почти что все требуемые изменения
сосредоточены вокруг механизма процедурного вызова.

Основная идея состоит в том, что при вызове процедуры
интерпретатор должен определить, какие аргументы требуется вычислить,
а какие задержать.  Задержанные аргументы не вычисляются, а
преобразуются в объекты, называемые 
\index{ru}{санк||thunk|||}\index{en}{thunk||санк|||}{\em санками} 
(thunks)\footnote{\index{ru}{санк|происхождение      
названия||||п}\index{ru}{Algol (Алгол)|санки||||п}Название <<санк>> было 
придумано в
неформальной группе, которая обсуждала реализацию вызова по имени в
Алголе 60.\index{ru}{Algol (Алгол)|передача аргументов по имени||||п}
Было замечено, что большую часть анализа
(<<обдумывания>>, {\em thinking about}) выражения можно производить
во время компиляции; таким образом, во время выполнения выражение
будет уже большей частью <<обдумано>> ({\em thunk about}~---
намеренно неверно образованная английская форма)
(Ingerman et al. 1960).\index{ru}{Ингерман, Питер||Peter 
Ingerman||n|п}\index{en}{Peter Ingerman||Ингерман, 
Питер||n|п}}\translationnote{В русскоязычной литературе слово {\em thunk}
иногда переводится как <<переходник>>.  Нам кажется, что в данном
случае такой перевод мешал бы пониманию текста.}.
В санке должна содержаться информация, необходимая, чтобы вычислить
значение аргумента, когда оно потребуется, и сделать это так, как будто оно
вычислено во время вызова.  Таким образом, санк должен содержать
выражение-аргумент и окружение, в котором вычисляется вызов процедуры.

Процесс вычисления санка называется 
\index{ru}{санк|вынуждение||||}\index{ru}{вынуждение санка||forcing a 
thunk|||}\index{en}{forcing a thunk||вынуждение санка|||}{\em вынуждением} 
(forcing a thunk)\footnote{Это аналогично использованию слова {\tt 
force}\index{ru}{force|vs. вынуждение санка|||p|п}
(<<вынудить>>, <<заставить>>) для задержанных объектов, при
помощи которых в главе~\ref{MODULARITY-OBJECTS-AND-STATE}
представлялись потоки.  Основная разница между тем, что мы делаем
здесь, и тем, чем мы занимались в 
главе~\ref{MODULARITY-OBJECTS-AND-STATE}, состоит в том, что теперь мы
встраиваем задержку и вынуждение в интерпретатор, и они
применяются автоматически и единообразно во всем языке.}
Вообще говоря, санк вынуждается только тогда, когда требуется его
значение: когда он передается в элементарную процедуру, использующую
его значение; когда он служит предикатом в условном
выражении; или когда он является значением оператора, который нужно
применить как процедуру.  Мы должны решить, будем ли 
мы 
\index{ru}{мемоизация|санков||||}\index{ru}{мемоизация||memoization|||}\index{en}{memoization||мемоизация|||}{\em
  мемоизировать} (memoize) санки, как мы делали с задержанными объектами в 
разделе~\ref{STREAMS-ARE-DELAYED-LISTS}.  При использовании мемоизации,
когда санк вынуждается в первый раз, он запоминает
вычисленное значение.  Последующие вызовы только возвращают
запомненное значение, не вычисляя его заново.  Мы делаем выбор
в пользу мемоизации, поскольку для многих приложений это
эффективнее.  Здесь, однако, имеются тонкости\footnote{Ленивые 
вычисления, совмещенные с мемоизацией, иногда
называют методом передачи аргументов с \index{ru}{вызов по 
необходимости||call by need|||п}\index{en}{call by need||вызов по 
необходимости|||п}{\em \index{ru}{вызов по необходимости|||||п} вызовом по
необходимости} (call by need), в отличие от \index{ru}{вызов по 
имени||call by name|||п}\index{en}{call by name||вызов по имени|||п}{\em 
вызова
по имени} (call by name). (Вызов по имени, введенный в Алголе 60, аналогичен
немемоизированному ленивому вычислению.)  Как проектировщики языка
мы можем сделать интерпретатор мемоизирующим или немемоизирующим,
или же оставить это на усмотрение программистов (упражнение~\ref{EX4.31}).
Как можно было ожидать из 
главы~\ref{MODULARITY-OBJECTS-AND-STATE}, этот выбор вызывает к жизни
вопросы, особенно тонкие и запутанные в присутствии присваивания. 
(См.~упражнения~\ref{EX4.27} и \ref{EX4.29}.)  В замечательной статье Клингера
(Clinger 1982) делается попытка прояснить
многомерную путаницу, которая здесь возникает.\index{ru}{Клингер, 
Уильям||William Clinger||n|п}\index{en}{William Clinger||Клингер, 
Уильям||n|п}}.

\paragraph{Преобразование интерпретатора}


Основная разница между ленивым интерпретатором и
интерпретатором из раздела~\ref{THE-CORE-OF-THE-EVALUATOR}
состоит в обработке вызовов процедур внутри {\tt eval} и
{\tt apply}.

Ветка {\tt application?} в {\tt eval}\index{ru}{eval (ленивая)||||p|}
принимает вид

\begin{Verbatim}[fontsize=\small]
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
\end{Verbatim}
Это почти тот же код, что был в ветке {\tt application?}  в
{\tt eval} из раздела~\ref{THE-CORE-OF-THE-EVALUATOR}.
Однако при ленивом вычислении мы зовем 
{\tt apply} с выражениями операндов, а не с аргументами,
которые получаются при их вычислении.  Мы также передаем {\tt apply}
окружение, поскольку оно понадобится для построения санков, если нам
хочется, чтобы аргуметы вычислялись с задержкой.  Оператор мы
по-прежнему вычисляем, потому что сама применяемая процедура нужна
{\tt apply}, чтобы выбрать действие на основании ее типа (элементарная
или составная) и применить ее.

Всякий раз, когда нам требуется собственно значение выражения, мы
вместо простого {\tt eval} пользуемся процедурой

\begin{Verbatim}[fontsize=\small]
(define (actual-value exp env)\index{ru}{actual-value||||pd|}
  (force-it (eval exp env)))
\end{Verbatim}
чтобы, если значение выражения является санком, оно было
вынуждено.

Наша новая версия {\tt apply} также почти
совпадает с версией из 
раздела~\ref{THE-CORE-OF-THE-EVALUATOR}.  Разница состоит в том,
что {\tt eval}
передает ей невычисленные выражения: для
элементарных процедур (они строгие) мы вычисляем все аргументы и затем
вызываем примитив; для составных процедур (они нестрогие) мы прежде
применения процедуры замораживаем все аргументы.

\begin{Verbatim}[fontsize=\small]
(define (apply procedure arguments env)\index{ru}{apply (ленивая)||||pd|}
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env))) {\em ; изменение}
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env) {\em ; изменение}
           (procedure-environment procedure))))
        (else
         (error
          "Неизвестный тип процедуры -- APPLY" procedure))))
\end{Verbatim}
Процедуры, обрабатывающие аргументы, почти такие же, как
{\tt list-of-values} из 
раздела~\ref{THE-CORE-OF-THE-EVALUATOR}, но только
{\tt list-of-delayed-args} замораживает аргументы, вместо того,
чтобы их вычислять, а в {\tt list-of-arg-values} вместо
{\tt eval} используется {\tt actual-value}:
{\sloppy

}
\begin{Verbatim}[fontsize=\small]
(define (list-of-arg-values exps env)\index{ru}{list-of-arg-values||||pd|}
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)\index{ru}{list-of-delayed-args||||pd|}
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
\end{Verbatim}

Кроме того, нам требуется изменить в интерпретаторе
обработку {\tt if}, где вместо {\tt eval} мы должны вызывать {\tt
  actual-value}, чтобы значение предикатного выражения вычислялось
прежде, чем мы проверим, истинно оно или ложно: 

\begin{Verbatim}[fontsize=\small]
(define (eval-if exp env)\index{ru}{eval-if (ленивая)||||pd|}
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{Verbatim}

\index{ru}{управляющий цикл|в ленивом интерпретаторе||||}Наконец, нужно изменить процедуру
{\tt driver-loop} 
(раздел~\ref{RUNNING-THE-EVALUATOR-AS-A-PROGRAM}), чтобы она звала
{\tt actual-value} вместо {\tt eval}. Таким образом, если
задержанное значение добирается до цикла чтение-вычисление-печать, то
оно, прежде чем печататься, будет разморожено.  Кроме того, чтобы
показать, что работа идет с ленивым интерпретатором, мы изменим
подсказки:

\begin{Verbatim}[fontsize=\small]
(define input-prompt ";;; Ввод L-Eval:") \index{ru}{подсказка|ленивый интерпретатор||||}
(define output-prompt ";;; Значение L-Eval:")

(define (driver-loop)\index{ru}{driver-loop|для ленивого интерпретатора|||pd|}
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
\end{Verbatim}

Внеся эти изменения, мы можем запустить
интерпретатор и протестировать его.  Успешное вычисление выражения
{\tt try}, описанного в 
разделе~\ref{NORMAL-ORDER-AND-APPLICATIVE-ORDER}, показывает, что
интерпретатор проводит ленивое вычисление:

\begin{Verbatim}[fontsize=\small]
(define the-global-environment (setup-environment))

(driver-loop)

\textit{;;; Ввод L-eval:}
(define (try a b)
  (if (= a 0) 1 b))
\textit{;;; Значение L-Eval:}
\textit{ok}

\textit{;;; Ввод L-eval:}
(try 0 (/ 1 0))
\textit{;;; Значение L-Eval:}
\textit{1}
\end{Verbatim}

\paragraph{Представление санков}

\index{ru}{санк|реализация||||}Наш интерпретатор должен устроить работу 
так, чтобы при
применении процедур к аргументам порождались санки, и чтобы потом они
вынуждались.  Выражение в санке должно запаковываться вместе с
окружением, так, чтобы потом можно было по ним вычислить аргумент.  Чтобы
вынудить санк, мы просто извлекаем из него выражение и окружение, и
вычисляем выражение в окружении.  Мы используем при этом не
{\tt eval}, а {\tt actual-value}, так что если результат
выражения сам окажется санком, мы и его вынудим, и так пока не
доберемся до не-санка.

\begin{Verbatim}[fontsize=\small]
(define (force-it obj)\index{ru}{force-it||||pd|}
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
\end{Verbatim}

Простой способ упаковать выражение вместе с окружением
--- создать список из выражения и окружения.  Таким образом, мы
порождаем санк так:

\begin{Verbatim}[fontsize=\small]
(define (delay-it exp env)\index{ru}{delay-it||||pd|}
  (list 'thunk exp env))

(define (thunk? obj)\index{ru}{thunk?||||pd|}
  (tagged-list? obj 'thunk))

(define (thunk-exp thunk) (cadr thunk))\index{ru}{thunk-exp||||pd|}

(define (thunk-env thunk) (caddr thunk))\index{ru}{thunk-env||||pd|}
\end{Verbatim}

Однако на самом деле нам в интерпретаторе нужны не
такие санки, а мемоизированные. Мы сделаем так, чтобы санк при
вынуждении превращался в вычисленный санк. Для этого мы будем заменять
хранимое в нем выражение на
значение и менять метку санка, чтобы можно было понять, что он уже
вычислен\footnote{Заметим, что, вычислив выражение, мы еще и стираем из
санка окружение.  Это не влияет на то, какие значения возвращает
интерпретатор.  Однако при этом экономится память,
поскольку стирание ссылки из санка на {\tt env}, когда она становится
больше не нужна, позволяет подвергнуть эту структуру
\index{ru}{сборка мусора||garbage collection|||п}\index{en}{garbage
  collection||сборка мусора|||п}{\em сборке мусора} (garbage
collection) и заново использовать ее память.  Мы обсудим это в 
разделе~\ref{STORAGE-ALLOCATION-AND-GARBAGE-COLLECTION}.\index{ru}{сборка 
мусора|и мемоизация||||п}\index{ru}{мемоизация|и сборка
мусора||||п}

Подобным образом можно было бы разрешить собирать как мусор 
ненужные окружения в мемоизированных задержанных объектах из
раздела~\ref{STREAMS-ARE-DELAYED-LISTS}:
{\tt memo-proc}, сохранив значение процедуры {\tt proc}, делала бы
что-нибудь вроде {\tt (set! proc '())}, чтобы забыть саму процедуру
(включающую окружение, где было вычислено {\tt delay}).}.

\begin{Verbatim}[fontsize=\small]
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (force-it obj)\index{ru}{force-it|вариант с мемоизацией|||pd|}
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result) 
	                           {\em ; заменить {\tt exp} на его значение}
           (set-cdr! (cdr obj) '()){\em ; забыть ненужное {\tt env}}
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
\end{Verbatim}
Заметим, что одна и та же процедура {\tt delay-it} работает и с
мемоизацией, и без нее.
\begin{exercise}{4.27}%
\label{EX4.27}%
Допустим, мы вводим в ленивый интерпретатор следующее
выражение:

\begin{Verbatim}[fontsize=\small]
(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)
\end{Verbatim}
Вставьте пропущенные значения в данной ниже последовательности
действий и объясните свои ответы\footnote{Это упражнение показывает, что 
взаимодействие между
ленивыми вычислениями и побочными эффектами может быть весьма
запутанным.  Ровно этого можно было ожидать после обсуждения в
главе~\ref{MODULARITY-OBJECTS-AND-STATE}.}:

\begin{Verbatim}[fontsize=\small]
(define w (id (id 10)))

\textit{;;; Ввод L-Eval:}
count
\textit{;;; Значение L-Eval:}
\textit{$\langle$вывод$\rangle$}

\textit{;;; Ввод L-Eval:}
w
\textit{;;; Значение L-Eval:}
\textit{$\langle$вывод$\rangle$}

\textit{;;; Ввод L-Eval:}
count
\textit{;;; Значение L-Eval:}
\textit{$\langle$вывод$\rangle$}
\end{Verbatim}
\end{exercise}
\begin{exercise}{4.28}%
\label{EX4.28}%
{\tt Eval}, передавая оператор в
{\tt apply}, вычисляет его не при помощи {\tt eval}, а
через {\tt actual-value}, чтобы вынудить.  Приведите пример, который
показывает, что такое вынуждение необходимо.
\end{exercise}

\begin{exercise}{4.29}%
\label{EX4.29}%
Придумайте пример программы, которая, по Вашему мнению,
будет работать намного медленнее без мемоизации, чем с мемоизацией.  
Рассмотрим, помимо этого, следующую последовательность действий, в которой 
процедура
{\tt id} определена как в упражнении~\ref{EX4.27},
а счетчик {\tt count} начинает с 0:

\begin{Verbatim}[fontsize=\small]
(define (square x)
  (* x x))

\textit{;;; Ввод L-Eval:}
(square (id 10))
\textit{;;; Значение L-Eval:}
\textit{$\langle$вывод$\rangle$}

\textit{;;; Ввод L-Eval:}
count
\textit{;;; Значение L-Eval:}
\textit{$\langle$вывод$\rangle$}
\end{Verbatim}
Укажите, как будет выглядеть вывод в случае с мемоизирующим интерпретатором и с
немемоизирующим.
\end{exercise}

\begin{exercise}{4.30}%
\label{EX4.30}%
Пабло Э.~Фект, бывший программист на языке C, беспокоится,
что ленивый интерпретатор не вынуждает выражения в
последовательности, и оттого некоторые побочные эффекты могут никогда не
произойти.  Поскольку ни у одного выражения в последовательности,
помимо конечного, значение не используется (выражение стоит там только ради
своего эффекта, например, чтобы присвоить значение переменной или
что-нибудь напечатать),
у значения такого выражения не может впоследствии быть применения, для
которого его потребуется вынудить (например, в качестве
аргумента элементарной процедуры).
Поэтому П.Э.~Фект считает, что при выполнении последовательности нужно
все выражения, кроме последнего, вынуждать.  Он предлагает изменить
{\tt eval-sequence} из  раздела~\ref{THE-CORE-OF-THE-EVALUATOR} так,
чтобы она  вместо {\tt eval} использовала {\tt actual-value}:

\begin{Verbatim}[fontsize=\small]
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
\end{Verbatim}

\begin{plainenum}
\item

Бен Битобор считает, что Пабло неправ.  Он
показывает ему процедуру {\tt for-each} из 
упражнения~\ref{EX2.23}~--- важный пример последовательности с побочными
эффектами:

\begin{Verbatim}[fontsize=\small]
(define (for-each proc items)\index{ru}{for-each||||pd|(упр.~4.30)}
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
\end{Verbatim}
Он утверждает, что интерпретатор из текста (с исходным
{\tt eval-sequence}) правильно работает с этой процедурой:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод L-Eval:}
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
\textit{57}
\textit{321}
\textit{88}
\textit{;;; Значение L-Eval:}
\textit{done}
\end{Verbatim}
Объясните, почему Бен прав насчет поведения {\tt for-each}.

\item
Пабло соглашается с Беном по поводу примера с
{\tt for-each}, но говорит, что, предлагая
изменить {\tt eval-sequence}, он имел в виду другой тип
программ.  Он определяет в ленивом интерпретаторе следующие две
процедуры:

\begin{Verbatim}[fontsize=\small]
(define (p1 x)
  (set! x (cons x '(2)))
  x)

(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
\end{Verbatim}
Какие значения вернут {\tt (p1 1)} и {\tt (p2 1)} с
исходной {\tt eval-sequence}?  Каковы будут значения с
изменением, которое предлагает Пабло?

\item
 Пабло указывает также, что изменение
{\tt eval-sequence}, которое он предлагает, не влияет на
поведение примера из части a.  Объясните, почему это так.

\item
Как, по-Вашему, нужно работать с
последовательностями в ленивом интерпретаторе? Что Вам нравится
больше: подход Пабло, подход, приведенный в тексте, или что-нибудь
третье?
\end{plainenum}
\end{exercise}

\begin{exercise}{4.31}%
\label{EX4.31}%
Подход, принятый в этом разделе, нехорош тем, что
вносит изменение в Scheme, не сохраняя ее семантику.  Было бы
приятнее реализовать ленивые вычисления как 
\index{ru}{совместимое расширение||upward-compatible 
extension|||(упр.~4.31)}\index{en}{upward-compatible 
extension||совместимое расширение|||(упр.~4.31)}{\em совместимое 
расширение} (upward-compatible extension),
то есть так, чтобы обычные программы на Scheme работали как прежде.
Этого можно добиться, расширив синтаксис определений процедур, так,
чтобы пользователь мог решать, нужно ли задерживать аргументы.  При
этом можно еще предоставить пользователю выбор между задержкой с мемоизацией и
без нее.  Например, определение

\begin{Verbatim}[fontsize=\small]
(define (f a (b lazy) c (d lazy-memo))
   ...)
\end{Verbatim}
делало бы {\tt f} процедурой от четырех аргументов, причем
первый и третий вычисляются при вызове процедуры, второй
задерживается, а четвертый задерживается и мемоизируется.  Таким
образом, обыкновенные определения процедур будут задавать такое же
поведение, как в обычной Scheme, а добавление декларации
{\tt lazy-memo} к каждому параметру каждой составной процедуры
приведет к поведению, как у ленивого интерпретатора, описанного в этом
разделе.  Разработайте и реализуйте изменения, с помощью которых можно
получить такое расширение Scheme.  Вам придется реализовать новые
синтаксические процедуры для нового синтаксиса {\tt define}.
Кроме того, надо будет добиться, чтобы {\tt eval} и
{\tt apply} определяли, когда надо задерживать аргументы, и
соответствующим образом задерживали и вынуждали их.
Наконец, придется обеспечить,чтобы вынуждение было с
мемоизацией или без оной, смотря по обстоятельствам.
\end{exercise}

\subsection{Потоки как ленивые списки}
\label{STREAMS-AS-LAZY-LISTS}%


\index{ru}{ленивый список||lazy list|||}\index{en}{lazy list||ленивый 
список|||}\index{ru}{ленивая пара||lazy pair|||}\index{en}{lazy 
pair||ленивая пара|||}\index{ru}{список|ленивый||||}\index{ru}{пара 
(пары)|ленивые||||}\index{ru}{процедура|vs. особая 
форма||||}\index{ru}{особая форма|vs. 
процедура||||}\index{ru}{поток(и)|реализованные в виде ленивых 
списков||||}В разделе~\ref{STREAMS-ARE-DELAYED-LISTS} мы
показали, как реализовать потоки в виде задержанных списков.  Мы ввели
особые формы {\tt delay} и {\tt cons-stream},\index{ru}{delay (особая 
форма)|и ленивые вычисления|||p|}\index{ru}{cons-stream (особая форма)|и 
ленивые вычисления|||p|} которые
позволили нам строить <<обещания>> вычислить {\tt cdr} потока,
не выполняя эти обещания до более позднего времени.  Можно было бы
использовать этот же метод и вводить новые особые формы всякий раз,
когда нам требуется детальное управление процессом вычисления, но
это было бы весьма неуклюже.  Прежде всего, особая форма, в
отличие от процедуры, не является полноправным объектом, и ее нельзя
использовать в сочетании с процедурами высших порядков\footnote{Это как 
раз тот вопрос, который возник по отношению к
процедуре {\tt unless} в упражнении~\ref{EX4.26}.}.
Кроме того, нам пришлось ввести потоки как новый тип объектов данных,
похожий на списки, но отличный от них, и из-за этого потребовалось
заново переписать для работы с потоками множество обычных операций над списками 
({\tt map}, {\tt append} и тому подобное).

Когда у нас есть ленивое вычисление, списки и потоки можно
считать одним и тем же типом, так что не возникает нужды в особых
формах и в отдельных наборах операций для списков и потоков.  Все, что
нам требуется,~--- это так устроить дела, чтобы {\tt cons}
оказалась нестрогой.  Можно сделать это, расширив интерпретатор и
разрешив нестрогие элементарные процедуры, а затем реализовать
{\tt cons} как одну из таких процедур.  Однако проще вспомнить
(из раздела~\ref{WHAT-IS-MEANT-BY-DATA}), что вообще не существует
особой нужды реализовывать {\tt cons} как примитив.  Вместо
этого можно \index{ru}{пара (пары)|процедурное
  представление||||}представлять пары в виде процедур\footnote{Это
  процедурное представление, описанное в
упражнении~\ref{EX2.4}.  В сущности, подошла бы и любая другая
процедурная реализация (например, на основе передачи сообщений).
Обратите внимание, что внести эти определения в ленивый интерпретатор
можно, просто набрав их в управляющем цикле.  Если мы изначально
включили  {\tt cons}, {\tt car} и {\tt cdr} как
примитивы в глобальное окружение, они будут
переопределены. (См. также упражнения~\ref{EX4.33} и 
\ref{EX4.34}.)}.

\begin{Verbatim}[fontsize=\small]
(define (cons x y)\index{ru}{cons (элементарная процедура)|процедурная реализация|||pd|}
  (lambda (m) (m x y)))

(define (car z)\index{ru}{car (элементарная процедура)|процедурная реализация|||pd|}
  (z (lambda (p q) p)))

(define (cdr z)\index{ru}{cdr (элементарная процедура)|процедурная реализация|||pd|}
  (z (lambda (p q) q)))
\end{Verbatim}

Выраженные через эти базовые операции, стандартные
определения операций над списками будут работать как с бесконечными
списками (потоками), так и с конечными, а потоковые операции можно
определить как операции над списками.  Вот несколько примеров:

\begin{Verbatim}[fontsize=\small]
(define (list-ref items n)\index{ru}{list-ref||||pd|}
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (map proc items)\index{ru}{map||||pd|}
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-list items factor)\index{ru}{scale-list||||pd|}
  (map (lambda (x) (* x factor))
       items))

(define (add-lists list1 list2)\index{ru}{add-lists||||pd|}
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))

(define ones (cons 1 ones))\index{ru}{ones (бесконечный поток)|вариант с ленивыми списками|||pd|}

(define integers (cons 1 (add-lists ones integers)))\index{ru}{integers (бесконечный поток)|вариант с ленивыми списками|||pd|}

\textit{;;; Ввод L-Eval:}
(list-ref integers 17)
\textit{;;; Значение L-Eval:}
\textit{18}
\end{Verbatim}

Заметим, что ленивые списки еще ленивее, чем потоки в 
главе~\ref{MODULARITY-OBJECTS-AND-STATE}: задерживается не
только {\tt cdr} списка, но и {\tt car}\footnote{Благодаря этому можно 
реализовать задержанные версии
не только последовательностей, но и более общих видов списковых структур. В
Hughes 1990 обсуждаются некоторые 
применения\index{ru}{Хьюз,~Р.~Дж.~М.||R.~J.~M.~Hughes||n|п}\index{en}{R.~J.~M.~Hughes||Хьюз,~Р.~Дж.~М.||n|п} 
\index{ru}{ленивое 
дерево||lazy tree|||п}\index{en}{lazy tree||ленивое 
дерево|||п}\index{ru}{дерево|ленивое||||п}<<ленивых деревьев>>.}.
На самом деле, даже доступ к {\tt car} или {\tt cdr}
ленивой пары не обязательно вынуждает значение элемента
списка.  Значение будет вынуждено только тогда, когда это
действительно нужно~--- например, чтобы использовать его в качестве
аргумента примитива или напечатать в качестве ответа.

Ленивые пары также помогают с решением проблемы, которая
возникла в разделе~\ref{STREAMS-AND-DELAYED-EVALUATION},
где мы обнаружили, что формулировка потоковых моделей систем с
циклами может потребовать оснащения программы явными операциями
{\tt delay}, 
\index{ru}{delay (особая форма)|явная vs. 
автоматическая|||p|}\index{ru}{задержанные вычисления|явные и 
автоматические||||}помимо тех, что встроены в {\tt cons-stream}.  При
ленивом вычислении все аргументы процедур единообразно задерживаются.
Например, можно реализовать процедуры для интегрирования
списка и решения дифференциальных уравнений так, как мы изначально намеревались
в разделе~\ref{STREAMS-AND-DELAYED-EVALUATION}:

\begin{Verbatim}[fontsize=\small]
(define (integral integrand initial-value dt)\index{ru}{integral|вариант с ленивыми списками|||pd|}
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt)
                    int)))
  int)

(define (solve f y0 dt)  \index{ru}{solve|вариант с ленивыми списками|||pd|}
  (define y (integral dy y0 dt))
  (define dy (map f y))
  y)

\textit{;;; Ввод L-Eval:}
;: (list-ref (solve (lambda (x) x) 1 .001) 1000)
\textit{;;; Значение L-Eval:}
\textit{2.176924}
\end{Verbatim}

\begin{exercise}{4.32}%
\label{EX4.32}%
Приведите несколько примеров, которые показывают разницу
между потоками из главы~\ref{STREAMS-AND-DELAYED-EVALUATION}
и <<более ленивыми>> списками, описанными в этом разделе.  Как можно
воспользоваться этой дополнительной ленивостью?
\end{exercise}

\begin{exercise}{4.33}%
\label{EX4.33}%
Бен Битобор проверяет вышеописанную реализацию при помощи
выражения

\begin{Verbatim}[fontsize=\small]
(car '(a b c))
\end{Verbatim}
К его большому удивлению, в ответ выдается ошибка.  После некоторого
размышления он понимает, что <<списки>>. которые получаются при
чтении кавычек, отличаются от списков, управляемых новыми определениями
{\tt cons}, {\tt car} и {\tt cdr}. Измените
работу интерпретатора с закавыченными выражениями так, чтобы при вводе
списковых выражений в цикле управления получались настоящие ленивые
списки.
\end{exercise}

\begin{exercise}{4.34}%
\label{EX4.34}%
Измените управляющий цикл интерпретатора так, чтобы ленивые
пары и списки печатались каким-либо разумным образом.  (Как Вы собираетесь 
работать
с бесконечными списками)?  Вероятно, понадобится также изменить
представление ленивых пар, чтобы при печати интерпретатор их
распознавал и печатал особым образом.
\end{exercise}

\section{Scheme с вариациями~---\protect\\ недетерминистское
вычисление}
\label{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}%


В этом разделе мы расширяем интерпретатор Scheme так, чтобы
он поддерживал  парадигму программирования, называемую 
\index{ru}{недетерминистское вычисление||non\-de\-ter\-mi\-nis\-tic
  computing|||}\index{en}{non\-de\-ter\-mi\-nis\-tic computing||недетерминистское
  вычисление|||}{\em недетерминистское вычисление} (nondeterministic 
computing), встраивая в интерпретатор средства
поддержки \index{ru}{автоматический поиск|||||} автоматического поиска.
Это значительно более глубокое 
изменение в языке, чем введение ленивых вычислений в 
разделе~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION}.

\index{ru}{недетерминистское программирование       vs. программирование 
на Scheme||non\-deter\-mi\-nis\-tic programming vs. Scheme       
programming|||}\index{en}{non\-de\-ter\-mi\-nis\-tic programming vs. Scheme       
programming||недетерминистское программирование       vs. программирование 
на Scheme|||}Подобно обработке потоков, недетерминистское вычисление
полезно в задачах типа <<порождение и проверка>>.  Рассмотрим такую задачу:
даются два списка натуральных чисел, и требуется найти пару
чисел~--- одно из первого списка, другое из второго,~--- сумма которых
есть простое число.  В 
разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES} мы уже
рассмотрели, как это можно сделать при помощи
операций над конечными последовательностями, а в 
разделе~\ref{EXPLOITING-THE-STREAM-PARADIGM}~--- при
помощи бесконечных потоков. Наш подход состоял в том, чтобы породить
последовательность всех возможных пар и отфильтровать ее, выбирая
пары, в которых сумма есть простое число.  Порождаем ли мы на самом деле
сначала всю последовательность, как в 
главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}, или чередуем
порождение и фильтрацию, как в 
главе~\ref{MODULARITY-OBJECTS-AND-STATE}, несущественно для
общей картины того, как организовано вычисление.

\index{ru}{недетерминистские программы|пары чисел с простой 
суммой|nondeterministic programs|||}\index{en}{nondeterministic 
programs||недетерминистские программы|пары чисел с простой суммой||}При 
недетерминистском подходе используется другой
образ.  Просто представим себе, что мы (каким-то образом)
выбираем число из первого списка и число из второго списка, а затем
предъявляем (при помощи какого-то механизма) требование, чтобы их сумма 
была простым числом.  Это выражается следующей процедурой:

\begin{Verbatim}[fontsize=\small]
(define (prime-sum-pair list1 list2) \index{ru}{prime-sum-pair||||pd|}
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
\end{Verbatim}
Может показаться, что эта процедура просто переформулирует задачу, а не
указывает способ ее решить.  Однако это законная недетерминистская
программа\footnote{Мы предполагаем, что уже заранее определена процедура
{\tt prime?}, которая проверяет числа на простоту.  Даже если
такая процедура определена, {\tt prime-sum-pair} может
подозрительно напоминать бестолковую попытку определения
квадратного корня на псевдо-Лиспе из начала 
раздела~\ref{EXAMPLE-SQUARE-ROOTS-BY-NEWTONS-METHOD}.  На самом
деле, подобного рода процедура вычисления квадратного корня может быть
сформулирована в виде недетерминистской программы. 
\index{ru}{декларативное vs. императивное знание|и недетерминистское 
вычисление||||п}\index{ru}{императивное vs.  декларативное знание|и 
недетерминистское вычисление||||п}Вводя в
интерпретатор механизм поиска, мы размываем границу между чисто
декларативными описаниями и императивными спецификациями способов
вычислить ответ.  В разделе~\ref{LOGIC-PROGRAMMING} мы
пойдем еще дальше в этом направлении.}.

Основная идея здесь состоит в том, что выражениям в
недетерминистском языке разрешается иметь более одного возможного значения.
Например, {\tt an-element-of} может вернуть любой элемент
данного списка.  Наш интерпретатор недетерминистских программ будет
автоматически выбирать возможное значение и запоминать, что он выбрал.
Если впоследствии какое-либо требование не будет выполнено,
интерпретатор попробует другой вариант выбора и будет перебирать варианты,
пока вычисление не закончится успешно или пока варианты не иссякнут.
Подобно тому, как ленивый интерпретатор освобождал
программиста от заботы о деталях задержки и
вынуждения значений, недетерминистский интерпретатор позволяет ему
не заботиться о том, как происходит выбор.

Поучительно будет сравнить различные понятия \index{ru}{время|в 
недетерминистских вычислениях||||}времени,
складывающиеся при недетерминистских вычислениях и обработке потоков.  При 
обработке  потоков ленивые вычисления используются для того, чтобы устранить
связь между временем, когда строится поток возможных ответов, и
временем, когда порождаются собственно ответы. Интерпретатор
создает иллюзию, что все возможные ответы предоставлены нам во
вневременной последовательности.  При недетерминистских вычислениях
выражение представляет собой исследование множества возможных миров, каждый
из которых определяется множеством выбранных вариантов.  Некоторые
возможные миры приводят в тупик, другие дают полезные ответы.
Вычислитель недетерминистских программ создает иллюзию, что время
разветвляется, и что у наших программ есть различные возможные истории
исполнения.  Если мы оказываемся в тупике, мы можем вернуться к
последней точке выбора и продолжить путь по другой ветке.

Описываемый в этом разделе интерпретатор недетерминистских
программ называется {\tt amb}-интерпретатор, потому что он
основан на новой особой форме {\tt amb}.  Мы можем ввести
вышеприведенное определение {\tt prime-sum-pair} в управляющем
цикле {\tt amb}-интерпретатора (наряду с определениями
{\tt prime?}, {\tt an-element-of} и
{\tt require}) и запустить процедуру:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод Amb-Eval:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{(3 20)}
\end{Verbatim}
Возвращенное значение было получено после того, как интерпретатор
сделал несколько попыток выбора из каждого списка, последняя из которых
оказалась успешной.

В разделе~\ref{AMB-AND-SEARCH} вводится форма
{\tt amb} и показывается, как она поддерживает недетерминизм
через механизм поиска, встроенный в интерпретатор.  В 
разделе~\ref{EXAMPLES-OF-NONDETERMINISTIC-PROGRAMS} приводятся
примеры недетерминистских программ, а 
раздел~\ref{IMPLEMENTING-THE-AMB-EVALUATOR} содержит подробности того,
как реализовать {\tt amb}-интерпретатор путем модификации
обычного интерпретатора Scheme.

\subsection{{\tt Amb} и {\tt search} }
\label{AMB-AND-SEARCH}%


Чтобы расширить Scheme и поддержать недетерминистское
программирование, мы вводим новую особую форму
{\tt amb}\index{ru}{amb||||pd|}\footnote{Идея недетерминистского
  программирования с помощью {\tt amb}-выражений впервые была описана
  Джоном Маккарти в 1961 году (см.~McCarthy 1967).\index{ru}{Маккарти, 
Джон||John McCarthy||n|п}\index{en}{John McCarthy||Маккарти, Джон||n|п}}.
Выражение 
{\tt (amb \textit{$\langle$e${}_{\mbox{1}}$$\rangle$} \textit{$\langle$e${}_{\mbox{2}}$$\rangle$} ... \textit{$\langle$e${}_{\mbox{n}}$$\rangle$})}
возвращает <<произвольным образом>> значение одного из 
$n$ выражений \textit{$\langle$e${}_{\mbox{i}}$$\rangle$}.
Например, выражение

\begin{Verbatim}[fontsize=\small]
(list (amb 1 2 3) (amb 'a 'b))
\end{Verbatim}
имеет шесть возможных значений:

\begin{tabular}{llllll}
{\tt (1 a)} & {\tt (1 b)} & {\tt (2 a)} & {\tt (2 b)} & {\tt (3 a)} & {\tt (3 b)}
\end{tabular}\\
{\tt Amb} с одним вариантом возвращает обыкновенное (одно)
значение.

{\tt Amb} без вариантов~--- выражение
{\tt (amb)}~--- является выражением без приемлемых значений.
С операционной точки зрения, выполнение выражения {\tt (amb)} приводит к
<<неудаче>> в вычислении:\index{ru}{неудача, в недетерминистском 
вычислении||fai\-lure in non\-de\-ter\-mi\-nis\-tic com\-pu\-ta\-tion|||}\index{en}{failure in
  nondeterministic com\-pu\-ta\-tion||неудача, в недетерминистском вычислении|||}
выполнение обрывается, и никакого значения не 
возвращается.  При помощи этого выражения можно следующим образом
выразить требование, чтобы выполнялось предикатное выражение
{\tt p}:

\begin{Verbatim}[fontsize=\small]
(define (require p)  \index{ru}{require||||pd|}
  (if (not p) (amb)))
\end{Verbatim}

Через {\tt amb} и {\tt require} можно
реализовать процедуру {\tt an-element-of}, используемую выше:

\begin{Verbatim}[fontsize=\small]
(define (an-element-of items)\index{ru}{an-element-of||||pd|}
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
\end{Verbatim}
Если список пуст, {\tt an-element-of} терпит неудачу.  В
противном случае он произвольным образом возвращает либо первый элемент
списка, либо элемент, выбранный из хвоста списка.

Можно также выразить выбор из бесконечного множества.
Следующая процедура произвольным образом возвращает целое число,
большее или равное некоторому данному~{\tt n}:

\begin{Verbatim}[fontsize=\small]
(define (an-integer-starting-from n)\index{ru}{an-integer-starting-from||||pd|}
  (amb n (an-integer-starting-from (+ n 1))))
\end{Verbatim}
Это похоже на потоковую процедуру {\tt integers-starting-from},
описанную в разделе~\ref{INFINITE-STREAMS}, но есть важное
различие: потоковая процедура возвращает поток, который представляет
последовательность всех целых чисел, начиная с {\tt n}, а
процедура, написанная через {\tt amb}, выдает одно целое
число\footnote{На самом деле, различие между произвольным выбором с
возвратом единственного значения и возвратом всех возможных значений выбора
определяется в некоторой степени точкой зрения.  С точки зрения того кода, 
который использует значение, недетерминистский выбор возвращает одно
значение.  С точки зрения программиста, проектирующего код,
недетерминистский выбор потенциально возвращает все возможные
значения, а вычисление разветвляется, вследствие чего каждое значение
исследуется отдельно.}.

Мысля абстрактно, мы можем представить, что выполнение выражения
{\tt amb} заставляет  \index{ru}{время|в недетерминистском
  вычислении||||}время разветвиться, и на каждой ветке оно
продолжается с одним из возможных значений выбора. Мы говорим, что
{\tt amb} представляет собой 
\index{ru}{точка недетерминистского выбора||nondeterministic choice 
point|||}\index{en}{nondeterministic choice point||точка 
недетерминистского выбора|||}{\em точку
недетерминистского выбора} (nondeterministic choice point).  Если бы у нас 
была машина с достаточным числом процессоров, которые можно было бы 
динамически выделять, то поиск можно было бы реализовать напрямую.  Выполнение
происходило бы, как в последовательной машине, пока не встретится
выражение {\tt amb}.  В этот момент выделялись и
инициализировались бы дополнительные процессоры, которые продолжали бы
все параллельные потоки выполнения, обусловленные выбором.  Каждый
процессор продолжал бы последовательное выполнение одного из потоков,
как если бы он был
единственным,  пока поток не оборвется, потерпев неудачу, не разделится
сам или не завершится\footnote{Можно возразить, что этот механизм безнадежно
неэффективен.  Чтобы решить какую-нибудь просто сформулированную
задачу таким образом, могут потребоваться миллионы процессоров, и
б\'ольшую часть времени б\'ольшая часть этих процессоров будет ничем не занята.
Это возражение нужно воспринимать в контексте истории.  Память раньше
точно так же считалась дорогим ресурсом.  
\index{ru}{память|в 1964 г.|memory|||п}\index{en}{memory||память|в 1964 
г.||п}В 1964 году мегабайт памяти
стоил 400~000 долларов.  Сейчас в каждом персональном компьютере
имеется много мегабайтов памяти, и б\'ольшую часть времени б\'ольшая часть
этой памяти не используется.  Трудно недооценить стоимость электроники
при массовом производстве.}.

\index{ru}{неудача, в недетерминистских вычислениях|и поиск||||}С другой 
стороны, если у нас есть машина, которая способна
выполнять только один процесс (или небольшое число параллельных процессов),
альтернативы приходится рассматривать последовательно.  Можно
представить себе интерпретатор, который в каждой точке выбора
произвольным образом выбирает, по какой ветке продолжить выполнение.
Однако случайный выбор может легко привести к неудачам.
Можно было бы запускать такой интерпретатор многократно, делая
случайный выбор и надеясь, что в конце концов мы получим требуемое
значение, но лучше проводить 
\index{ru}{поиск|систематический||systematic||}\index{ru}{систематический 
поиск||systematic search|||}\index{en}{systematic search||систематический 
поиск|||}{\em систематический поиск} (systematic search)
среди всех возможных путей выполнения. {\tt Amb}-интерпретатор,
который мы разработаем в этом разделе, реализует систематический поиск
следующим образом: когда интерпретатор встречает выражение
{\tt amb}, он сначала выбирает первый вариант.  Такой выбор
может в дальнейшем привести к другим точкам выбора.  В каждой точке выбора
интерпретатор сначала будет выбирать первый вариант.  Если выбор
приводит к неудаче, интерпретатор 
\index{ru}{автомагически||automagically|||}\index{en}{automagically||автомагически|||}автомагически\footnote{Автомагически:
<<Автоматически, но при этом таким способом,
который говорящий почему-либо (обычно либо из-за его сложности, либо
уродливости, или даже тривиальности) не склонен объяснять>>.
(Steele 1983; Raymond 1993)\index{ru}{Рэймонд, Эрик||Eric 
Raymond||n|п}\index{en}{Eric Raymond||Рэймонд, Эрик||n|п}\index{ru}{Стил, 
Гай Льюис мл.||Guy Lewis Steele Jr.||n|п}\index{en}{Guy Lewis Steele 
Jr.||Стил, Гай Льюис мл.||n|п}}
\index{ru}{возврат||backtracking|||}\index{en}{backtracking||возврат|||}{\em 
возвращается} (backtracks) к последней точке выбора и
пробует следующий вариант.  Если в какой-то точке выбора варианты
исчерпаны, интерпретатор возвращается к предыдущей точке выбора и
продолжает оттуда.  Такой процесс реализует стратегию поиска, которую
называют
\index{ru}{поиск|в 
глубину|search|depth-first||}\index{en}{search|depth-first|поиск|в 
глубину||}{\em поиск в глубину} (depth-first search) или
\index{ru}{поиск с
возвратом|хронологический|backtracking|chronological||}\index{en}{backtracking|chronological|поиск 
с возвратом|хронологический||}{\em хронологический поиск с возвратом} 
(chronological backtracking)\footnote{\label{F4.47}У встраивания %
стратегий автоматического поиска в языки
программирования долгая и пестрая \index{ru}{автоматический 
поиск|история|automatic search|||п}\index{en}{automatic 
search||автоматический поиск|история||п}история.  Первые предположения, что
недетерминистские алгоритмы можно изящно реализовать в языке
программирования с поиском и автоматическим возвратом, высказывались
Робертом Флойдом (Floyd 1967).\index{ru}{Флойд, Роберт||Robert 
Floyd||n|п}\index{en}{Robert Floyd||Флойд, Роберт||n|п}
Карл Хьюитт 
(Hewitt 1969)\index{ru}{Хьюитт, Карл Эдди||Carl Eddie 
Hewitt||n|п}\index{en}{Carl Eddie Hewitt||Хьюитт, Карл Эдди||n|п} 
изобрел язык программирования \index{ru}{Planner (Плэнер)|||||п}Плэнер 
(Planner),
который явным образом поддерживал автоматический хронологический поиск
в возвратом, обеспечивая встроенную стратегию поиска в глубину.
Сассман,\index{ru}{Сассман, Джеральд Джей||Gerald Jay 
Sussman||n|п}\index{en}{Gerald Jay Sussman||Сассман, Джеральд Джей||n|п}
Виноград\index{ru}{Виноград, Терри||Terry Winograd||n|п}\index{en}{Terry 
Winograd||Виноград, Терри||n|п}
и Чарняк\index{ru}{Чарняк, Юджин||Eugene Charniak||n|п}\index{en}{Eugene 
Charniak||Чарняк, Юджин||n|п}
(Sussman, Winograd, and Charniak 1971) 
реализовали
подмножество этого языка, названное ими \index{ru}{MicroPlanner 
(МикроПлэнер)|||||п}МикроПлэнер (MicroPlanner), которое
использовалось в работе по автоматическому решению задач и планированию действий
роботов.  Похожие идеи, основанные на логике и доказательстве теорем,
привели к созданию в Эдинбурге и Марселе изящного языка \index{ru}{Prolog 
(Пролог)|||||п}Пролог (Prolog)
(который мы обсудим в разделе~\ref{LOGIC-PROGRAMMING}).
Разочаровавшись в автоматическом поиске, Макдермот и Сассман 
(McDermott and Sussman 1972)\index{ru}{Макдермот, Дрю||Drew 
McDermott||n|п}\index{en}{Drew McDermott||Макдермот, Дрю||n|п} разработали 
язык \index{ru}{Conniver (Коннивер)|||||п}Коннивер
(Conniver), в котором имелись механизмы, позволявшие программисту
управлять стратегией поиска.  Однако это оказалось слишком громоздким,
и Сассман и Столлман (Sussman and Stallman 1975)\index{ru}{Столлман, 
Ричард~М.||Richard~M. Stallman||n|п}\index{en}{Richard~M. 
Stallman||Столлман, Ричард~М.||n|п}
нашли более удобный в обращении подход, когда исследовали методы 
символьного анализа электрических
цепей.  Они разработали схему нехронологического поиска с возвратом,
которая была основана на отслеживании логических зависимостей,
связывающих факты, и стала известна как метод 
\index{ru}{поиск с возвратом|управляемый 
зависимостями|backtracking|dependency-directed||п}\index{en}{backtracking|dependency-directed|поиск 
с возвратом|управляемый зависимостями||п}{\em поиска с возвратом, управляемого
зависимостями} (dependency-directed backtracking).  При всей своей
сложности, их метод
позволял строить достаточно эффективные программы, так как почти не
проводилось излишнего поиска. Дойл (Doyle 1979)\index{ru}{Дойл, Джон||Jon 
Doyle||n|п}\index{en}{Jon Doyle||Дойл, Джон||n|п}
и Макаллестер (McAllester 1978;
McAllester 1980)\index{ru}{Макаллестер, Дэвид Аллен||David Allen 
McAllester||n|п}\index{en}{David Allen McAllester||Макаллестер, Дэвид 
Аллен||n|п} обобщили и сделали более ясными идеи
Столлмана и Сассмана, разработав новую парадигму для формулирования
поиска, называемую сейчас \index{ru}{поддержание истины||truth 
maintenance|||п}\index{en}{truth maintenance||поддержание истины|||п}{\em 
поддержание истины} (truth maintenance).
Все современные системы решения задач основаны на какой-либо форме
поддержания истины.  У Форбуса и де Клеера 
(Forbus and deKleer 1993)\index{ru}{Форбус, Кеннет~Д.||Kenneth~D. 
Forbus||n|п}\index{en}{Kenneth~D. Forbus||Форбус, 
Кеннет~Д.||n|п}\index{ru}{де Клеер, Йохан||Johan 
deKleer||n|п}\index{en}{Johan deKleer||де Клеер, Йохан||n|п} 
можно найти обсуждение изящных способов строить системы с поддержанием
истины и приложения, в которых используется поддержание истины. 
Заби,\index{ru}{Заби, Рамин||Ramin Zabih||n|п}\index{en}{Ramin 
Zabih||Заби, Рамин||n|п} 
Макаллестер 
и Чепман\index{ru}{Чепман, Дэвид||David Chapman||n|п}\index{en}{David 
Chapman||Чепман, Дэвид||n|п}
(Zabih, McAllester, and Chapman 1987)
описывают недетерминистское расширение Scheme, основанное на
{\tt amb}; оно похоже на интерпретатор, обсуждаемый в этом
разделе, но более сложно, поскольку использует поиск с возвратом,
управляемый зависимостями, а не хронологический. Уинстон (Winston 
1992)\index{ru}{Уинстон, Патрик Генри||Patrick Henry 
Winston||n|п}\index{en}{Patrick Henry Winston||Уинстон, Патрик Генри||n|п}
дает введение в обе разновидности поиска с возвратом.}.

\paragraph{Управляющий цикл}


\index{ru}{управляющий цикл|в  недетерминистском 
интерпретаторе||||}Управляющий цикл {\tt amb}-интерпретатора не
совсем обычен.  Он считывает выражение и печатает значение первого
успешного вычисления, как в примере с {\tt prime-sum-pair} в
начале раздела.  Если нам хочется увидеть значение следующего
успешного выполнения, мы можем попросить интерпретатор вернуться и
попробовать породить значение следующего успешного выполнения.  Для
этого нужно ввести символ \index{ru}{try-again||||pd|}{\tt try-again}.  Если
вводится какое-то другое выражение, а не {\tt try-again},
интерпретатор начнет решать новую задачу, отбрасывая неисследованные
варианты предыдущей.  Вот пример работы с интерпретатором:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод Amb-Eval:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{(3 20)}

\textit{;;; Ввод Amb-Eval:}
try-again
\textit{;;; Значение Amb-Eval:}
\textit{(3 110)}

\textit{;;; Ввод Amb-Eval:}
try-again
\textit{;;; Значение Amb-Eval:}
\textit{(8 35)}

\textit{;;; Ввод Amb-Eval:}
try-again
\textit{;;; Нет больше значений}
\textit{(prime-sum-pair (quote (1 3 5 8))  (quote (20 35 110)))}

\textit{;;; Ввод Amb-Eval:}
(prime-sum-pair '(19 27 30) '(11 36 58))
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{(30 11)}
\end{Verbatim}

\begin{exercise}{4.35}%
\label{EX4.35}%
Напишите процедуру {\tt an-integer-between},
которая возвращает целое число, лежащее между двумя заданными
границами.  С ее помощью можно следующим образом реализовать процедуру
для поиска \index{ru}{недетерминистские программы|Пифагоровы 
тройки||||(упр.~4.35)}\index{ru}{Пифагоровы тройки|в недетерминистских     
программах|Pythagorean triples|||(упр.~4.35)}\index{en}{Pythagorean 
triples||Пифагоровы тройки|в недетерминистских     
программах||(упр.~4.35)}Пифагоровых троек, то есть троек чисел $(i, j, k)$ 
между заданными границами, таких, что $i \leq j$ и 
$i^2 + j^2 = k^2$:

\begin{Verbatim}[fontsize=\small]
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
\end{Verbatim}
\end{exercise}

\begin{exercise}{4.36}\label{EX4.36}%
В упражнении~\ref{EX3.69} рассматривалась
задача порождения потока {\em всех} \index{ru}{недетерминистские 
программы|Пифагоровы тройки||||(упр.~4.36)}\index{ru}{Пифагоровы тройки|в 
недетерминистских программах||||(упр.~4.36)}Пифагоровых троек, без
всякой верхней границы диапазона целых чисел, в котором надо искать.
Объясните, почему простая замена {\tt an-integer-between} на
{\tt an-integer-starting\-from} в процедуре из %HERE361
упражнения~\ref{EX4.35} не является адекватным способом порождения
произвольных Пифагоровых троек.  Напишите процедуру, которая решает
эту задачу. (Это значит, что Вам нужно написать процедуру, для которой
многократный запрос {\tt try-again} в принципе способен
породить все Пифагоровы тройки.)
\end{exercise}

\begin{exercise}{4.37}%
\label{EX4.37}%
Бен Битобор утверждает, что следующий метод порождения
\index{ru}{недетерминистские программы|Пифагоровы  тройки||||(упр.~4.37)} 
\index{ru}{Пифагоровы тройки|в недетерминистских 
программах||||(упр.~4.37)}Пифагоровых троек
эффективнее, чем приведенный в 
упражнении~\ref{EX4.35}.  Прав ли он?  (Подсказка: найдите, сколько
вариантов требуется рассмотреть.)

\begin{Verbatim}[fontsize=\small]
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
\end{Verbatim}
\end{exercise}

\subsection{Примеры недетерминистских программ}
\label{EXAMPLES-OF-NONDETERMINISTIC-PROGRAMS}%

В разделе~\ref{IMPLEMENTING-THE-AMB-EVALUATOR}
описывается реализация {\tt amb}-интерпретатора.  Однако
для начала мы приведем несколько примеров его использования.
Преимущество недетерминистского программирования
состоит в том, что можно отвлечься от деталей процесса
поиска, а следовательно, выражать программы на более высоком уровне
абстракции.\index{ru}{абстракция|поиска в недетерминистском 
программировании||||}

\paragraph{Логические загадки}


\index{ru}{логические загадки||logic     puzzles|||}\index{en}{logic     
puzzles||логические загадки|||}\index{ru}{недетерминистские 
программы|логические 
загадки||||}\index{ru}{загадки|логические||||}Следующая задача (взятая из 
Dinesman 1968)\index{ru}{Дайнсман, Говард~П.||Howard~P. 
Dinesman||n|}\index{en}{Howard~P. Dinesman||Дайнсман, Говард~П.||n|}
--- типичный представитель большого класса простых логических
загадок.
\begin{quote}
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах
пятиэтажного дома.  Бейкер живет не на верхнем этаже.  Купер живет не
на первом этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже.
Миллер живет выше Купера. Смит живет не на соседнем с Флетчером этаже.
Флетчер живет не на соседнем с Купером этаже.  Кто где живет?
\end{quote}

Можно впрямую определить, кто на каком этаже живет,
перечислив все возможности и наложив данные нам ограничения\footnote{В 
нашей программе используется следующая процедура,
определяющая, все ли элементы списка отличны друг от друга:

\begin{Verbatim}
(define (distinct? items)\index{ru}{distinct?||||pd|п}
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
\end{Verbatim}
Процедура {\tt member}\index{ru}{member||||p|п}
подобна {\tt memq}, но
на равенство проверяет с помощью {\tt equal?}, а не
{\tt eq?}.}.

\begin{Verbatim}[fontsize=\small]
(define (multiple-dwelling)\index{ru}{multiple-dwelling||||pd|}
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
\end{Verbatim}

Выполнение выражения {\tt (multiple-dwelling)}
дает следующий результат:

\begin{Verbatim}[fontsize=\small]
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
\end{Verbatim}
Эта простая процедура работает, но работает очень медленно.  В
упражнениях~\ref{EX4.39} и \ref{EX4.40}
обсуждаются возможные улучшения.

\begin{exercise}{4.38}%
\label{EX4.38}%
Измените процедуру {\tt multiple-dwelling},
отказавшись от требования, что Смит и Флетчер живут не на соседних
этажах.  Сколько решений имеется у измененной загадки?
\end{exercise}

\begin{exercise}{4.39}%
\label{EX4.39}%
Влияет ли порядок ограничений в процедуре
{\tt multiple-dwelling} на ответ?  Влияет ли он на время,
необходимое для поиска ответа?  Если Вы считаете, что он имеет
значение, то покажите, как можно ускорить программу, переупорядочив
ограничения.  Если Вы считаете, что порядок значения не имеет,
объясните, почему.
\end{exercise}

\begin{exercise}{4.40}%
\label{EX4.40}%
Сколько возможных соответствий между людьми и этажами
имеется в задаче о проживании, если учитывать требование, что все
живут на разных этажах, и если его не учитывать?  Крайне неэффективно
порождать все возможные соответствия между людьми и этажами, а
затем полагаться на то, что поиск с возвратом отсечет лишнее.
Например, большая часть ограничений зависит только от одной или двух
переменных, соответствующих людям, и их можно было бы проверять раньше, чем
этажи выбраны для всех действующих лиц.  Напишите и продемонстрируйте значительно
более эффективную недетерминистскую процедуру, которая бы решала задачу,
порождая только те варианты, которые еще не исключены благодаря предыдущим
ограничениям. (Подсказка: потребуется набор вложенных выражений
{\tt let}.)
\end{exercise}

\begin{exercise}{4.41}%
\label{EX4.41}%
\index{ru}{недетерминистское программирование vs. программирование на Scheme|||||(упр.~4.41)}%
Напишите процедуру для решения задачи о проживании на обычной Scheme.
\end{exercise}

\begin{exercise}{4.42}%
\label{EX4.42}%
Решите задачу <<Лгуньи>> (из Phillips 1934):\index{ru}{Филипс, 
Хьюберт||Hubert Phillips||n|(упр.~4.42)}\index{en}{Hubert 
Phillips||Филипс, Хьюберт||n|(упр.~4.42)} %MLR% Поискать в сети русский перевод.

\begin{quote}
Пять школьниц писали экзаменационную работу.  Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что каждая
девочка должна написать домой о результатах экзамена и при этом
сделать одно верное и одно неверное утверждение.  Вот соответствующие
выдержки из их писем:

Бетти: <<Китти была на экзамене второй, а я только третьей>>.

Этель: <<Вам будет приятно узнать, что я написала
лучше всех.  Второй была Джоан>>.

Джоан: <<Я была третьей, а бедная Этель последней>>.

Китти: <<Я оказалась второй.  Мэри была только четвертой>>.

Мэри: <<Я была четвертой. Первое место заняла Бетти>>.

В каком порядке на самом деле расположились отметки девочек?
\end{quote}
\end{exercise}

\begin{exercise}{4.43}%
\label{EX4.43}%
Решите с помощью {\tt amb}-интерпретатора
следующую задачу\footnote{Задача взята из книжки <<Занимательные загадки>>,
опубликованной в 60-е годы издательством Литтон Индастриз.  Книжка
приписывает задачу газете <<Кэнзас стейт энджинир>>.}.%MLR% Тоже поискать перевод.

\begin{quote}
У отца Мэри Энн Мур есть яхта, и у каждого из четверых его
друзей тоже.  Эти четверо друзей~--- полковник Даунинг, мистер Холл,
сэр Барнакл Худ и доктор Паркер.  У каждого из них тоже есть по
дочери, и каждый из них назвал свою яхту в честь дочери одного из
своих друзей.  Яхта сэра Барнакла называется Габриэлла, яхта мистера
Мура~--- Лорна, а у мистера Холла яхта Розалинда.  Мелисса, яхта
полковника Даунинга, названа в честь дочери сэра Барнакла.  Отец
Габриэллы владеет яхтой, названной в честь дочери доктора Паркера.
Кто отец Лорны?
\end{quote}
Попытайтесь написать программу так, чтобы она работала эффективно
(см. упражнение~\ref{EX4.40}).  Кроме того, определите,
сколько будет решений, если не указывается, что фамилия Мэри Энн~---
Мур.
\end{exercise}

\begin{exercise}{4.44}%
\label{EX4.44}%
\index{ru}{недетерминистское программирование vs. программирование на Scheme|||||(упр.~4.44)}%
В упражнении~\ref{EX2.42} описывалась
\index{ru}{шахматы, задача о восьми 
ферзях|||||(упр.~4.44)}\index{ru}{задача о восьми 
ферзях|||||(упр.~4.44)}\index{ru}{загадки|задача о восьми 
ферзях||||(упр.~4.44)}<<задача о восьми ферзях>>, в которой требуется 
расставить на
шахматной доске восемь ферзей так, чтобы ни один не бил другого.
Напишите недетерминистскую программу для решения этой задачи.
\end{exercise}

\paragraph{Синтаксический анализ естественного языка}

\index{ru}{недетерминистские программы|синтаксический анализ естественного 
языка||||}Программы, которые должны принимать на входе естественный
язык, обычно прежде всего пытаются провести 
\index{ru}{синтаксический анализ естественного 
языка||parsing|||}\index{en}{parsing||синтаксический анализ естественного 
языка|||}{\em синтаксический анализ} (parsing) ввода, то есть сопоставить 
входному тексту какую-то грамматическую
структуру.  Например, мы могли бы попытаться распознавать простые
предложения, состоящие из артикля, за которым идет существительное, а
вслед за ними глагол, например {\em The cat eats} (<<Кошка ест>>).  Чтобы
выполнять такой анализ, нам нужно уметь определять части речи, к
которым относятся отдельные слова.  Мы можем для начала составить
несколько списков, которые задают классы слов\footnote{Здесь мы 
используем соглашение, что первый элемент
списка обозначает часть речи, к которой относятся остальные слова
списка.}:

\begin{Verbatim}[fontsize=\small]
(define nouns '(noun student professor cat class))

(define verbs '(verb studies lectures eats sleeps)) \index{ru}{verbs||||pd|}

(define articles '(article the a))\index{ru}{articles||||pd|}
\end{Verbatim}
Нам также нужна 
\index{ru}{грамматика||grammar|||}\index{en}{grammar||грамматика|||}{\em 
грамматика} (grammar), то есть
набор правил, которые описывают, как элементы грамматической структуры
составляются из меньших элементов.  Простейшая грамматика может
постановить, что предложение всегда состоит из двух частей~--- именной
группы, за которой следует глагол,~--- и что именная группа состоит из
артикля и имени существительного.  С такой грамматикой предложение
{\em The cat eats} разбирается так:

\begin{Verbatim}[fontsize=\small]
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
\end{Verbatim}

Мы можем породить такой разбор при помощи простой
программы, в которой для каждого грамматического правила имеется своя
процедура.  Чтобы разобрать предложение, мы определяем две его
составные части и возвращаем список из этих элементов, помеченный
символом {\tt sentence}:\index{ru}{parse-\ldots||||p|}

\begin{Verbatim}[fontsize=\small]
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
\end{Verbatim}
Подобным образом, разбор именной группы состоит в поиске артикля и
существительного:

\begin{Verbatim}[fontsize=\small]
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
\end{Verbatim}

На самом нижнем уровне разбор сводится к многократной
проверке, является ли следующее неразобранное слово элементом списка
слов для данной части речи.  Чтобы реализовать это, мы заводим
глобальную переменную {\tt *unparsed*}, содержащую еще
неразобранный ввод. Каждый раз, проверяя слово, мы требуем,
чтобы {\tt *unparsed*} не была пустым списком и чтобы ее
значение начиналось со слова из указанного списка.  Если это так, мы
убираем слово из {\tt *unparsed*} и возвращаем его вместе с
частью речи (которую можно найти в голове списка)\footnote{Обратите 
внимание, что {\tt parse-word}
изменяет список необработанных слов при помощи {\tt set!}.  Для
того, чтобы это работало, 
{\tt amb}-интерпретатор при возврате должен отменять действия операций
{\tt set!}.}.

\begin{Verbatim}[fontsize=\small]
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
\end{Verbatim}

Чтобы запустить разбор, нужно только присвоить переменной
{\tt *unparsed*} весь имеющийся ввод, попытаться
проанализировать предложение и убедиться, что ничего не осталось в
конце:

\begin{Verbatim}[fontsize=\small]
(define *unparsed* '())

(define (parse input)\index{ru}{parse||||pd|}
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*))
    sent))
\end{Verbatim}

Теперь мы можем опробовать анализатор и убедиться, что он
работает на нашем простом примере:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод Amb-Eval:}
(parse '(the cat eats))
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}
\end{Verbatim}

{\tt Amb}-интерпретатор здесь удобно использовать потому,
что ограничения на разбор легко выражаются при помощи
{\tt require}. Однако по-настоящему достоинства автоматического поиска
с возвратом проявляются тогда, когда мы обращаемся
к более сложным грамматикам, где имеются варианты декомпозиции
единиц.

Добавим к грамматике список предлогов:

\begin{Verbatim}[fontsize=\small]
(define prepositions '(prep for to in by with))\index{ru}{prepositions||||pd|}
\end{Verbatim}
и определим предложную группу (например, {\em for the cat},
<<для кошки>>) как последовательность из предлога и именной группы:

\begin{Verbatim}[fontsize=\small]
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
\end{Verbatim}
Теперь мы можем сказать, что предложение~--- это именная группа, за
которой следует глагольная группа, а глагольная группа~--- это либо
глагол, либо глагольная группа, дополненная предложной
группой\footnote{Заметим, что это определение рекурсивно~--- за
глаголом может следовать любое число предложных групп.}:

\begin{Verbatim}[fontsize=\small]
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-verb-phrase)))

(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list 'verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
\end{Verbatim}

Раз уж мы занялись этим делом, можно также уточнить определение именной группы и
разрешить выражения вроде {\em a cat in the class} (<<кошка в
аудитории>>).  То, что раньше называлось именной группой, теперь мы
будем называть простой именной группой, а именная группа теперь может
быть либо простой именной группой, либо именной группой, которая
дополняется предложной группой:

\begin{Verbatim}[fontsize=\small]
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))

(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend (list 'noun-phrase
                             noun-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
\end{Verbatim}

Обновленная грамматика позволяет разбирать более
сложные предложения.  Например,

\begin{Verbatim}[fontsize=\small]
(parse '(the student with the cat sleeps in the class))
\end{Verbatim}
(<<студент с кошкой спит в аудитории>>) дает

\begin{Verbatim}[fontsize=\small]
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase (prep in)
               (simple-noun-phrase
                (article the) (noun class)))))
\end{Verbatim}

Заметим, что входное предложение может иметь более одного
законного анализа.  В предложении {\em The professor lectures to the
student with the cat} (<<Профессор читает лекцию студенту с
кошкой>>) может иметься в виду, что профессор вместе с кошкой читают
лекцию, или что кошка~--- у студента.  Наша недетерминистская
программа находит оба варианта:

\begin{Verbatim}[fontsize=\small]
(parse '(the professor lectures to the student with the cat))
\end{Verbatim}
дает

\begin{Verbatim}[fontsize=\small]
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase (prep to)
                (simple-noun-phrase
                 (article the) (noun student))))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat)))))
\end{Verbatim}
Если попросить интерпретатор поискать еще, получится

\begin{Verbatim}[fontsize=\small]
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase (prep to)
               (noun-phrase
                (simple-noun-phrase
                 (article the) (noun student))
                (prep-phrase (prep with)
                             (simple-noun-phrase
                              (article the) (noun cat)))))))
\end{Verbatim}

\begin{exercise}{4.45}%
\label{EX4.45}%
Согласно заданной выше грамматике, следующее
предложение можно проанализировать пятью различными способами:
{\em The professor lectures to the student in the class with the
cat}
(<<Профессор читает лекцию студенту в аудитории с кошкой>>). Покажите эти
пять разборов и объясните разницу в оттенках значения между ними.
\end{exercise}

\begin{exercise}{4.46}%
\label{EX4.46}%
\index{ru}{недетерминистский интерпретатор|порядок вычисления операндов||||(упр.~4.46)}%
Интерпретаторы в
разделах~\ref{THE-METACIRCULAR-EVALUATOR} и
\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION} не
определяют, в каком порядке вычисляются операнды при вызове
процедуры.  Мы увидим, что {\tt amb}-интерпретатор вычисляет их
слева направо. Объясните, почему программа разбора не стала бы
работать, если бы операнды вычислялись в каком-нибудь другом
порядке.
\end{exercise}

\begin{exercise}{4.47}%
\label{EX4.47}%
Хьюго Дум говорит, что поскольку глагольная группа
--- это либо глагол, либо глагольная группа плюс предложная группа,
было бы намного естественнее определить процедуру
{\tt parse-verb-phrase} так (и то же сделать для именных
групп):

\begin{Verbatim}[fontsize=\small]
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
\end{Verbatim}
Работает ли этот вариант?  Изменится ли поведение программы, если мы
поменяем местами выражения в {\tt amb}?
\end{exercise}

\begin{exercise}{4.48}%
\label{EX4.48}%
Дополните описанную выше грамматику так, чтобы она
могла работать с более сложными предложениями.  Например, можно
позволить именным и глагольным группам включать прилагательные и
наречия, или же можно обрабатывать сложные 
предложения\footnote{\index{ru}{синтаксический анализ естественного 
языка|настоящая обработка языка vs. игрушечный анализатор||||п}Грамматики 
такого рода могут быть сколь угодно
сложными, но по сравнению с настоящей обработкой естественного языка
они остаются игрушкой.  Настоящее понимание естественного языка
компьютером требует сложного сочетания синтаксического анализа с
интерпретацией значения.  С другой стороны, даже простые анализаторы
могут быть полезны для поддержки гибких командных языков в программах
вроде систем поиска информации. Уинстон (Winston 1992)\index{ru}{Уинстон, 
Патрик Генри||Patrick Henry Winston||n|п}\index{en}{Patrick Henry 
Winston||Уинстон, Патрик Генри||n|п}
описывает вычислительные подходы к пониманию настоящего естественного
языка, а также применение простых грамматик в командных языках.}.
\end{exercise}

\begin{exercise}{4.49}%
\label{EX4.49}%
Лизу П.~Хакер больше интересует не анализ
предложений, а их 
\index{ru}{порождение предложений||generating 
sentences|||(упр.~4.49)}\index{en}{generating sentences||порождение 
предложений|||(упр.~4.49)}порождение.  Она замечает, что если изменить
процедуру {\tt parse-word} так, чтобы она игнорировала
<<входное предложение>>, всегда заканчивалась успехом и порождала
подходящее слово, мы сможем использовать те же программы, которые мы
написали для анализа, для порождения предложений.  Реализуйте идею Лизы и
покажите первые пять-шесть порожденных предложений\footnote{Несмотря на 
то, что идея Лизы (будучи
удивительно простой) дает результат, порождаемые предложения оказываются 
довольно скучными~--- они не отображают возможные предложения нашего языка
никаким интересным образом.  Дело в том, что грамматика рекурсивна во
многих местах, а метод Лизы <<проваливается>> в одну из рекурсий и
там застревает.  Как с этим можно бороться, Вы увидите в 
упражнении~\ref{EX4.50}.}.
\end{exercise}

\subsection{Реализация {\tt amb}-интерпретатора}
\label{IMPLEMENTING-THE-AMB-EVALUATOR}%

\index{ru}{недетерминистский интерпретатор||nondeterministic 
evaluator|||}\index{en}{nondeterministic evaluator||недетерминистский 
интерпретатор|||}Выполнение выражения в обыкновенной Scheme может вернуть
результат, может вообще не завершиться, и, наконец, может закончиться сообщением
об ошибке.  В недетерминистской Scheme при выполнении выражения, в
дополнение ко всему этому, может еще обнаружиться тупик, и
в этом случае вычисление должно откатиться к предыдущей точке выбора.
Интерпретация недетерминистской Scheme осложняется из-за этой дополнительной
возможности.

Мы построим {\tt amb}-интерпретатор для
недетерминистской Scheme, модифицировав
\index{ru}{анализирующий интерпретатор|как основа для недетерминистского 
интерпретатора||||}анализирующий интерпретатор из
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}\footnote{В 
разделе~\ref{VARIATIONS-ON-A-SCHEME-LAZY-EVALUATION}
мы решили реализовать ленивый интерпретатор как модификацию
обыкновенного метациклического интерпретатора из 
раздела~\ref{THE-CORE-OF-THE-EVALUATOR}.  Напротив, здесь в основу
{\tt amb}-интерпретатора мы кладем анализирующий
интерпретатор из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION},
поскольку исполнительные процедуры этого интерпретатора служат удобной
базой для реализации поиска с возвратом.}.
Как и в анализирующем интерпретаторе, вычисление выражения происходит
путем вызова \index{ru}{исполнительная процедура|в недетерминистском  
вычислителе||||}исполнительной процедуры, которая
получается при анализе 
этого выражения.  Разница между интерпретацией обыкновенной Scheme и
недетерминистской Scheme будет полностью сводиться к исполнительным
процедурам.

\paragraph{Исполнительные процедуры и продолжения}

Напомним, что исполнительные процедуры обыкновенного
интерпретатора принимают один аргумент: окружение, в котором
происходит вычисление выражения.   \index{ru}{исполнительная процедура|в 
недетерминистском  вычислителе||||}В
противоположность этому, исполнительные процедуры
{\tt amb}-интерпретатора принимают три аргумента: окружение и
две процедуры, называемые  \index{ru}{продолжение|в недетерминистском
  интерпретаторе|continuation|||}\index{en}{continuation||продолжение|в 
недетерминистском интерпретаторе||}{\em процедурами продолжения} 
(continuation procedures).
Вычисление выражения будет заканчиваться вызовом одного из этих 
продолжений:
если результатом вычисления является значение, то зовется
\index{ru}{продолжение успеха||success continuation|||}\index{en}{success 
continuation||продолжение успеха|||}{\em продолжение успеха} (success 
continuation) с этим
значением в качестве аргумента; если вычисление натыкается на тупик,
вызывается \index{ru}{продолжение неудачи||failure 
continuation|||}\index{en}{failure continuation||продолжение 
неудачи|||}{\em продолжение
неудачи} (failure continuation).  Построение и вызов соответствующих 
продолжений служит
механизмом, с помощью которого в недетерминистском интерпретаторе
реализуется поиск с возвратом.

Задача продолжения успеха~--- принять значение и
продолжить вычисление.  Помимо этого значения, продолжение успеха
получает дополнительное продолжение неудачи, которое нужно будет вызвать,
если использование значения приведет в тупик.

Задача продолжения неудачи~--- попробовать другую ветвь
недетерминистского процесса.  Главная особенность недетерминистского языка
состоит в том, что выражения могут представлять собой точки выбора между
вариантами.  Выполнение такого выражения должно продолжиться согласно
одному из указанных взаимоисключающих вариантов, несмотря на то, что
заранее неизвестно, какие варианты приведут к приемлемым результатам.
При обработке такой ситуации интерпретатор выбирает один из
вариантов и передает его значение продолжению успеха.  Кроме того,
он строит и передает вместе со значением продолжение неудачи, которое
потом можно вызвать, чтобы рассмотреть другой вариант.

Неудача возникает во время вычисления (то есть, зовется
продолжение неудачи), когда пользовательская программа явным образом
отказывается от
текущего рассматриваемого варианта (например, вызов
{\tt require} может привести к выполнению {\tt (amb)}, а
это выражение всегда терпит неудачу~--- 
см.~раздел~\ref{AMB-AND-SEARCH}).  В этом месте продолжение неудачи
вернет нас к последней по времени точке и оттуда направит по другому
варианту.  Если же в этой точке выбора больше не осталось вариантов, то
запускается неудача в предыдущей точке выбора, и так далее.  Кроме
того, продолжения неудачи запускаются управляющим циклом в ответ на
запрос {\tt try-again}, чтобы найти еще одно значение последнего
выражения.

Помимо того, если на какой-то ветке процесса,
возникшей в результате выбора, происходит операция с побочным эффектом
(например, присваивание переменной), то может понадобиться отменить
побочный эффект, если процесс наткнется на неудачу, прежде чем
будет сделан новый выбор. Этого мы добиваемся, заставив операцию с
побочным эффектом порождать продолжение неудачи, которое отменяет
эффект и отправляет неудачу дальше.

Итак, продолжения неудачи порождаются

\begin{plainlist}
\item
в выражениях {\tt amb}~--- чтобы обеспечить
механизм выбора альтернативных вариантов, если текущий выбор,
сделанный внутри {\tt amb}, приведет к тупику;

\item
в управляющем цикле верхнего уровня~--- чтобы иметь
возможность сообщить о неудаче, когда перебраны все альтернативы;

\item
в присваиваниях~--- чтобы во время отката перехватывать неудачи и
отменять присваивания.
\end{plainlist}

Неудачи возбуждаются только тогда, когда программа
заходит в тупик.  Это происходит

\begin{plainlist}
\item
если пользовательская программа выполняет выражение
{\tt (amb)};

\item
если пользователь печатает {\tt try-again} в
управляющем цикле.
\end{plainlist}

Кроме того, продолжения неудачи вызываются при обработке
неудачи:

\begin{plainlist}
\item
Когда продолжение неудачи, порожденное
присваиванием, заканчивает отмену побочного эффекта, оно вызывает то
предложение неудачи, которое оно само перехватило, и посредством его
отправляет неудачу назад до точки выбора, которая привела к
присваиванию, либо до верхнего уровня.

\item
Когда продолжение неудачи для {\tt amb}
исчерпывает все варианты выбора, оно вызывает продолжение
неудачи, которое изначально было дано {\tt amb}, и посредством его
распространяет неудачу до предыдущей точки выбора, либо до верхнего
уровня.
\end{plainlist}

\paragraph{Структура интерпретатора}

Процедуры представления синтаксиса и данных в
{\tt amb}-интерпретаторе, а также базовая процедура
{\tt analyze}, совпадают с соответствующими процедурами в интерпретаторе из
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION},
только здесь требуются дополнительные синтаксические процедуры для
анализа особой формы {\tt amb}\footnote{Мы предполагаем, что 
интерпретатор поддерживает
{\tt let} (см.~упражнение~\ref{EX4.22}), который мы
использовали в недетерминистских программах.}:

\begin{Verbatim}[fontsize=\small]
(define (amb? exp) (tagged-list? exp 'amb))

(define (amb-choices exp) (cdr exp))
\end{Verbatim}
Кроме того, требуется добавить в процедуру разбора
{\tt analyze} ветку, которая будет распознавать эту особую форму и
порождать соответствующую исполнительную процедуру:

\begin{Verbatim}[fontsize=\small]
((amb? exp) (analyze-amb exp))
\end{Verbatim}

Процедура верхнего уровня {\tt ambeval} (сходная с
версией {\tt eval}, приведенной в 
разделе~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION})
анализирует данное выражение и применяет полученную исполнительную
процедуру к данному окружению и двум данным 
продолжениям:\index{ru}{analyze|недетерминистская|||p|}

\begin{Verbatim}[fontsize=\small]
(define (ambeval exp env succeed fail)\index{ru}{ambeval||||pd|}
  ((analyze exp) env succeed fail))
\end{Verbatim}

\index{ru}{продолжение успеха|||||}Продолжение \index{ru}{продолжение|в 
недетерминистском интерпретаторе||||}успеха представляет собой процедуру 
от двух
аргументов: только что полученного значения и \index{ru}{продолжение 
неудачи|||||}продолжения неудачи,
которое нужно будет применить, если обработка значения впоследствии приведет
к неудаче.  Продолжение неудачи представляет собой процедуру без
аргументов.  Таким образом, общая форма  \index{ru}{исполнительная 
процедура|в  недетерминистском  вычислителе||||}исполнительной процедуры
такова:
 
\begin{Verbatim}[fontsize=\small]
(lambda (env succeed fail)
   {\em ;; {\tt succeed} выглядит как {\tt (lambda (value fail) ...)}}
   {\em ;; {\tt fail} выглядит как {\tt (lambda () ...)}}
   ...)
\end{Verbatim}

Например,

\begin{Verbatim}[fontsize=\small]
(ambeval \textit{$\langle$выражение$\rangle$}
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
\end{Verbatim}
попытается вычислить данное выражение, и вернет либо его значение
(если вычисление будет успешным), либо символ 
{\tt failed} (если вычисление потерпит неудачу).  Вызов
{\tt ambeval} в нижеприведенном управляющем цикле использует
намного более сложные процедуры продолжения, которые возвращаются к 
выполнению цикла и поддерживают запрос {\tt try-again}.

Сложность {\tt amb}-интерпретатора по большей части
заключается в механизмах передачи продолжений, когда исполнительные
процедуры вызывают друг друга.  Читая код в этом разделе, следует
сравнивать каждую исполнительную процедуру с соответствующей процедурой
обыкновенного интерпретатора из 
раздела~\ref{SEPARATING-SYNTACTIC-ANALYSIS-FRON-EXECUTION}.

\paragraph{Простые выражения}


Исполнительные процедуры для простейших видов выражений здесь,
в сущности, такие же, как и в обычном интерпретаторе, не считая
того, что здесь надо уметь управлять продолжениями.  Исполнительные
процедуры просто зовут продолжение успеха, давая ему значение выражения,
и передают дальше продолжение неудачи, которое получили 
сами.\index{ru}{analyze-\ldots|недетерминистские|||p|}
\begin{Verbatim}[fontsize=\small]
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))

(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))

(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
\end{Verbatim}

Заметим, что поиск переменной всегда <<успешен>>.  Если
процедуре {\tt lookup-va\-riable-value} не удается найти
значение, она, как обычно, сообщает об ошибке.\index{ru}{неудача, в 
недетерминистских вычислениях|vs. ошибка||||}
Такая <<неудача>> означает ошибку в программе: ссылку на несвязанную 
переменную; это
не означает, что нам нужно пробовать какой-либо другой вариант
недетерминистского выбора вместо того, который исполняется сейчас.

\paragraph{Условные выражения и последовательности}

Обработка условных выражений также похожа на
соответствующий процесс в обычном интерпретаторе.  Исполнительная процедура,
порождаемая в {\tt analyze-if}, зовет исполнительную процедуру
предиката {\tt pproc} с продолжением успеха, которое, проверив,
истинно ли значение предиката, в соответствии с этим выполняет либо
следствие, либо альтернативу.  Если выполнение {\tt pproc}
терпит неудачу, вызывается исходное продолжение неудачи, переданное в
выражение {\tt if}.

\begin{Verbatim}[fontsize=\small]
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             {\em ;; продолжение успеха при вычислении предиката}
             {\em ;; и получении {\tt pred-value}}
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             {\em ;; продолжение неудачи при вычислении предиката}
             fail))))
\end{Verbatim}

Последовательности тоже обрабатываются так же, как и в
предыдущем интерпретаторе, если не считать махинаций в подпроцедуре
{\tt sequentially}, которые требуются для передачи
продолжений. А именно, чтобы выполнить последовательно {\tt a}
и {\tt b}, мы вызываем {\tt a} с продолжением успеха,
вызывающим~{\tt b}.

\begin{Verbatim}[fontsize=\small]
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         {\em ;; продолжение успеха при вызове {\tt a}}
         (lambda (a-value fail2)
           (b env succeed fail2))
         {\em ;; продолжение неудачи при вызове {\tt a}}
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Пустая последовательность -- ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{Verbatim}

\paragraph{Определения и присваивания}

Определения~--- еще один случай, когда обработка продолжений
сопряжена с известными трудностями, поскольку требуется сначала
вычислить выражение, которое будет значением определяемой переменной,
а затем уже ее собственно определить.  Ради этого процедура
вычисления значения {\tt vproc} вызывается со следующими
аргументами: окружение, продолжение успеха и продолжение неудачи.  Если
вычисление {\tt vproc} происходит успешно и дает значение {\tt val}
для определяемой переменной, то переменная определяется и успех
распространяется далее:

\begin{Verbatim}[fontsize=\small]
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
\end{Verbatim}

\index{ru}{продолжение неудачи|присваивания||||}Присваивания устроены 
интереснее.  Это первый случай,
когда мы действительно используем продолжения, а не просто передаем их из 
процедуры в процедуру.  Исполнительная процедура для присваивания 
начинается так
же, как и процедура для определения.  Сначала она пытается получить новое
значение, которое надо присвоить переменной.  Если вычисление
{\tt vproc} терпит неудачу, неудачно и все присваивание.

Однако если {\tt vproc} выполняется удачно, и мы
действительно выполняем присваивание, то нам нужно рассмотреть
возможность, что текущая ветка вычисления позже, может быть, приведет
к неудаче.
Тогда нам понадобится откатиться к моменту до присваивания.  Таким образом, нам
нужно уметь отменить присваивание в процессе возврата\footnote{Мы не
заботились об отмене определений, поскольку
можно предположить, что 
\index{ru}{внутренние определения|в недетерминистском 
интерпретаторе||||п}внутренние определения изымаются
(раздел~\ref{INTERNAL-DEFINITIONS-CH4}).}.

Этого мы добиваемся, передавая {\tt vproc} продолжение
успеха (отмеченное ниже комментарием <<{\em *1*}>>), которое
сохраняет старое значение переменной, прежде чем присвоить ей новое
значение и продолжить вычисление.  Продолжение неудачи, которое передается 
вместе со значением присваивания (и отмечено ниже комментарием
<<{\em *2*}>>), восстанавливает старое значение
переменной, прежде чем продолжить откат.  То есть, успешное
присваивание дает продолжение неудачи, которое перехватит последующую
неудачу;  неудача, которая в противном случае вызвала бы
{\tt fail2}, вместо этого зовет эту процедуру, а она отменяет
присваивание и уже затем зовет {\tt fail2}.

\begin{Verbatim}[fontsize=\small]
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)         {\em ; *1*}
               (let ((old-value
                      (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    {\em ; *2*}
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
\end{Verbatim}

\paragraph{Вызов процедур}

Исполнительная процедура для вызовов не содержит никаких новшеств,
кроме сложных технических деталей работы с продолжениями.  Сложность
возникает внутри {\tt ana\-lyze-application} и обусловлена
необходимостью следить за продолжениями успеха и неудачи при вычислении
операндов.  Мы вычисляем операнды с помощью процедуры
{\tt get-args}, а не простого {\tt map}, как в
обыкновенном интерпретаторе.

\begin{Verbatim}[fontsize=\small]
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
\end{Verbatim}

Заметьте, как в {\tt get-args} для движения
через {\tt cdr} по списку исполнительных процедур
{\tt aproc} и сборки через {\tt cons} получающегося
списка аргументов  каждая
{\tt aproc} в списке вызывается с продолжением успеха, которое рекурсивно
зовет {\tt get-args}.  Каждый из этих рекурсивных вызовов
{\tt get-args} имеет продолжение успеха, значение которого ---
{\tt cons} свежеполученного аргумента со списком уже
собранных аргументов:

\begin{Verbatim}[fontsize=\small]
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    {\em ;; продолжение успеха для этой {\tt aproc}}
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                {\em ;; продолжение успеха для }
                                {\em ;; рекурсивного вызова {\tt get-args}}
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
\end{Verbatim}

Собственно вызов процедуры, который выполняет
{\tt execute-application}, осуществляется так же, как и
в обыкновенном интерпретаторе, не считая того, что необходимо управлять
продолжениями.

\begin{Verbatim}[fontsize=\small]
(define (execute-application proc args succeed fail)\index{ru}{execute-application|недетерминистская|||pd|}
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
          proc))))
\end{Verbatim}

\paragraph{Выполнение выражений {\tt amb}}


\index{ru}{продолжение неудачи|{\tt amb}||||}Особая форма {\tt amb}~--- 
ключевой элемент
недетерминистского языка.  Здесь лежит сущность процесса интерпретации
и обоснование необходимости отслеживать продолжения.  Исполнительная 
процедура для {\tt amb} определяет цикл {\tt try-next}, который
перебирает исполнительные процедуры для всех возможных значений
выражения {\tt amb}.  Каждая из исполнительных процедур
вызывается с продолжением неудачи, которое попробует выполнить
следующий вариант.  Когда вариантов больше не остается, все выражение
{\tt amb} терпит неудачу.

\begin{Verbatim}[fontsize=\small]
(define (analyze-amb exp)\index{ru}{analyze-amb||||pd|}
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))
\end{Verbatim}

\paragraph{Управляющий цикл}

\index{ru}{управляющий цикл|в  недетерминистском 
интерпретаторе||||}\index{ru}{продолжение неудачи|управляющий 
цикл||||}Управляющий цикл {\tt amb}-интерпретатора сложен
из-за наличия механизма, позволяющего пользователю заново попытаться выполнить
выражение.  Цикл использует процедуру {\tt internal-loop},
которая в качестве аргумента принимает процедуру
{\tt try-again}.  Наш замысел состоит в том, чтобы вызов
{\tt try-again} переходил к следующему нерассмотренному
варианту в недетерминистском вычислении.  Процедура
{\tt internal-loop} либо зовет {\tt try-again}, если
пользователь набирает {\tt try-again} в управляющем цикле, либо
запускает новое вычисление, вызывая {\tt ambeval}.

Продолжение неудачи в этом вызове {\tt ambeval}
сообщает пользователю, что значений больше нет, и перезапускает
управляющий цикл.

Продолжение успеха для вызова {\tt ambeval}
устроено тоньше.  Мы печатаем вычисленное значение, а потом заново
запускаем внутренний цикл с процедурой {\tt try-again},
которая сможет попробовать следующий вариант.  Этот переход к
следующему варианту выражается процедурой
{\tt next-alternative}, которая передана вторым аргументом в
продолжение успеха.  Обычно мы считаем этот второй аргумент
продолжением неудачи, которое придется использовать, если текущая ветвь
исполнения потерпит неудачу.  Однако в данном случае мы завершили
успешное вычисление, так что <<неудачный>> вариант можно позвать
для того, чтобы найти дополнительные успешные варианты вычисления.

\begin{Verbatim}[fontsize=\small]
(define input-prompt ";;; Ввод Amb-Eval:") \index{ru}{подсказка|недетерминистский вычислитель||||}
(define output-prompt ";;; Значение Amb-Eval:")

(define (driver-loop)\index{ru}{driver-loop|для недетерминистского интерпретатора|||pd|}
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Начало новой задачи ")
            (ambeval input
                     the-global-environment
                     {\em ;; успех {\tt ambeval}}
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     {\em ;; неудача {\tt ambeval}}
                     (lambda ()
                       (announce-output
                        ";;; Нет больше значений")
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; Задача не задана")
     (driver-loop))))
\end{Verbatim}
Самый первый вызов {\tt internal-loop} использует процедуру
{\tt try-again}, которая жалуется, что не было
дано никакой задачи, и возобновляет управляющий цикл.  Такое поведение
требуется, если пользователь набирает {\tt try-again}, еще не задав
выражение для вычисления.

\begin{exercise}{4.50}%
\label{EX4.50}%
Реализуйте новую особую форму {\tt ramb},
которая подобна {\tt amb}, однако перебирает варианты не
слева направо, а в случайном порядке.  Покажите, как такая форма может
пригодиться в Лизиной задаче из упражнения~\ref{EX4.49}
\end{exercise}

\begin{exercise}{4.51}%
\label{EX4.51}%
Реализуйте новую разновидность присваивания
{\tt permanent-set!}~--- присваивание, которое не отменяется
при неудачах.  Например, можно выбрать два различных элемента в списке
и посчитать, сколько для этого потребовалось попыток, следующим
образом:

\begin{Verbatim}[fontsize=\small]
(define count 0)

(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{(a b 2)}

\textit{;;; Ввод Amb-Eval:}
try-again
\textit{;;; Значение Amb-Eval:}
\textit{(a c 3)}
\end{Verbatim}
Какие значения были бы напечатаны, если бы мы вместо
{\tt permanent-set!} использовали здесь обычный {\tt set!}?
\end{exercise}

\begin{exercise}{4.52}%
\label{EX4.52}%
Реализуйте новую конструкцию {\tt if-fail},
которая позволяет пользователю перехватить неудачу при выполнении
выражения. {\tt If-fail} принимает два выражения.  Первое она
выполняет как обычно и, если вычисление успешно, возвращает его
результат.  Однако если вычисление неудачно, то возвращается значение
второго выражения, как в следующем примере:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод Amb-Eval:}
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{all-odd}

\textit{;;; Ввод Amb-Eval:}
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
\textit{;;; Начало новой задачи}
\textit{;;; Значение Amb-Eval:}
\textit{8}
\end{Verbatim}
\end{exercise}

\begin{exercise}{4.53}%
\label{EX4.53}%
Если у нас есть {\tt permanent-set!}, описанное в 
упражнении~\ref{EX4.51}, и {\tt if-fail} из
упражнения~\ref{EX4.52}, то каков будет результат вычисления

\begin{Verbatim}[fontsize=\small]
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
\end{Verbatim}
\end{exercise}

\begin{exercise}{4.54}%
\label{EX4.54}%
Если бы мы не догадались, что конструкцию
\index{ru}{require|как особая форма|||p|(упр.~4.54)}{\tt require}
можно реализовать как обычную процедуру с помощью {\tt amb},
так что пользователь сам может определить ее в своей недетерминистской
программе, то нам пришлось бы задать эту конструкцию в виде особой
формы.  Потребовались бы синтаксические процедуры

\begin{Verbatim}[fontsize=\small]
(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
\end{Verbatim}
новая ветвь разбора в {\tt analyze}:

\begin{Verbatim}[fontsize=\small]
((require? exp) (analyze-require exp))
\end{Verbatim}
а также процедура {\tt analyze-require}, которая обрабатывает
выражения {\tt require}.  Допишите следующее определение
{\tt analyze-require}:

\begin{Verbatim}[fontsize=\small]
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if \textit{$\langle$??$\rangle$}
                   \textit{$\langle$??$\rangle$}
                   (succeed 'ok fail2)))
             fail))))
\end{Verbatim}
\end{exercise}

\section{Логическое программирование}
\label{LOGIC-PROGRAMMING}%

\index{ru}{логическое программирование|||||}\index{ru}{информатика|vs. 
математика||||}\index{ru}{математика|vs. информатика||||}В 
главе~\ref{BUILDING-ABSTRACTIONS-WITH-PROCEDURES} мы
подчеркивали, что информатика имеет дело с \index{ru}{декларативное vs. императивное знание|||||}
\index{ru}{императивное vs. декларативное знание|||||}императивным знанием 
(<<как сделать>>), в то время как математика имеет дело с
декларативным знанием (<<что такое>>).  Действительно, языки
программирования требуют, чтобы программист, выражая свои знания,
указывал методы пошагового решения определенных задач.  С другой
стороны, языки высокого уровня обеспечивают в рамках своих реализаций
существенный объем методологических знаний, которые освобождает
пользователя от забот о многих деталях того, как проходит описываемое
вычисление.

Большинство языков программирования, включая Лисп, построены вокруг
вычисления значений математических функций.  Языки, ориентированные
на выражения, (такие, как Лисп, Фортран и Алгол) пользуются тем, что
выражение, описывающее значение функции,
можно интерпретировать и как способ вычислить это значение.  По этой
причине большинство языков программирования имеют уклон
в однонаправленные вычисления (вычисления со строго определенными
входом и выходом).  Имеются, однако, совсем другие языки
программирования, в которых этот уклон ослаблен.  Пример такого языка мы
видели в разделе~\ref{PROPAGATION-OF-CONSTRAINTS}, где
объектами вычисления были арифметические ограничения. В системе
ограничений направление и порядок вычислений определены не столь
четко; стало быть, чтобы провести вычисление, система должна
содержать в себе более детальное знание <<как сделать>>, чем в случае
с обычным арифметическим вычислением.  Однако это не значит, что
пользователь вовсе не отвечает за то, чтобы обеспечить систему
императивным знанием.  Существует множество сетей, которые
задают одно и то же множество ограничений, и пользователю нужно
выбрать из множества математически эквивалентных сетей одну подходящую,
чтобы описать нужное вычисление.

Недетерминистский интерпретатор программ из 
раздела~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}
тоже представляет собой отход от представления, что
программирование связано с построением алгоритмов для вычисления
однонаправленных функций.  В недетерминистском языке у выражений может
быть более одного значения, и оттого вычисление работает с\index{ru}{отношения, 
вычисления в терминах отношений||computing in terms of 
relations|||}\index{en}{computing
in terms of relations||отношения, вычисления в терминах отношений|||}
отношениями, а не с функциями, у которых значение только
одно. Логическое программирование расширяет эту идею, сочетая
реляционный взгляд на программирование с мощной разновидностью
символьного сопоставления с образцом, которую называют \index{ru}{
унификация||unification|||}\index{en}{
unification||унификация|||}{\em унификация} 
(unification)\footnote{\index{ru}{логическое 
программирование|история||||п}Логическое программирование выросло из 
долгой традиции исследований по 
\index{ru}{доказательство теорем (автоматическое)||automatic theorem 
proving|||п}\index{en}{automatic theorem proving||доказательство теорем 
(автоматическое)|||п}автоматическому доказательству теорем.  Ранние
программы доказательства теорем достигали лишь скромных результатов,
так как они полностью перебирали пространство возможных
доказательств.  Крупный прорыв, который сделал такой поиск
осмысленным, случился в начале 1960х годов, когда были открыты \index{ru}{
унификация|открытие алгоритма||||п}\index{ru}{
алгоритм|унификации|algorithm|unification algorithm||п}\index{en}{
algorithm|unification algorithm|алгоритм|унификации||п}{\em алгоритм 
унификации} (unification algorithm) и \index{ru}{резолюции
принцип||resolution principle|||п}\index{en}{resolution
principle||резолюции принцип|||п}{\em принцип резолюции} (resolution 
principle) (Robinson 1965).\index{ru}{Робинсон, 
Дж.~А.||J.~A.~Robinson||n|п}\index{en}{J.~A.~Robinson||Робинсон, Дж.~А.||n|п}
Резолюцию использовали, например, Грин и Рафаэль (Green and Raphael 
1968,\index{ru}{Грин, Корделл||Cordell Green||n|п}\index{en}{Cordell 
Green||Грин, Корделл||n|п}\index{ru}{Рафаэль, Бертрам||Bertram 
Raphael||n|п}\index{en}{Bertram Raphael||Рафаэль, Бертрам||n|п}
см. также Green 1969) как основу дедуктивной
системы вопрос-ответ.  Большую часть этого периода исследователи
сосредотачивались на алгоритмах, которые гарантированно находят решение,
если оно существует.  Такими алгоритмами было трудно управлять, и
трудно было указать им направление доказательства. Хьюитт 
(Hewitt 1969) нашел возможность сочетать\index{ru}{Хьюитт,
Карл Эдди||Carl Eddie Hewitt||n|п}\index{en}{Hewitt, Carl Eddie||Хьюитт, 
Карл Эдди||n|п} 
управляющую структуру языка программирования с операциями системы
логического манипулирования, и это привело к появлению работы по автоматическому
поиску, упомянутой в разделе~\ref{AMB-AND-SEARCH}
(примечание \ref{F4.47}). В то же самое время  в
Марселе Кольмероэ разрабатывал системы обработки
естественного языка, основанные на правилах (см. Colmerauer et
al. 1973).\index{ru}{Кольмероэ,
Ален||Alain Colmerauer||n|п}\index{en}{Alain Colmerauer||Кольмероэ, Ален||n|п}
Для представления этих правил он изобрел язык\index{ru}{Prolog 
(Пролог)|||||п} Пролог. Ковальски 
(Kowalski 1973; Kowalski 1979)\index{ru}{Ковальски,
Роберт||Robert Kowalski||n|п}\index{en}{Robert 
Kowalski||Ковальски, Роберт||n|п}
в Эдинбурге обнаружил, что выполнение программы на Прологе можно
интерпретировать как доказательство теорем (с использованием метода
доказательства, называемого линейной резолюцией Хорновских
форм)\index{ru}{резолюции принцип|Хорновские формы||||п}.
Слияние этих двух линий привело к возникновению традиции
логического программирования. Таким образом, в споре о приоритетах в
области логического программирования французы могут указать на
корни Пролога в\index{ru}{Марсельский
университет||University of Marseille|||п}\index{en}{University
of Marseille||Марсельский университет|||п}
Марсельском университете, а британцы на работы,
сделанные в  \index{ru}{Эдинбургский университет||University of 
Edinburgh|||п}\index{en}{University of Edinburgh||Эдинбургский 
университет|||п}университете Эдинбурга.  А по мнению исследователей из 
\index{ru}{MIT|||||п}MIT, обе эти
группы разработали логическое программирование, когда пытались понять, что же
хотел сказать Хьюитт в своей блистательной, но трудночитаемой
диссертации. Историю логического программирования можно найти в
Robinson 1983.}.

\index{ru}{декларативное 
vs. императивное знание|и логическое
программирование||||}\index{ru}{императивное 
vs. декларативное знание|и логическое
программирование||||}Когда этот подход работает, он служит весьма мощным
способом написания программ.  Отчасти эта мощь проистекает из того,
что один факт вида <<что такое>> можно использовать для решения
нескольких различных задач с разными компонентами <<как сделать>>.  Для
примера рассмотрим операцию {\tt append}, которая в
качестве аргументов принимает два списка и объединяет их элементы в
один список.  В процедурном языке вроде Лиспа можно определить
{\tt append} через базовый конструктор списков
{\tt cons}, как в 
разделе~\ref{REPRESENTING-SEQUENCES}:\index{ru}{append|<<что такое>> 
(правила) или <<как сделать>> (процедура)|||p|}

\begin{Verbatim}[fontsize=\small]
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
\end{Verbatim}
Эту процедуру можно рассматривать как перевод на Лисп следующих двух
правил; первое покрывает случай, когда первый список пуст, а второе
--- случай непустого списка, представляющего собой {\tt cons} двух частей:

\begin{plainlist}
\item
Для любого списка {\tt y}, {\tt append} пустого
списка и {\tt y} дает {\tt y}.

\item
Для любых {\tt u}, {\tt v},
{\tt y} и {\tt z}, {\tt append} от {\tt (cons u
v)} и {\tt y} дает {\tt (cons u z)}, если
{\tt append} от {\tt v} и {\tt y} дает
{\tt z}\footnote{Соответствие между правилами и процедурой такое:
пусть {\tt x} из процедуры (когда {\tt x} непустой)
соответствует {\tt (cons u v)} из правила.  Тогда
{\tt z} из правила соответствует {\tt append} от
{\tt (cdr x)} и {\tt y}.}.
\end{plainlist}
С помощью процедуры {\tt append} мы можем решать задачи
типа

\begin{quote}
Найти {\tt append} от {\tt (a b)} и
{\tt (c d)}.
\end{quote}
Однако тех же двух правил достаточно для решения следующих типов
вопросов, на которые процедура ответить не может:

\begin{quote}
Найти список {\tt y}, такой, что
{\tt append} {\tt (a b)} и {\tt y} дает {\tt (a b c d)}.
\end{quote}

\begin{quote}
Найти все такие {\tt x} и {\tt y}, что
{\tt append} от них дает {\tt (a b c d)}.
\end{quote}
\index{ru}{логическое программирование|язык логического 
программирования||||}\index{ru}{язык программирования|логического||||}В 
языке логического программирования, когда программист пишет <<процедуру>>
{\tt append}, он формулирует два правила, приведенные
выше. Знание <<как сделать>> автоматически обеспечивается
интерпретатором, что позволяет использовать одну эту пару правил для
ответа на все три типа вопросов об {\tt append}\footnote{Это ни в коем 
случае не освобождает программиста
полностью от решения задачи, как вычислить ответ.  Существует
множество математически эквивалентных наборов правил для отношения
{\tt append}, и только некоторые из них можно превратить в
эффективное средство для вычисления в каком-либо направлении.
Вдобавок, иногда информация <<что такое>> ничего не говорит о том,
{\em как} вычислить ответ,~--- возьмем, например, задачу найти такое
$y$, что $y^2 = x$.}.

У современных языков логического программирования (включая
тот, который мы сейчас реализуем) есть существенные недостатки, а
именно: их общие методы <<как сделать>> порой заводят в ненужные
бесконечные циклы или вызывают нежелательное поведение другого рода.
Логическое программирование сейчас активно исследуется в
информатике\footnote{\index{ru}{логическое 
программирование|история||||п}\index{ru}{логическое 
программирование|в Японии||||п}Пик интереса к логическому программированию 
пришелся на начало 80-х, когда японское правительство инициировало амбициозный
проект, целью которого было построение
сверхбыстрых\index{ru}{логическое 
программирование|компьютеры||||п}
компьютеров, оптимизированных для логических языков программирования.  Скорость
таких компьютеров предполагалось измерять в LIPS (Logical Inferences
Per Second~--- число логических выводов в секунду), а не в обычных FLOPS
(FLoating-point Operations Per Second~--- число операций с плавающей
точкой в секунду).  Несмотря на то, что в рамках проекта удалось
создать аппаратное и программное обеспечение, которое изначально
планировалось, интересы международной компьютерной промышленности сместились
в другом направлении.  Обзор и оценку японского проекта
можно найти в Feigenbaum and Shrobe 1993.\index{ru}{Фейгенбаум, 
Эдвард||Edward Feigenbaum||n|п}\index{en}{Edward Feigenbaum||Фейгенбаум, 
Эдвард||n|п}\index{ru}{Шроуб, Ховард~Э.||Howard~E. 
Shrobe||n|п}\index{en}{Howard~E. Shrobe||Шроуб, Ховард~Э.||n|п}
К тому же и в сообществе логических программистов возник интерес к реляционному
программированию на основе других методов, помимо простого
сопоставления с образцом, например, к работе с численными
ограничениями~--- вроде тех, которые присутствуют в системе
распространения ограничений из 
раздела~\ref{PROPAGATION-OF-CONSTRAINTS}.}.

Ранее в этой главе мы изучили технологию реализации
интерпретаторов и описали те ее элементы, которые необходимы в
интерпретаторе Лисп-подобного языка (в сущности, любого традиционного
языка).  
Теперь мы воспользуемся этими идеями при рассмотрении
интерпретатора для языка логического программирования.  Мы называем
этот язык \index{ru}{язык запросов||query language|||}\index{en}{query
language||язык запросов|||}{\em языком запросов} (query language),
поскольку он весьма удобен для извлечения информации из баз данных
при помощи
\index{ru}{запрос||query|||}\index{en}{query||запрос|||}{\em запросов}
(queries), то есть выраженных на
нашем языке вопросов.  Несмотря на то, что язык запросов сильно
отличается от Лиспа, его удобно обсуждать в терминах той
же самой общей схемы, которую мы использовали до сих пор: как набор
элементарных составляющих, дополненных средствами комбинирования, которые
позволяют нам сочетать простые составляющие и получать при этом
сложные, и средствами абстракции, которые позволяют нам
рассматривать сложные составляющие как единые концептуальные единицы.
Интерпретатор языка логического программирования существенно сложнее,
чем интерпретатор языка типа Лиспа.  Тем не менее, нам предстоит
убедиться, что наш\index{ru}{интерпретатор языка запросов||query
interpreter|||}\index{en}{query interpreter||интерпретатор языка запросов|||} 
интерпретатор языка запросов содержит многие из тех же элементов,
которые были в интерпретаторе из 
раздела~\ref{THE-METACIRCULAR-EVALUATOR}.  В частности, у нас будет
часть <<eval>>, которая классифицирует выражения в соответствии с
типом, и часть <<apply>>, которая реализует механизм абстракции языка
(процедуры в случае Лиспа и \index{ru}{правило (в языке 
запросов)||rule|||}\index{en}{rule||правило (в языке запросов)|||}{\em 
правила} (rules) в
случае логического программирования).  Кроме того, в реализации
центральную роль будет играть структура данных, построенная из кадров
и определяющая соотношение между символами и связанными с ними
значениями.  Еще одна интересная сторона нашей реализации языка
запросов~--- то, что мы существенным образом используем потоки,
введенные в главе~\ref{MODULARITY-OBJECTS-AND-STATE}.

\subsection{Дедуктивный поиск информации}
\label{DEDUCTIVE-INFORMATION-RETRIEVAL}%

\index{ru}{база данных|и логическое
  программирование||||}\index{ru}{язык 
запросов|||||}Логическое программирование хорошо приспособлено 
для построения интерфейсов к базам данных, служащих для поиска
информации. Язык запросов, который мы реализуем в этой главе,
спроектирован именно для такого использования.

Чтобы показать, чем занимается система запросов, мы
покажем, как с ее помощью управлять базой данных персонала для
\index{ru}{<<Микрошафт>> (Microshaft)|||||}<<Микрошафт>>, процветающей
компании из окрестностей Бостона со 
специализацией в области высоких технологий.
Язык предоставляет возможность поиска 
информации о сотрудниках, производимого с помощью образцов; он также
может осуществлять логический вывод на основании общих правил.

\paragraph{База данных}

\index{ru}{база данных|персонал <<Микрошафт>>||||}\index{ru}{язык
  запросов|база данных||||}База данных персонала <<Микрошафт>> содержит 
\index{ru}{утверждение||assertion|||}\index{en}{assertion||утверждение|||}{\em 
утверждения} (assertions) о сотрудниках компании.
Вот информация о Бене Битоборе, местном компьютерном гуру:

\begin{Verbatim}[fontsize=\small]
(адрес (Битобор Бен) (Сламервилл (Ридж Роуд) 10))
(должность (Битобор Бен) (компьютеры гуру))
(зарплата (Битобор Бен) 60000)
\end{Verbatim}
Каждое утверждение представляет собой список (в данном случае
тройку). элементы которого сами могут быть списками.

В качестве местного гуру Бен отвечает за компьютерный
отдел компании и руководит двумя программистами и одним техником.
Вот информация о них:

\begin{Verbatim}[fontsize=\small]
(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78))
(должность (Хакер Лиза П) (компьютеры программист))
(зарплата (Хакер Лиза П) 40000)
(начальник (Хакер Лиза П) (Битобор Бен))

(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3))
(должность (Фект Пабло Э) (компьютеры программист))
(зарплата (Фект Пабло Э) 35000)
(начальник (Фект Пабло Э) (Битобор Бен))

(адрес (Поправич Дайко) (Бостон (Бэй Стейт Роуд) 22))
(должность (Поправич Дайко) (компьютеры техник))
(зарплата (Поправич Дайко) 25000)
(начальник (Поправич Дайко) (Битобор Бен))
\end{Verbatim}
Имеется также программист-стажер, над которым начальствует Лиза:

\begin{Verbatim}[fontsize=\small]
(адрес (Дум Хьюго) (Сламервилл (Пайн Три Роуд) 80))
(должность (Дум Хьюго) (компьютеры программист стажер))
(зарплата (Дум Хьюго) 30000)
(начальник (Дум Хьюго) (Хакер Лиза П))
\end{Verbatim}
Все эти служащие работают в компьютерном отделе, на что указывает
слово {\tt компьютеры} в начале описания их должностей.

Бен~--- служащий высокого ранга.  Его начальник~--- сам
глава компании:

\begin{Verbatim}[fontsize=\small]
(начальник (Битобор Бен) (Уорбак Оливер))

(адрес (Уорбак Оливер) (Суэлсли (Топ Хип Роуд)))
(должность (Уорбак Оливер) (администрация большая шишка))
(зарплата (Уорбак Оливер) 150000)
\end{Verbatim}

Помимо компьютерного отдела, руководимого Беном, в
компании имеется бухгалтерия, где работает главный бухгалтер со своим
помощником:

\begin{Verbatim}[fontsize=\small]
(адрес (Скрудж Эбин) (Уэстон (Шейди Лейн) 10))
(должность (Скрудж Эбин) (бухгалтерия главный бухгалтер))
(зарплата (Скрудж Эбин) 75000)
(начальник (Скрудж Эбин) (Уорбак Оливер))

(адрес (Крэтчит Роберт) (Олстон (Норт Гарвард Стрит) 16))
(должность (Крэтчит Роберт) (бухгалтерия писец))
(зарплата (Крэтчит Роберт) 18000)
(начальник (Крэтчит Роберт) (Скрудж Эбин))
\end{Verbatim}
Есть еще секретарь главы компании:

\begin{Verbatim}[fontsize=\small]
(адрес (Фиден Кон) (Сламервилл (Онион Сквер) 5))
(должность (Фиден Кон) (администрация секретарь))
(зарплата (Фиден Кон) 25000)
(начальник (Фиден Кон) (Уорбак Оливер))
\end{Verbatim}

Данные содержат также утверждения о том, какой род работы
могут выполнять сотрудники, имеющие другую должность.  Например,
компьютерный гуру способен выполнять работу как компьютерного
программиста, так и компьютерного техника:

\begin{Verbatim}[fontsize=\small]
(может-замещать (компьютеры гуру) (компьютеры программист))
(может-замещать (компьютеры гуру) (компьютеры техник))
\end{Verbatim}
Программист может выполнять работу стажера:

\begin{Verbatim}[fontsize=\small]
(может-замещать (компьютеры программист)
                (компьютеры программист стажер))
\end{Verbatim}
Кроме того, как всем известно,\index{ru}{секретарь, его важное 
значение||importance of a secretary|||}

\begin{Verbatim}[fontsize=\small]
(может-замещать (администрация секретарь)
                (администрация большая шишка))
\end{Verbatim}

\paragraph{Простые запросы}

\index{ru}{простой запрос|||||}Язык запросов дает пользователям 
возможность извлекать
информацию из базы данных, формулируя запросы в ответ на приглашение
системы.  Например, чтобы найти всех программистов, можно сказать

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод запроса:}
(должность ?x (компьютеры программист))
\end{Verbatim}
Система выведет следующие результаты:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Результаты запроса:}
(должность (Хакер Лиза П) (компьютеры программист))
(должность (Фект Пабло Э) (компьютеры программист))
\end{Verbatim}

Входной запрос указывает, что мы ищем в базе данных
записи, соответствующие
некоторому 
\index{ru}{образец||pattern|||}\index{en}{pattern||образец|||}{\em 
образцу} (pattern).  В этом примере образец
указывает, что запись должна состоять из трех элементов, из которых
первый является символом {\tt должность}, второй может быть
чем угодно, а третий представляет собой список 
{\tt (компьютеры программист)}. <<Что угодно>>, которое может
стоять на второй позиции в искомом списке, изображается 
\index{ru}{переменная образца||pattern variable|||}\index{en}{pattern 
variable||переменная образца|||}{\em переменной образца} (pattern variable)
{\tt ?x}.  В общем случае переменная образца~--- это символ,
который мы считаем именем переменной, предваряемый знаком
вопроса.  Несколько позже мы увидим, почему имеет смысл давать переменным
образца имена, а не просто ставить в образцы {\tt ?},
означающее <<что угодно>>.  Система отвечает на простой запрос, выводя
все записи в базе данных, соответствующие введенному образцу.

В образце может содержаться более одной переменной.
Например,

\begin{Verbatim}[fontsize=\small]
(адрес ?x ?y)
\end{Verbatim}
выводит адреса всех служащих.

В образце может совсем не быть переменных.  В этом случае
запрос просто проверяет, содержится ли запись в базе.  Если да, будет
одна подходящая под образец запись; если нет, ни одной.

Одна и та же переменная может встречаться в образце в нескольких местах,
и это означает, что одинаковое <<что угодно>> должно
встретиться в каждом из этих мест.  Ради этого переменным и даются
имена.  Например,

\begin{Verbatim}[fontsize=\small]
(начальник ?x ?x)
\end{Verbatim}
находит всех сотрудников, которые сами себе начальники (впрочем, в
нашей пробной базе таковых не имеется).

Запросу

\begin{Verbatim}[fontsize=\small]
(должность ?x (компьютеры ?type))
\end{Verbatim}
соответствуют все записи о должностях, в которых третий элемент
является двухэлементным списком, а первый элемент в нем
{\tt компьютеры}:

\begin{Verbatim}[fontsize=\small]
(должность (Битобор Бен) (компьютеры гуру))
(должность (Хакер Лиза П) (компьютеры программист))
(должность (Фект Пабло Э) (компьютеры программист))
(должность (Поправич Дайко) (компьютеры техник))
\end{Verbatim}
Этому образцу {\em не} соответствует запись

\begin{Verbatim}[fontsize=\small]
(должность (Дум Хьюго) (компьютеры программист стажер))
\end{Verbatim}
поскольку третий элемент здесь является списком из трех элементов, а
третий элемент образца указывает, что элементов должно быть
два. \index{ru}{точечная запись|в образцах   запросов|dotted-tail 
notation|||}\index{en}{dotted-tail notation||точечная запись|в образцах   
запросов||}Если
бы нам захотелось изменить образец так, чтобы третий элемент мог быть
любым списком, который начинается с {\tt компьютеры}, мы могли
бы написать\footnote{Здесь используется точечная запись, введенная в
упражнении~\ref{EX2.20}.}

\begin{Verbatim}[fontsize=\small]
(должность ?x (компьютеры . ?type))
\end{Verbatim}
Например,

\begin{Verbatim}[fontsize=\small]
(компьютеры . ?type)
\end{Verbatim}
соответствуют данные

\begin{Verbatim}[fontsize=\small]
(компьютеры программист стажер)
\end{Verbatim}
причем {\tt ?type} равняется списку  {\tt (программист стажер)}.  Тому
же образцу соответствуют данные

\begin{Verbatim}[fontsize=\small]
(компьютеры программист)
\end{Verbatim}
где {\tt ?type} равняется списку {\tt (программист)},
и  данные

\begin{Verbatim}[fontsize=\small]
(компьютеры)
\end{Verbatim}
где {\tt ?type} равняется пустому списку
{\tt ()}.

Можно следующим образом описать обработку
простых запросов в нашем языке:

\begin{plainlist}
\item
Система находит все присваивания переменным в
образце запроса, которые 
\index{ru}{удовлетворение запросу||satisfying a 
pattern|||}\index{en}{satisfying a pattern||удовлетворение запросу|||}{\em 
удовлетворяют} (satisfy) запросу~---
то есть, все наборы значений переменных, такие, что если переменные
образца \index{ru}{конкретизация образца||instantiation of a
  pattern|||}\index{en}{instantiation of a pattern||конкретизация
  образца|||}{\em конкретизуются} (are instantiated), то есть замещаются,
своими значениями, то результат находится в базе данных.

\item
Система отвечает на запрос, перечисляя все
конкретизации образца с удовлетворяющими ему присваиваниями
переменным.
\end{plainlist}
Заметим, что в случае, когда образец не содержит переменных, запрос
сводится к выяснению, находится ли образец в базе.  Если да, то
нулевое присваивание, не сообщающее значений никаким переменным,
удовлетворяет запросу к текущей базе данных.

\begin{exercise}{4.55}%
\label{EX4.55}%
Постройте простые запросы, которые извлекают из базы
данных следующую информацию:

\begin{plainenum}
\item
Все сотрудники, начальником которых является Бен
Битобор.
\item
Имена и должности всех работников
бухгалтерии.

\item
 Имена и адреса всех сотрудников, живущих в
Сламервилле.
\end{plainenum}
\end{exercise}

\paragraph{Составные запросы}

\index{ru}{составной запрос||compound query|||}\index{en}{compound 
query||составной запрос|||}Простые запросы являются элементарными 
операциями языка
запросов.  Чтобы порождать составные операции, язык предоставляет
средства комбинирования.  Один из элементов, превращающих язык
запросов в язык логического программирования~--- то, что средства
комбинирования запросов отражают средства комбинирования, используемые
при построении логических выражений: {\tt and} (и),
{\tt or} (или) и {\tt not} (не).  (Здесь
{\tt and}, {\tt or} и {\tt not}~--- это не
элементарные выражения Лиспа, а операции, встроенные в язык
запросов.)

Мы можем найти адреса всех программистов с помощью
{\tt and} так:\index{ru}{and (язык запросов)||||p|}

\begin{Verbatim}[fontsize=\small]
(and (должность ?person (компьютеры программист))
     (адрес ?person ?where))
\end{Verbatim}
Получаем на выводе

\begin{Verbatim}[fontsize=\small]
(and (должность (Хакер Лиза П) (компьютеры программист))
     (адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78)))

(and (должность (Фект Пабло Э) (компьютеры программист))
     (адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3)))
\end{Verbatim}
В общем случае, запросу

\begin{Verbatim}[fontsize=\small]
(and \textit{$\langle$запрос${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$запрос${}_{\mbox{n}}$$\rangle$})
\end{Verbatim}
удовлетворяют все наборы значений переменных образца, которые
одновременно удовлетворяют \index{ru}{удовлетворение 
запросу|составному||||}\textit{$\langle$запросу${}_{\mbox{1}}$$\rangle$} 
... \textit{$\langle$запросу${}_{\mbox{n}}$$\rangle$}.

Как и в случае с простыми запросами, система при
обработке составного запроса находит все присваивания переменным
образца, удовлетворяющие запросу, и затем печатает все
конкретизации запроса этими значениями.

Другой метод построения составных запросов~--- через
{\tt or}.  Например,\index{ru}{or (язык запросов)||||p|}

\begin{Verbatim}[fontsize=\small]
(or (начальник ?x (Битобор Бен))
    (начальник ?x (Хакер Лиза П)))
\end{Verbatim}
найдет всех сотрудников, над которыми начальствует Бен Битобор или
Лиза П.~Хакер:

\begin{Verbatim}[fontsize=\small]
(or (начальник (Хакер Лиза П) (Битобор Бен))
    (начальник (Хакер Лиза П) (Хакер Лиза П)))

(or (начальник (Фект Пабло Э) (Битобор Бен))
    (начальник (Фект Пабло Э) (Хакер Лиза П)))

(or (начальник (Поправич Дайко) (Битобор Бен))
    (начальник (Поправич Дайко) (Хакер Лиза П)))

(or (начальник (Дум Хьюго) (Битобор Бен))
    (начальник (Дум Хьюго) (Хакер Лиза П)))
\end{Verbatim}
В общем случае, запросу

\begin{Verbatim}[fontsize=\small]
(or \textit{$\langle$запрос${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$запрос${}_{\mbox{n}}$$\rangle$})
\end{Verbatim}
удовлетворяют все наборы значений переменных образца, которые
удовлетворяют по крайней мере одному из
\textit{$\langle$запроса${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$запроса${}_{\mbox{n}}$$\rangle$}.

Кроме того, составные запросы можно порождать при помощи
{\tt not}.\index{ru}{not (язык запросов)||||p|}
Например,

\begin{Verbatim}[fontsize=\small]
(and (начальник ?x (Битобор Бен))
     (not (должность ?x (компьютеры программист))))
\end{Verbatim}
ищет всех сотрудников, для которых начальник Бен Битобор, не
являющихся программистами.  В общем случае, запросу

\begin{Verbatim}[fontsize=\small]
(not \textit{$\langle$запрос${}_{\mbox{1}}$$\rangle$})
\end{Verbatim}
удовлетворяют все присваивания переменным образца, которые не
удовлетворяют
\textit{$\langle$за\-просу${}_{\mbox{1}}$$\rangle$}\footnote{Это описание 
{\tt not} верно только для простых случаев.  На самом деле поведение этой 
конструкции более сложное.  Мы исследуем тонкости {\tt not} в 
разделах~\ref{HOW-THE-QUERY-SYSTEM-WORKS} 
и~\ref{IS-LOGIC-PROGRAMMING-MATHEMATICAL-LOGIC}.}.

Последняя комбинирующая форма называется
{\tt lisp-value}.\index{ru}{lisp-value (язык запросов)||||p|}
Когда она стоит в начале образца, она
указывает, что следующий элемент является предикатом Лиспа, который
требуется применить к остальным (конкретизированным) элементам как к
аргументам.  В общем случае, образец

\begin{Verbatim}[fontsize=\small]
(lisp-value \textit{$\langle$предикат$\rangle$} \textit{$\langle$арг${}_{\mbox{1}}$$\rangle$} ... \textit{$\langle$арг${}_{\mbox{n}}$$\rangle$})
\end{Verbatim}
удовлетворяется теми присваиваниями переменным образца, для которых
применение \textit{$\langle$предиката$\rangle$} к конкретизированным
\textit{$\langle$арг${}_{\mbox{1}}$$\rangle$} \ldots
\textit{$\langle$арг${}_{\mbox{n}}$$\rangle$} дает истину.  Например, чтобы найти
всех сотрудников с зарплатой выше 30000 долларов, можно
написать\footnote{{\tt Lisp-value} имеет смысл использовать только для
тех операций, которых нет в языке запросов. \index{ru}{язык
  запросов|проверка  на равенство||||п}В частности, с его
помощью не следует проверять равенство (так как для этого
предназначено сопоставление в языке запросов) и неравенство (так как
это можно сделать посредством правила {\tt same}, приведенного ниже).}

\begin{Verbatim}[fontsize=\small]
(and (зарплата ?person ?amount)
     (lisp-value > ?amount 30000))
\end{Verbatim}

\begin{exercise}{4.56}%
\label{EX4.56}%
Сформулируйте составные запросы для получения следующей
информации:

\begin{plainenum}
\item

имена всех сотрудников, у которых начальником Бен
Битобор, и их адреса;

\item
все сотрудники, чья зарплата ниже, чем у Бена
Битобора, вместе с их зарплатой и зарплатой Бена;

\item
все сотрудники, у которых начальник не относится к
компьютерному отделу, вместе с именем и должностью их начальника.
\end{plainenum}
\end{exercise}

\paragraph{Правила}

\index{ru}{правило (в языке запросов)|||||}В дополнение к элементарным и 
составным запросам, наш 
язык обладает  \index{ru}{язык запросов|абстракция||||}средством 
абстракции запросов. Это 
\index{ru}{правило (в языке запросов)||rule|||}\index{en}{rule||правило (в 
языке запросов)|||}{\em правила} (rules).  Правило

\begin{Verbatim}[fontsize=\small]
(rule (живет-около ?person-1 ?person-2)\index{ru}{живет-около (правило)||||pd|}
      (and (адрес ?person-1 (?town . ?rest-1))
           (адрес ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{Verbatim}
говорит, что двое людей живут рядом друг с другом, если они живут в
одном городе.  Выражение {\tt not} в конце необходимо для того,
чтобы правило не говорило про всех людей, что они живут сами около
себя.  Отношение {\tt same} (тот же самый) определяется очень
простым правилом\footnote{Заметим, что правило {\tt same} не нужно для
того, чтобы сделать два объекта одинаковыми: достаточно просто
использовать одну и ту же переменную образца~--- тогда у нас с самого
начала будет иметься только один объект, а не два.  Например, обратите
внимание на {\tt ?town} в правиле {\tt живет-около} или
{\tt ?middle-manager} в правиле {\tt шишка}
ниже. {\tt Same} оказывается полезным, когда нам хочется,
чтобы два объекта различались, как {\tt ?person-1} и
{\tt ?person-2} в правиле {\tt живет-около}.  При том,
что использование одной переменной в двух местах в запросе требует,
чтобы в обоих местах присутствовало одно значение, использование
разных переменных не означает, что значения различаются.
(Значения, присваиваемые различным переменным образца, могут быть как
разными, так и одинаковыми.)}:

\begin{Verbatim}[fontsize=\small]
(rule (same ?x ?x))  \index{ru}{same (правило)||||pd|}
\end{Verbatim}

Следующее правило объявляет, что сотрудник является
<<шишкой>>, если он начальствует над кем-нибудь, кто сам является
начальником:

\begin{Verbatim}[fontsize=\small]
(rule (шишка ?person) \index{ru}{шишка (правило)||||pd|}
      (and (начальник ?middle-manager ?person)
           (начальник ?x ?middle-manager)))
\end{Verbatim}

В общем случае правило выглядит как

\begin{Verbatim}[fontsize=\small]
(rule \textit{$\langle$заключение$\rangle$} \textit{$\langle$тело$\rangle$})
\end{Verbatim}
где \textit{$\langle$заключение$\rangle$}~--- это образец, а
\textit{$\langle$тело$\rangle$}~--- произвольный 
запрос\footnote{\index{ru}{правило (в языке запросов)|без тела||||п}Кроме того, мы разрешаем иметь правила без тела,
вроде {\tt same}, и будем полагать, что такое правило означает,
что заключение удовлетворяется любыми значениями переменных.}.
Можно
считать, что правило представляет собой большое (даже бесконечное)
множество утверждений, а именно, все конкретизации заключения при
помощи присваиваний переменным, удовлетворяющих телу правила.
Когда мы описывали простые запросы (образцы), мы сказали, что
присваивание переменным удовлетворяет образцу в том случае, когда
конкретизированный образец имеется в базе данных.  Однако образец не
обязательно должен явно присутствовать в базе данных как утверждение.
Это может быть \index{ru}{утверждение|неявное||||}неявное утверждение, 
следующее из правила.  Например, запрос

\begin{Verbatim}[fontsize=\small]
(живет-около ?x (Битобор Бен))
\end{Verbatim}
выдает

\begin{Verbatim}[fontsize=\small]
(живет-около (Дум Хьюго) (Битобор Бен))
(живет-около (Фиден Кон) (Битобор Бен))
\end{Verbatim}
Чтобы найти всех программистов, живущих около Бена Битобора,
можно спросить

\begin{Verbatim}[fontsize=\small]
(and (должность ?x (компьютеры программист))
     (живет-около ?x (Битобор Бен)))
\end{Verbatim}

\index{ru}{рекурсия|в правилах||||}Как и в случае с составными 
процедурами, правила
можно использовать внутри других правил (как мы видели в
{\tt живет-около}),  и они даже могут быть рекурсивными.  Например,
правило

\begin{Verbatim}[fontsize=\small]
(rule (одчиняется ?staff-person ?boss) \index{ru}{подчиняется (правило)||||pd|}
      (or (начальник ?staff-prerson ?boss)
          (and (начальник ?staff-person ?middle-manager)
               (подчиняется ?middle-manager ?boss))))
\end{Verbatim}
говорит, что служащий подчиняется руководителю, если руководитель командует
им непосредственно или (рекурсивно) непосредственный начальник
служащего подчиняется руководителю.

\begin{exercise}{4.57}%
\label{EX4.57}%
Определите правило, которое говорит, что служащий 1
может заменить служащего 2, если либо служащий 1 имеет ту же
должность, что и служащий 2, либо человек с должностью
служащего 1 может выполнять работу служащего 2, и при этом служащие 1
и 2~--- разные люди.
Используя это правило, составьте запросы, которые находят следующую
информацию:

\begin{plainenum}
\item

все служащие, которые могут заменить П.Э.~Фекта.

\item
все служащие, которые могут заменить кого-то, кто
получает больше их самих, с указанием двух зарплат.
\end{plainenum}
\end{exercise}

\begin{exercise}{4.58}%
\label{EX4.58}%
Определите правило, которое говорит, что человек
<<независим>> в своем отделе, если он работает в этом отделе, но у
него нет начальника, который работает в том же отделе.
\end{exercise}

\begin{exercise}{4.59}%
\label{EX4.59}%
Бен Битобор пропускает слишком много совещаний.
Опасаясь потерять из-за этой глупой привычки работу, он решает, что с
ней надо что-то делать.  Он добавляет данные обо всех еженедельных
совещаниях в базу данных <<Микрошафт>> в виде следующих утверждений:

\begin{Verbatim}[fontsize=\small]
(совещание бухгалтерия (понедельник 9))
(совещание администрация (понедельник 10))
(совещание компьютеры (среда 15))
(совещание администрация (пятница 13))
\end{Verbatim}
Все эти утверждения сообщают о совещаниях отделов.  Кроме того, Бен
вводит утверждение о совещании всей компании, которое относится ко
всем отделам.  Все сотрудники компании должны ходить на это совещание.

\begin{Verbatim}[fontsize=\small]
(совещание вся-компания (среда 16))
\end{Verbatim}

\begin{plainenum}
\item

В пятницу утром Бен хочет спросить у базы данных,
какие совещания происходят в этот день.  Как ему надо составить
запрос?

\item
 Лиза П.~Хакер недовольна.  Она считает, что
намного полезнее было бы, если бы можно было спрашивать о совещаниях,
указывая свое имя.  Она пишет правило, гласящее, что совещания,
куда служащему надо ходить, это совещания всей компании и совещания
отдела, где он работает.  Допишите тело Лизиного правила.

\begin{Verbatim}[fontsize=\small]
(rule (время-совещания ?person ?day-and-time)
      \textit{$\langle$тело$\rangle$})
\end{Verbatim}

\item
 Лиза приходит на работу в среду и хочет узнать,
на какие совещания ей нужно идти в этот день.  Если имеется правило
{\tt время-совещания}, то какой запрос ей надо подать?
\end{plainenum}
\end{exercise}

\begin{exercise}{4.60}%
\label{EX4.60}%
\nopagebreak
\samepage
Подав запрос\index{ru}{живет-около (правило)||||p|(упр.~4.60)}

\begin{Verbatim}[fontsize=\small]
(живет-около ?person (Хакер Лиза П))
\end{Verbatim}
Лиза П.~Хакер может найти людей, которые живут с ней рядом, и с
которыми она вместе может ездить на работу.  С другой стороны, когда
она пытается найти все пары людей, живущих друг около друга, при
помощи запроса

\begin{Verbatim}[fontsize=\small]
(живет-около ?person-1 ?person-2)
\end{Verbatim}
она видит, что каждая подходящая пара людей попадается в выводе
дважды, например

\begin{Verbatim}[fontsize=\small]
(живет-около (Хакер Лиза П) (Фект Пабло Э))
(живет-около (Фект Пабло Э) (Хакер Лиза П))
\end{Verbatim}
Почему так происходит?  Можно ли получить список людей, живущих рядом друг
с другом, в котором каждая пара появлялась бы по одному разу?
Ответ объясните.
\end{exercise}

\paragraph{Логика как программы}

Можно рассматривать правило как своего рода логическую
импликацию: {\em если} присваивание значений переменным образца
удовлетворяет телу, {\em то} оно удовлетворяет заключению.
Следовательно, можно считать, что язык запросов способен производить
\index{ru}{язык запросов|логический вывод||||}\index{ru}{логический 
вывод||logical deduction|||}\index{en}{logical deduction||логический 
вывод|||}{\em логический вывод} (logical deduction) на основании
правил.  В качестве примера рассмотрим операцию {\tt append},
описанную в начале раздела~\ref{LOGIC-PROGRAMMING}.  Как
мы уже сказали, {\tt append} характеризуется следующими двумя
правилами:

\begin{plainlist}
\item
Для любого списка {\tt y}, {\tt append} пустого
списка и {\tt y} дает {\tt y}

\item
Для любых {\tt u}, {\tt v},
{\tt y} и {\tt z}, {\tt append} от {\tt (cons u
v)} и {\tt y} дает {\tt (cons u z)}, если
{\tt append} от {\tt v} и {\tt y} дает
{\tt z}.
\end{plainlist}

Чтобы выразить это в нашем языке запросов, мы определяем
два правила для отношения

\begin{Verbatim}[fontsize=\small]
(append-to-form x y z)
\end{Verbatim}
которое можно интерпретировать как <<{\tt append} от
{\tt x} и {\tt y} дает {\tt z}>>:

\begin{Verbatim}[fontsize=\small]
(rule (append-to-form () ?y ?y))\index{ru}{append-to-form (правила)||||pd|}

(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
\end{Verbatim}
\index{ru}{точечная запись|в правилах языка 
запросов||||}\index{ru}{правило (в языке запросов)|без тела||||}В первом 
правиле нет тела, и это означает, что следствие выполняется
для любого значения {\tt ?y}.  Обратите также внимание, как во
втором правиле {\tt car} и {\tt cdr} списка изображаются
с использованием точечной записи.

При помощи этих двух правил мы можем формулировать запросы,
которые вычисляют {\tt append} от двух списков:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод запроса:}
(append-to-form (a b) (c d) ?z)
\textit{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
\end{Verbatim}
Удивительнее то, что мы с помощью тех же правил можем задать вопрос
<<Какой список, будучи добавлен к {\tt (a b)}, дает {\tt (a b
c d)}?>> Это делается так:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод запроса:}
(append-to-form (a b) ?y (a b c d))
\textit{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
\end{Verbatim}
Можно также запросить все пары списков, {\tt append} от
которых дает {\tt (a b c d)}:

\begin{Verbatim}[fontsize=\small]
\textit{;;; Ввод запроса:}
(append-to-form ?x ?y (a b c d))
\textit{;;; Результаты запроса:}
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
\end{Verbatim}

Может показаться, что, используя правила для вывода
ответов на перечисленные запросы, система демонстрирует немалый
интеллект.  На самом же деле, как мы увидим в следующем разделе,
при разборе правил она следует хорошо определенному алгоритму.  К
сожалению, хотя в случае с {\tt append} результаты впечатляют,
в более сложных ситуациях общие методы могут не сработать, как мы
увидим в 
разделе~\ref{IS-LOGIC-PROGRAMMING-MATHEMATICAL-LOGIC}.

\begin{exercise}{4.61}%
\label{EX4.61}%
Следующие правила определяют отношение
{\tt next-to}, которое находит в списке соседние элементы:

\begin{Verbatim}[fontsize=\small]
(rule (?x next-to ?y in (?x ?y . ?u)))\index{ru}{next-to (правила)||||pd|(упр.~4.61)}

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
\end{Verbatim}
Каков будет ответ на следующие запросы?

\begin{Verbatim}[fontsize=\small]
(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
\end{Verbatim}
\end{exercise}

\begin{exercise}{4.62}%
\label{EX4.62}%
Определите правила, которые реализуют операцию
{\tt last-pair}\index{ru}{last-pair|правила|||p|(упр.~4.62)}
из упражнения~\ref{EX2.17}, которая
возвращает последнюю пару непустого списка.  Проверьте Ваши правила на
таких запросах, как {\tt (last-pair (3) ?x)}, {\tt (last-pair
(1 2 3) ?x)} и {\tt (last-pair (2 ?x) (3))}.  Правильно
ли Ваши правила работают с запросами вида {\tt (last-pair ?x
(3))}?
\end{exercise}

\begin{exercise}{4.63}%
\label{EX4.63}%
Следующая база данных (см. книгу\index{ru}{Бытие|||||(упр.~4.63)}
Бытия, 4) содержит генеалогию сыновей \index{ru}{Ада, 
сыновья|||||(упр.~4.63)} Ады вплоть до Адама, через Каина:

\begin{Verbatim}[fontsize=\small]
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)
\end{Verbatim}
Сформулируйте правила, такие как <<Если $S$ сын $F$, а
$F$ сын $G$, то $S$ внук
$G$>> и <<Если $W$ жена $M$, а
$S$ сын $W$, то $S$ также сын
$M$>> (предполагается, что в библейские времена это в
большей степени соответствовало истине, чем теперь).  Эти правила
должны позволить системе найти внука Каина; сыновей Ламеха; внуков
Мафусала. (В упражнении~\ref{EX4.69} можно найти правила,
с помощью которых выводятся более сложные родственные связи.)
\end{exercise}

\subsection{Как действует система обработки запросов}
\label{HOW-THE-QUERY-SYSTEM-WORKS}%

\index{ru}{интерпретатор языка запросов|обзор||||}В 
разделе~\ref{IMPLEMENTING-THE-QUERY-SYSTEM}
мы представим реализацию интерпретатора запросов в виде набора
процедур.  В этом разделе дается обзор системы и объясняется ее общая
структура, без низкоуровневых деталей реализации.  После
того, как мы опишем интерпретатор, нам легче будет понять его
ограничения и некоторые тонкости, в которых логические операции языка
запросов отличаются от операций математической логики.

Должно быть очевидно, что вычислителю запросов требуется
какая-то разновидность поиска, чтобы сопоставлять запросы
с фактами и правилами в базе данных. Одним из способов сделать это
была бы реализация системы запросов в виде недетерминистской программы
с использованием {\tt amb}-интерпретатора из 
раздела~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}
(см.~упражнение~\ref{EX4.78}).  Другая возможность состоит
в том, чтобы управлять поиском при помощи потоков.  Наша реализация
использует этот второй подход.

Запросная система организована вокруг двух основных
операций, которые называются \index{ru}{интерпретатор языка
  запросов|сопоставление с образцом||||}\index{ru}{сопоставление с
  образцом||pattern matching|||}\index{en}{pattern
  matching||сопоставление с образцом|||} {\em сопоставление с образцом} 
(pattern matching) и 
\index{ru}{унификация||unification|||}\index{en}{unification||унификация|||}{\em 
унификация} (unification).  Сначала мы опишем
сопоставление с образцом и объясним, как эта операция, вместе с
организацией информации в виде потоков кадров, позволяет нам
реализовывать как простые, так и составные запросы.  Затем мы
обсудим унификацию~--- обобщение сопоставления с образцом, которое
требуется для реализации правил.  Наконец, мы покажем, как
части интерпретатора связываются воедино процедурой, 
классифицирующей выражения, подобно тому, как  {\tt eval}
разбирает выражения в интерпретаторе, описанном в 
разделе~\ref{THE-METACIRCULAR-EVALUATOR}.

\paragraph{Сопоставление с образцом}

\index{ru}{сопоставитель||pattern matcher|||}\index{en}{pattern 
matcher||сопоставитель|||}{\em Сопоставитель} (pattern matcher)~--- это
программа, которая проверяет, соответствует ли некоторая структура
данных указанному образцу.  Например, список {\tt ((a b) c (a
b))} соответствует образцу {\tt (?x c ?x)} при значении
переменной {\tt ?x}, равном {\tt (a b)}. Этот же список
соответствует образцу {\tt (?x ?y ?z)} при значениях переменных
{\tt ?x} и {\tt ?z}, равных {\tt (a b)} и
значении {\tt ?y}, равном {\tt b}.  Однако он не
соответствует образцу {\tt (?x a ?y)}, поскольку этот образец
требует, чтобы вторым элементом списка был символ {\tt a}.

Сопоставитель, который используется в запросной системе,
принимает на входе образец, структуру данных и 
\index{ru}{кадр (в интерпретаторе 
запросов)||frame|||}\index{en}{frame||кадр (в интерпретаторе 
запросов)|||}{\em кадр} (frame), в котором указываются связывания для
различных переменных образца.  Он проверяет, соответствует ли
структура данных образцу без противоречия со
связываниями переменных, уже находящимися в кадре.  Если да, то сопоставитель
возвращает кадр, дополнив его связываниями, определенными во время
сопоставления.  Если нет, он указывает, что сопоставление
неудачно.

Например, сопоставление образца {\tt (?x ?y ?x)}
со списком {\tt (a b a)} при пустом начальном кадре вернет
кадр, в котором переменная {\tt ?x} связана со значением
{\tt a}, а {\tt ?y} со значением {\tt b}.
Попытка сопоставления того же списка с тем же образцом при начальном
кадре, в котором указывается, что {\tt ?y} связывается с
{\tt a}, окажется неудачной.  Попытка сопоставления с теми же
данными и образцом, при начальном кадре, в котором {\tt ?y}
связана со значением {\tt b}, а {\tt ?x} несвязана,
вернет исходный кадр, дополненный связыванием {\tt a} для
{\tt ?x}.

\index{ru}{простой запрос|обработка||||}Сопоставитель~--- единственный
механизм, необходимый для 
обработки простых образцов, не содержащих правил.  Например, чтобы
обработать запрос:

\begin{Verbatim}[fontsize=\small]
(должность ?x (компьютеры программист))
\end{Verbatim}
--- мы просматриваем все утверждения в базе данных и выбираем те, которые
соответствуют образцу при пустом начальном кадре.  Для каждого
найденного утверждения мы подставляем в образец значение
{\tt ?x} из кадра, полученного при сопоставлении.

\paragraph{Потоки кадров}

\index{ru}{интерпретатор языка запросов|потоки 
кадров||||}\index{ru}{поток(и)|используемые в интерпретаторе языка 
запросов||||}Проверка образцов по отношению к кадрам организована
посредством потоков.  Получив кадр, процесс сопоставления просматривает
элементы базы данных один за другим.  Для каждого входа базы данных
сопоставитель порождает либо специальный символ, указывающий,
что сопоставление оказалось неудачным, либо расширение кадра.
Из результатов сопоставления всей базы данных собирается поток, и
этот поток пропускается через фильтр, отбрасывающий неудачи.  Получается
поток всех кадров, которые расширяют данный кадр за счет сопоставления с
каким-либо утверждением из
базы\footnote{\index{ru}{эффективность|доступа к базе
    данных||||п}Поскольку сопоставление~--- в общем случае весьма дорогая
операция, нам хотелось бы избежать применения полного сопоставителя к
каждому элементу базы данных.  Обычное решение этой проблемы~--- разбить
процесс на грубое (быстрое) сопоставление и окончательное
сопоставление.  Грубое сопоставление отфильтровывает базу и находит
кандидатуры на окончательное сопоставление.  Если действовать
аккуратно, можно построить базу данных таким образом, что часть работы
грубого сопоставителя проделывается при построении базы, а не в момент
отбора кандидатов.  Это называется 
\index{ru}{индексирование базы данных||database 
indexing|||п}\index{en}{database indexing||индексирование базы 
данных|||п}{\em индексированием} (indexing)\index{ru}{база 
данных|индексирование||||п} базы данных.
Существует множество приемов и схем индексирования баз данных.  Наша
реализация, которую мы описываем 
разделе~\ref{IMPLEMENTING-THE-QUERY-SYSTEM}, содержит
простейший вариант такой оптимизации.}.


\begin{cntrfig}
\input{xfig-mod/4-4.eepic}
%{\small входной поток кадров\\
%запрос\\
%выходной поток кадров, отфильтрованный и расширенный\\
%поток утверждений из базы данных}
\caption{Запрос обрабатывает поток кадров}
\label{P4.4}%
\end{cntrfig}

В нашей системе запрос принимает входной поток кадров и
для каждого кадра применяет вышеописанную операцию сопоставления, как
показано на рис.~\ref{P4.4}.  А именно, для каждого кадра
во входном потоке запрос генерирует новый поток, содержащий все
расширения этого кадра, порожденные сопоставлением с утверждениями из
базы.  Затем все эти потоки собираются в один громадный поток, который
содержит все возможные расширения всех кадров входного потока.  Этот
поток и есть результат запроса.

\index{ru}{простой запрос|обработка||||}Чтобы 
ответить на простой запрос, мы применяем его к
потоку, который состоит из одного пустого кадра.  Поток на выходе
содержит все расширения пустого кадра (то есть, все ответы на наш
запрос).  Затем на основе этого потока кадров создается поток
копий исходного образца запроса, в которых переменные конкретизированы
значениями из всех кадров, и этот поток в конце концов
печатается.

\paragraph{Составные запросы}

\begin{cntrfig}
\input{xfig-mod/4-5.eepic}
\caption{Комбинация двух запросов через {\tt and}
\index{ru}{and (язык запросов)|обработка|||p|}осуществляется 
последовательной обработкой потока кадров.}
\label{P4.5}%

\end{cntrfig}

Изящество реализации с потоками кадров по-настоящему
проявляется при работе с составными запросами.  При \index{ru}{составной 
запрос|обработка||||}обработке 
составных запросов мы пользуемся тем, что наш сопоставитель умеет
требовать, чтобы сопоставление не противоречило указанному кадру.
Например, чтобы обработать {\tt and} от двух запросов, скажем,

\begin{Verbatim}[fontsize=\small]
(and (может-замещать ?x (компьютеры программист стажер))
     (должность ?person ?x))
\end{Verbatim}
(неформально, <<найти всех сотрудников, способных выполнять
работу про\-грам\-мис\-та-стажера>>), сначала мы находим все записи базы,
отвечающие образцу

\begin{Verbatim}[fontsize=\small]
(может-замещать ?x (компьютеры программист стажер))
\end{Verbatim}
Получается поток кадров, каждый из которых содержит связывание для
{\tt ?x}.  Затем для всех кадров этого потока мы находим
записи, соответствующие образцу

\begin{Verbatim}[fontsize=\small]
(должность ?person ?x)
\end{Verbatim}
таким образом, чтобы не менять уже известное связывание переменной
{\tt ?x}.  Каждое новое сопоставление породит кадр, в котором
будут содержаться связывания для {\tt ?x} и
{\tt ?person}. {\tt And} от двух запросов можно
рассматривать как последовательное применение двух составляющих запросов,
как показано на рис.~\ref{P4.5}.  Кадры, прошедшие через
первый запрос, фильтруются и расширяются вторым запросом.


\begin{cntrfig}
\input{xfig-mod/4-6.eepic}
%{\small входной поток кадров\\
%выходной поток кадров\\
%база данных}
\caption{Комбинация двух запросов через
{\tt or} осуществляется путем параллельной обработки потока кадров
и слияния результатов.
\index{ru}{or (язык запросов)|обработка|||p|}}
\label{P4.6}%
\end{cntrfig}

На рисунке~\ref{P4.6} показан аналогичный
метод для вычисления {\tt or} от двух запросов через
параллельное выполнение двух составляющих запросов.  Каждый запрос отдельно
расширяет входной поток кадров.  Затем два получившихся потока
сливаются и образуют окончательный поток-результат.

\index{ru}{эффективность|обработки  запросов||||}Даже из этого
высокоуровневого описания ясно, что
обработка составных запросов может занимать много времени.  Например,
поскольку запрос может породить более одного выходного кадра для
каждого входного, а каждый подзапрос в {\tt and} принимает
входные кадры от предыдущего подзапроса, в наихудшем случае число
сопоставлений, которые должен произвести запрос {\tt and},
растет экспоненциально с числом подзапросов 
(см. упражнение~\ref{EX4.76})\footnote{Впрочем, такой экспоненциальный 
взрыв в запросах {\tt and} происходит редко, поскольку, как правило,
дополнительные условия не увеличивают, а уменьшают число порождаемых
кадров.}.
Несмотря на то, что системы для обработки простых запросов вполне могут быть
практически полезны, обработка сложных запросов чрезвычайно 
трудоемка\footnote{Имеется обширная литература по системам управления
базами данных, в которой основной темой является эффективная
обработка сложных запросов.}.

С точки зрения потока кадров, запрос {\tt not}\index{ru}{not (язык 
запросов)|вычисление|||p|}
работает как фильтр, уничтожающий все кадры, для которых его подзапрос
можно удовлетворить.  Например, имея образец

\begin{Verbatim}[fontsize=\small]
(not (должность ?x (компьютеры программист)))
\end{Verbatim}
мы для каждого кадра во входном потоке пытаемся породить расширенные
кадры, которые удовлетворяют образцу {\tt (должность ?x (компьютеры
про\-г\-раммист))}.  Все кадры, для которых такие расширения
существуют, мы изымаем из входного потока.  В результате получается
поток, состоящий только из тех кадров, в которых связывание для
{\tt ?x} не удовлетворяет {\tt (должность ?x (компьютеры
программист))}.  Например, при обработке запроса
{\sloppy

} %HERE395

\begin{Verbatim}[fontsize=\small]
(and (начальник ?x ?y)
     (not (должность ?x (компьютеры программист))))
\end{Verbatim}
первый подзапрос породит кадры со связанными значениями
{\tt ?x} и {\tt ?y}.  Затем выражение {\tt not}
отфильтрует этот поток, удалив все кадры, в которых значение
{\tt ?x} удовлетворяет ограничению, что {\tt ?x}
является программистом\footnote{Существует тонкое различие между реализацией
{\tt not} в виде фильтра и значением отрицания в математической
логике. См.~раздел~\ref{IS-LOGIC-PROGRAMMING-MATHEMATICAL-LOGIC}.}.

Особая форма {\tt lisp-value}
\index{ru}{lisp-value (язык запросов)|вычисление|||p|}
реализуется при
помощи подобного же фильтра для потоков кадров.  При помощи каждого
кадра из потока мы конкретизируем все переменные образца, а затем
применяем лисповский предикат.  Все кадры, для которых предикат
оказывается ложным, мы удаляем из входного потока.

\paragraph{Унификация}

\index{ru}{интерпретатор языка запросов|унификация||||}Чтобы обрабатывать 
правила языка запросов, нам нужно
уметь находить правила, в которых заключения соответствуют данному
входному образцу.  Заключения правил подобны утверждениям, но только в
них могут содержаться переменные, так что нам требуется обобщенный
вариант сопоставления с образцом,~--- называемый 
\index{ru}{унификация||unification|||}\index{en}{unification||унификация|||}{\em 
унификация} (unification),~--- в котором как
<<образец>>, так и <<данные>> могут содержать переменные.

Унификатор берет два образца, в каждом из которых могут
быть константы и переменные, и определяет, возможно ли присвоить
переменным значения, которые сделают два образца одинаковыми.  Если да,
то он возвращает кадр, содержащий эти значения.  Например, при
унификации {\tt (?x a ?y)} и {\tt (?y ?z a)} получится
кадр, в котором все три переменные {\tt ?x}, {\tt ?y} и
{\tt ?z} связаны со значением {\tt a}.  С другой
стороны, унификация {\tt (?x ?y a)} и {\tt (?x b ?y)}
потерпит неудачу, поскольку не имеется такого значения для
{\tt ?y}, которое бы сделало два образца одинаковыми.  (Чтобы
вторые элементы образцов оказались равными, {\tt ?y} должно
равняться {\tt b}; однако, чтобы совпали третьи элементы,
{\tt ?y} обязан быть {\tt a}.) Подобно сопоставителю,
унификатор, используемый в системе запросов, принимает на входе кадр и
проводит унификации, не противоречащие содержимому этого кадра.

Алгоритм унификации~--- самая технически сложная часть
запросной системы.  При наличии сложных образцов может показаться, что
для унификации требуются дедуктивные способности.  Например, чтобы
унифицировать {\tt (?x ?x)} и {\tt ((a ?y c) (a b ?z))},
алгоритм обязан вычислить, что {\tt ?x} должен быть равен
{\tt (a b c)}, {\tt ?y} должен быть {\tt b}, а
{\tt ?z} должен быть равен {\tt c}. Можно считать, что
этот процесс решает систему уравнений, описывающую компоненты
образцов.  В общем случае это будут взаимозависимые уравнения, для
решения которых требуются существенные преобразования\footnote{В 
одностороннем сопоставлении с образцом все
уравнения, которые содержат переменные, заданы явно и уже решены
относительно неизвестного (переменной образца).}.
К примеру,
унификацию {\tt (?x ?x)} и {\tt ((a ?y c) (a b ?z))}
можно рассматривать как систему уравнений

\begin{Verbatim}[fontsize=\small]
?x = (a ?y c)
?x = (a b ?z)
\end{Verbatim}
Из этих уравнений следует, что

\begin{Verbatim}[fontsize=\small]
(a ?y c) = (a b ?z)
\end{Verbatim}
а отсюда, в свою очередь, что

\begin{Verbatim}[fontsize=\small]
a = a, ?y = b, c = ?z
\end{Verbatim}
и, следовательно,

\begin{Verbatim}[fontsize=\small]
?x = (a b c)
\end{Verbatim}

\index{ru}{сопоставление с образцом|vs. 
унификация||||}\index{ru}{унификация|vs. сопоставление с образцом||||}При 
успешном сопоставлении с образцом все переменные 
оказываются связанными, и значения, с которыми они связаны, содержат
только константы.  Это верно и для всех примеров унификации, которые
мы до сих пор рассмотрели.  Однако в общем случае успешная унификация
может не полностью определить значения переменных; какие-то переменные
могут остаться неопределенными, а значения других сами могут содержать
переменные.

Рассмотрим унификацию {\tt (?x a)} и {\tt ((b ?y)
?z)}.  Можно вычислить, что {\tt ?x $=$ (b ?y)}, а
{\tt a $=$ ?z}, но ничего больше нельзя сказать о значениях
{\tt ?x} и {\tt ?y}.  Унификация заканчивается успешно,
поскольку, естественно, можно сделать образцы одинаковыми, присвоив
значения {\tt ?x} и {\tt ?y}.  Поскольку сопоставление
никак не ограничивает значение, которое может принимать переменная
{\tt ?y}, никакого ее значения не оказывается в
кадре-результате.  Однако результат ограничивает значение
{\tt ?x}.  Какое бы значение не имела переменная
{\tt ?y}, {\tt ?x} должен равняться {\tt (b
?y)}.  Таким образом, в кадр помещается связывание
{\tt ?x} со значением {\tt (b ?y)}.  Если позже значение
{\tt ?y} оказывается определенным (путем сопоставления с
образцом или унификации, которая должна соответствовать этому кадру) и
добавляется в кадр, значение, связанное с {\tt ?x}, будет
ссылаться на него\footnote{Можно считать, что унификация находит наиболее 
общий образец, который является специализацией двух входных образцов.  А 
именно, унификация  {\tt (?x a)} и {\tt ((b ?y) ?z)} равна
{\tt ((b ?y) a)}, а унификация {\tt (?x a ?y)} и
{\tt (?y ?z a)}, описанная выше, равна {\tt (a a a)}.
Однако в нашей реализации удобнее считать, что результатом унификации
является не образец, а кадр.}.

\paragraph{Применение правил}

\index{ru}{правило (в языке запросов)|применение||||}Главной операцией в 
компоненте запросной системы, который производит логический вывод на основе
правил, является унификация.  Чтобы увидеть, как этот компонент работает, 
рассмотрим обработку запроса, содержащего обращение к правилу, например:
\begin{Verbatim}[fontsize=\small]
(живет-около ?x (Хакер Лиза П))
\end{Verbatim}
Обрабатывая этот запрос, сначала мы при помощи описанной ранее
обыкновенной процедуры сопоставления смотрим, имеются
ли в базе данных утверждения, которые сопоставляются с данным
образцом.  (В данном случае таковых не окажется, поскольку в нашей базе
данных нет никаких прямых утверждений о том, кто около кого живет.)
На следующем шаге мы пытаемся унифицировать образец-запрос с
заключением каждого правила.  Мы обнаруживаем, что образец
унифицируется с заключением правила
\begin{Verbatim}[fontsize=\small]
(rule (живет-около ?person-1 ?person-2)
      (and (адрес ?person-1 (?town . ?rest-1))
           (адрес ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{Verbatim}
и получается кадр, в котором переменная {\tt ?person-2} связана со значением
{\tt (Хакер Лиза П)}, а переменная {\tt ?x} связана с
(должна иметь то же значение, что и) {\tt ?person-1}.  Теперь по
отношению к этому кадру мы вычисляем составной запрос, содержащийся в
теле правила.  Успешные сопоставления расширят кадр, сообщив
значение переменной {\tt ?person-1}, а соответственно, и
{\tt ?x}, которую мы можем использовать при конкретизации
исходного образца-запроса.

В общем случае обработчик запросов при применении правила, когда он 
пытается распознать образец-запрос в кадре, который содержит связывания 
для некоторых переменных образца,  использует следующий метод:

\begin{plainlist}
\item
Унифицировать запрос с заключением правила и
получить (если унификация успешна) расширение исходного кадра.

\item
По отношению к расширенному кадру вычислить запрос,
который является телом правила.
\end{plainlist}

\index{ru}{интерпретатор языка запросов|vs. интерпретатор для 
Лиспа||||}Обратите внимание, насколько это похоже на метод
применения процедуры в интерпретаторе {\tt eval/apply} для
Лиспа:

\begin{plainlist}
\item
Связать параметры процедуры с ее аргументами и
получить кадр, расширяющий исходное окружение процедуры.

\item
По отношению к расширенному окружению вычислить
выражение, которое является телом процедуры.
\end{plainlist}
Подобие двух вычислителей неудивительно.  Точно так же, как в
Лиспе средством абстракции являются определения процедур, в языке
запросов средством абстракции являются определения правил.  В каждом
случае мы развертываем абстракцию, создавая соответствующие связывания
и вычисляя тело правила либо процедуры по отношению к расширенной
среде.

\paragraph{Простые запросы}

\index{ru}{простой запрос|обработка||||}В этом разделе мы уже 
рассматривали, как вычислять простые
запросы при отсутствии правил.  Теперь, разобравшись, как
применяются правила, мы можем описать, как простые запросы вычисляются с
помощью как правил, так и утверждений.

Получая запрос-образец и поток кадров, мы порождаем для
каждого входного кадра два новых потока:

\begin{plainlist}
\item
поток расширенных кадров, получаемых сопоставлением
образца со всеми утверждениями базы данных (при помощи сопоставителя),
а также

\item
поток расширенных кадров, полученных применением
всех возможных правил (при помощи 
унификатора)\footnote{\index{ru}{сопоставление с образцом|vs. 
унификация||||п}\index{ru}{унификация|vs. сопоставление с 
образцом||||п}Поскольку унификация является обобщением
сопоставления, можно было бы упростить систему и порождать оба потока
с помощью унификатора.  Однако обработка простого случая с помощью
обычного сопоставителя показывает, как сопоставление (а не полноразмерная
унификация) может само по себе быть полезным.}.
\end{plainlist}
Соединение двух этих потоков порождает поток, который состоит изо всех
способов, которыми данный образец можно удовлетворить в соответствии с
исходным кадром.  Эти потоки (по одному на каждый кадр входного
потока) соединяются, и получается единый большой поток.  Окончательный 
поток, таким образом, состоит изо всех способов, которыми какой-либо кадр 
входного потока может быть расширен так, чтобы получалось сопоставление с
данным запросом.

\paragraph{Вычислитель запросов и управляющий цикл}

\index{ru}{интерпретатор языка запросов|вычислитель запросов||||}Несмотря 
на сложность встроенных операций сопоставления,
система организована подобно  \index{ru}{интерпретатор языка запросов|vs. 
интерпретатор для Лиспа||||} интерпретатору любого языка.  Процедура,
координирующая операции сопоставления, называется  
\index{ru}{qeval||||p|}{\tt qeval} и
играет роль, аналогичную процедуре {\tt eval} для
Лиспа. {\tt Qeval} принимает на входе запрос и поток кадров.
Ее выходом служит поток кадров, соответствующих успешным
сопоставлениям с запросом, которые расширяют какой-либо кадр во
входном потоке, как показано на рис.~\ref{P4.4}.  Подобно
{\tt eval}, {\tt qeval} распознает
различные типы выражений (запросов) и для каждого из них вызывает
соответствующую процедуру.  Имеется по процедуре для каждой особой
формы ({\tt and}, {\tt or}, {\tt not} и {\tt lisp-value}) и
еще одна для простых запросов.

\index{ru}{управляющий цикл|в  интерпретаторе запросов||||}Управляющий 
цикл, аналогичный процедуре  \index{ru}{интерпретатор языка 
запросов|управляющий цикл||||}{\tt driver-loop} из других интерпретаторов 
этой главы, считывает запросы с терминала.  Для каждого запроса он вызывает
{\tt qeval} с запросом и потоком, состоящим из одного пустого
кадра.  Получается поток всех возможных сопоставлений (всех возможных
расширений пустого кадра).  Для каждого кадра в выходном потоке
управляющий цикл конкретизирует входной запрос с использованием
значений переменных, имеющихся в кадре.  Затем этот поток конкретизированных
запросов печатается\footnote{Мы используем \index{ru}{интерпретатор языка 
запросов|потоки кадров||||п}\index{ru}{поток(и)|используемые в 
интерпретаторе языка запросов||||п}потоки (а не списки) кадров потому, что
рекурсивное применение правил может порождать бесконечное число
значений, удовлетворяющих запросу.  Здесь существенно задержанное
вычисление, осуществляемое потоками: система будет печатать ответы
один за другим по мере их порождения, независимо от того, получается
ли конечное или бесконечное количество ответов.}.

Кроме того, управляющий цикл распознает особую команду
{\tt assert!}, которая говорит, что на вход поступает не
\index{ru}{assert! (интерпретатор запросов)||||p|}запрос, а  
\index{ru}{интерпретатор языка запросов|добавление утверждения или 
правила||||} новое утверждение или правило, которое следует добавить в
базу данных.  Например,

\begin{Verbatim}[fontsize=\small]
(assert! (должность (Битобор Бен) (компьютеры гуру)))

(assert! (rule (шишка ?person)
               (and (начальник ?middle-manager ?person)
                    (начальник ?x ?middle-manager))))
\end{Verbatim}

\subsection{Является ли логическое программирование математической
логикой?}
\label{IS-LOGIC-PROGRAMMING-MATHEMATICAL-LOGIC}%


\index{ru}{логическое программирование|vs. математическая 
логика||||}\index{ru}{язык запросов|vs. математическая логика||||} На 
первый взгляд может показаться, что средства
комбинирования, используемые в языке запросов, совпадают с операторами
математической логики~--- {\em и} ({\tt and}),
{\em или} ({\tt or}) и отрицанием ({\tt not}), а
при применении правил языка запросов производится корректный
\index{ru}{логический вывод|||||}логический вывод\footnote{То, что 
конкретный метод логического вывода корректен
--- утверждение не тривиальное.  Требуется доказать, что исходя из
истинных посылок, можно придти только к истинным заключениям.  В
применении правил используется \index{ru}{modus ponens|||||п}{\em modus 
ponens}, известный
метод вывода, который говорит, что если истинны утверждения
$A$ и {\em из $A$ следует
$B$}, то можно заключить истинность утверждения
$B$.}.
Однако такая идентификация языка запросов с математической логикой
неверна, поскольку язык запросов обладает 
\index{ru}{структура управления||control structure|||}\index{en}{control 
structure||структура управления|||}{\em структурой управления} (control 
structure),
которая интерпретирует логические утверждения процедурным образом.
Часто из этой структуры управления можно извлечь пользу.  Например,
чтобы найти начальников всех программистов, можно сформулировать запрос
двумя логически эквивалентными способами:

\begin{Verbatim}[fontsize=\small]
(and (должность ?x (компьютеры программист))
     (начальник ?x ?y))
\end{Verbatim}
и

\begin{Verbatim}[fontsize=\small]
(and (начальник ?x ?y)
     (должность ?x (компьютеры программист)))
\end{Verbatim}
Если в компании 
\index{ru}{бюрократия||bureaucracy|||}\index{en}{bureaucracy||бюрократия|||}намного 
больше начальников, чем программистов (обычный
случай), то первую форму использовать выгоднее, чем вторую, поскольку
для каждого промежуточного результата (кадра), порождаемого первым
подзапросом {\tt and}, требуется просмотреть базу данных.

Цель логического программирования состоит в том, чтобы дать
программисту способ разбить вычислительную задачу на две отдельные
подзадачи: \index{ru}{декларативное vs. императивное знание|и логическое 
программирование||||}\index{ru}{императивное vs. декларативное знание|и 
логическое программирование||||}<<что>> требуется посчитать и <<как>> это 
сделать.  Этого 
добиваются, выделив подмножество утверждений математической логики ---
достаточно мощное, чтобы описать все, что захочется вычислить,
но при этом достаточно слабое, чтобы иметь управляемую процедурную
реализацию.  Идея состоит в том, чтобы, с одной стороны, программа,
выраженная на языке логического программирования, была эффективной,
и компьютер мог бы ее исполнить.  Управление (<<как>>
считать) определяется порядком вычислений языка.  У нас должна быть
возможность определять порядок выражений и порядок подвыражений в них
так, чтобы вычисление проходило правильным и эффективным способом.  В
то же самое время мы должны быть способны рассматривать результат
вычислений (<<что>> считать) как простое следствие законов логики.

Наш язык запросов можно рассматривать в качестве именно
такого процедурно интерпретируемого подмножества математической
логики.  Утверждение представляет простой факт (атомарную
пропозицию).  Правило представляет импликацию, говорящую, что
заключение истинно в случаях, когда истинно тело правила.  Правило
обладает естественной процедурной интерпретацией: чтобы доказать
заключение правила, требуется доказать его тело.  Следовательно,
правила описывают вычисления.  Однако поскольку правила можно
рассматривать и как формулы математической логики, мы можем оправдать
любой <<вывод>>, производимый логической программой, показав, что того
же результата можно достичь, работая строго в рамках логики\footnote{Это 
утверждение нужно ограничить соглашением:
говоря о <<выводе>>, производимом логической программой, мы
предполагаем, что вычисление имеет конец.  К сожалению, даже это
ограниченное утверждение оказывается ложным для нашей реализации языка
запросов (а также для программ на Прологе и большинстве других
современных математических языков) из-за использования
{\tt not} и {\tt lisp-value}.  Как будет описано ниже,
примитив {\tt not}, реализованный в языке запросов, не всегда
имеет то же значение, что отрицание в математической логике, а
использование {\tt lisp-value} вызывает дополнительные
сложности.  Можно было бы реализовать язык, согласованный с
математической логикой, если просто убрать из него {\tt not} и
{\tt lisp-value} и согласиться писать программы с
использованием исключительно простых запросов, {\tt and} и
{\tt or}.  Однако при этом оказалась бы ограничена
выразительная сила языка.  Одна из основных тем исследований в
логическом программировании~--- поиск способов более тесного согласования с
математической логикой без чрезмерной потери выразительной силы.}.

\paragraph{Бесконечные циклы}

\index{ru}{интерпретатор языка запросов|бесконечные циклы||||}Вследствие 
процедурной интерпретации логических
программ для решения некоторых задач можно построить безнадежно
неэффективные программы.  Частным случаем неэффективности является
ситуация, когда программа при работе над выводом впадает в
бесконечный цикл. Возьмем простой пример: предположим, что мы
строим базу данных знаменитых супружеских пар, в том числе

\begin{Verbatim}[fontsize=\small]
(assert! (супруг Минни Микки))
\end{Verbatim}
\index{ru}{Маус, Минни и Микки||Mickie and Minnie 
Mouse||n|}\index{en}{Mickie and Minnie Mouse||Маус, Минни и Микки||n|}Если 
теперь мы спросим

\begin{Verbatim}[fontsize=\small]
(супруг Микки ?who)
\end{Verbatim}
мы не получим ответа, поскольку система не знает, что если
$A$ является супругом $B$, то $B$ является
супругом $A$. Поэтому мы вводим правило

\begin{Verbatim}[fontsize=\small]
(assert! (rule (супруг ?x ?y)
               (супруг ?y ?x)))
\end{Verbatim}
и снова делаем запрос

\begin{Verbatim}[fontsize=\small]
(супруг Микки ?who)
\end{Verbatim}
К сожалению, это вводит систему в бесконечный цикл следующим образом:

\begin{plainlist}
\item
Система обнаруживает, что применимо правило
{\tt супруг}; а именно, заключение {\tt (су\-пруг ?x ?y)}
успешно унифицируется с образцом-запросом {\tt (су\-пруг Микки
?who)} и получается кадр, в котором переменная {\tt ?x}
связана со значением {\tt Микки}, а переменная {\tt ?y}
со значением {\tt ?who}.  Интерпретатор должен, таким образом,
выполнить в этом кадре запрос {\tt (супруг ?y ?x)}~--- в
сущности, выполнить запрос {\tt (супруг ?who Микки)}.

\item
Один ответ находится как утверждение в базе данных:
{\tt (супруг Минни Микки)}.

\item
Применимо также и правило {\tt супруг}, так
что интерпретатор снова выполняет его тело, которое теперь равно
{\tt (супруг Микки ?who)}.
\end{plainlist}
Теперь система оказалась в бесконечном цикле.  В сущности, найдет ли
система простой ответ {\tt (супруг Минни Микки)} прежде, чем
окажется в цикле, зависит от деталей реализации, связанных с порядком,
в котором система проверяет записи базы данных.  Это простой пример
циклов, которые могут возникнуть.  Наборы взаимосвязанных правил могут
привести к циклам, которые значительно труднее предвидеть, а
возникновение  цикла может зависеть от порядка подвыражений в
{\tt and} (см.~упражнение~\ref{EX4.64}) или от
низкоуровневых деталей, связанных с порядком обработки запросов в
системе\footnote{Это проблема не собственно логики, а процедурной интерпретации
логики, которую дает наш интерпретатор.  В данном случае можно написать
интерпретатор, который не попадет в цикл. Например, можно
пронумеровать доказательства, выводимые из наших утверждений и правил,
по ширине, а не по глубине.  Однако в такой системе оказывается
труднее использовать порядок правил в программах.  Одна из попыток
встроить в такую программу тонкое управление вычислениями описана в
deKleer et al. 1977.\index{ru}{де Клеер, Йохан||Johan 
deKleer||n|п}\index{en}{Johan deKleer||де Клеер, Йохан||n|п}
Еще один метод, который не ведет
к столь же сложным проблемам с управлением, состоит в добавлении
специальных знаний, например, детекторов для каких-то типов циклов
(см.~упражнение~\ref{EX4.67}).  Однако общую схему
надежного предотвращения бесконечных путей в рассуждениях построить
невозможно.  Представьте себе дьявольское правило вида <<чтобы
доказать истинность $P(x)$, докажите истинность
$P(f(x))$>> для какой-нибудь хитро выбранной функции
$f$.}.

\paragraph{Проблемы с {\tt not}}


\index{ru}{интерпретатор языка запросов|проблемы с \texttt{not} и 
\texttt{lisp-value}||||}Еще одна особенность запросной системы связана с 
{\tt not}.\index{ru}{not (язык запросов)||||p|}
Рассмотрим следующие два запроса к базе данных из
раздела~\ref{DEDUCTIVE-INFORMATION-RETRIEVAL}:

\begin{Verbatim}[fontsize=\small]
(and (начальник ?x ?y)
     (not (должность ?x (компьютеры программист))))

(and (not (должность ?x (компьютеры программист)))
     (начальник ?x ?y))
\end{Verbatim}
Эти два запроса приводят к различным результатам.  Первый запрос
сначала находит все записи в базе данных, соответствующие образцу
{\tt (начальник ?x ?y)}, затем фильтрует полученные
кадры, удаляя те, в которых значение {\tt ?x} удовлетворяет
образцу {\tt (должность ?x (компьютеры программист))}.  Второй
запрос сначала фильтрует входные кадры, пытаясь удалить те, которые
удовлетворяют образцу {\tt (должность ?x (компьютеры
программист))}.  Поскольку единственный входной кадр пуст, он
проверяет базу данных и смотрит, есть ли там записи, соответствующие
{\tt (должность ?x (компьютеры программист))}.  Поскольку, как
правило, такие записи имеются, выражение {\tt not} удаляет
пустой кадр, и остается пустой поток кадров.  Следовательно, весь
составной запрос также возвращает пустой поток.

Сложность состоит в том, что наша реализация
{\tt not} предназначена только для того, чтобы служить фильтром
для значений переменных.  Если выражение {\tt not}
обрабатывается с кадром, в котором часть переменных остается
несвязанными (как {\tt ?x} в нашем примере), система выдаст
неверный результат.  Подобные сложности возникают и с использованием
{\tt lisp-value}\index{ru}{lisp-value (язык запросов)||||p|}~--- предикат 
Лиспа не сможет работать, если часть из его аргументов несвязана.  
См.~упражнение~\ref{EX4.77}.

Есть еще один, значительно более серьезный аспект, в
котором {\tt not} языка запросов отличается от отрицания в
математической логике.  В логике мы считаем, что выражение <<не
$P$>> означает, что $P$ ложно.  Однако в системе
запросов <<не $P$>> означает, что $P$ невозможно
доказать на основе информации из базы данных.  Например, имея базу
данных из раздела~\ref{DEDUCTIVE-INFORMATION-RETRIEVAL},
система радостно выведет разнообразные отрицательные утверждения,
например, что Бен Битобор не любитель бейсбола, что на улице нет
дождя, и что $2+2$ не равно 4\footnote{Рассмотрим запрос {\tt (not 
(любитель-бейсбола (Битобор Бен)))}.  Система обнаруживает, что записи 
{\tt (любитель-бейсбола (Битобор Бен))} в базе нет, так что пустой кадр 
образцу не 
соответствует и не удаляется из исходного потока кадров.  Таким
образом, результатом запроса является пустой кадр, он используется
для конкретизации запроса, и выходит {\tt (not (любитель-бейсбола
(Битобор Бен)))}.}.
Иными словами, операция {\tt not} в языках логического
программирования отражает так называемую 
\index{ru}{гипотеза о замкнутости мира||closed world 
assumption|||}\index{en}{closed world assumption||гипотеза о замкнутости 
мира|||}{\em гипотезу о замкнутости
мира} (closed world assumption) и считает, что вся релевантная информация 
включена в базу
данных\footnote{Обсуждение и защита такой интерпретации
{\tt not} содержится в статье Кларка (Clark 1978).\index{ru}{Кларк, 
Кит~Л.||Keith~L. Clark||n|п}\index{en}{Keith~L. Clark||Кларк, Кит~Л.||n|п}}.

\begin{exercise}{4.64}%
\label{EX4.64}%
Хьюго Дум по ошибке уничтожил в базе данных правило
{\tt подчиняется} (раздел~\ref{DEDUCTIVE-INFORMATION-RETRIEVAL}).
Обнаружив это, он быстро набивает правило заново, только, к сожалению,
по ходу дела вносит небольшое изменение:\index{ru}{подчиняется (правило)||||p|(упр.~4.64)}

\begin{Verbatim}[fontsize=\small]
(rule (подчиняется ?staff-person ?boss)
      (or (начальник ?staff-person ?boss)
          (and (подчиняется ?middle-manager ?boss)
               (начальник ?staff-person ?middle-manager))))
\end{Verbatim}
Сразу после того, как Хьюго ввел информацию в систему, Кон Фиден хочет
посмотреть, кому подчиняется Бен Битобор.  Он вводит запрос

\begin{Verbatim}[fontsize=\small]
(подчиняется (Битобор Бен) ?who)
\end{Verbatim}
После ответа система проваливается в бесконечный цикл.  Объясните,
почему.
\end{exercise}

\begin{exercise}{4.65}%
\label{EX4.65}%
П.Э.~Фект, ожидая собственного продвижения по
иерархии, дает запрос, который находит всех шишек (используя правило
\index{ru}{шишка (правило)||||p|(упр.~4.65)}{\tt шишка} из 
раздела~\ref{DEDUCTIVE-INFORMATION-RETRIEVAL}):

\begin{Verbatim}[fontsize=\small]
(шишка ?who)
\end{Verbatim}
К его удивлению, система отвечает

\begin{Verbatim}[fontsize=\small]
\textit{;;; Результаты запроса:}
(шишка (Уорбак Оливер))
(шишка (Битобор Бен))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
\end{Verbatim}
Почему система упоминает Оливера Уорбака четыре раза?
\end{exercise}

\begin{exercise}{4.66}%
\label{EX4.66}%
\index{ru}{язык запросов|расширения||||(упр.~4.66)}Бен работал над 
обобщением системы запросов так, чтобы
можно было собирать статистику о компании. Например, чтобы найти сумму
зарплат всех программистов, можно было бы сказать

\begin{Verbatim}[fontsize=\small]
(sum ?amount
     (and (должность ?x (компьютеры программист))
          (зарплата ?x ?amount)))
\end{Verbatim}
В общем случае новая система Бена допускает запросы вида

\begin{Verbatim}[fontsize=\small]
(accumulation-function \textit{$\langle$переменная$\rangle$}
                       \textit{$\langle$запрос-образец$\rangle$})
\end{Verbatim}
где в виде {\tt accumulation-function} могут выступать
{\tt sum} (сумма), {\tt average} (среднее) или
{\tt maximum} (максимум).  Бен думает, что реализовать это
расширение будет проще простого. Он просто скормит образец-запрос
функции {\tt qeval} и получит поток кадров.  Затем он пропустит
поток через функцию-отображение, которая из каждого кадра извлечет
значение указанной переменной, и получившийся поток значений отдаст
функции-накопителю.  Когда Бен заканчивает свою реализацию и
собирается ее опробовать, мимо проходит Пабло, все еще смущенный
результатом запроса из упражнения~\ref{EX4.65}.  Когда Пабло
показывает Бену полученный им от системы ответ, Бен хватается за
голову: <<Моя простая схема накопления не будет работать!>>

Что понял Бен?  Опишите, как он мог бы исправить
ситуацию.
\end{exercise}

\begin{exercise}{4.67}%
\label{EX4.67}%
\index{ru}{интерпретатор языка запросов|улучшения||||(упр.~4.67)}%
Придумайте, как в запросную систему можно вставить 
детектор циклов, который избегает простых  \index{ru}{интерпретатор языка 
запросов|бесконечные циклы||||(упр.~4.67)}зацикливаний, вроде
показанных в тексте и в упражнении~\ref{EX4.64}.  Общая
идея состоит в том, что система должна хранить в каком-то виде историю
текущей цепи рассуждений и не начинать обработку запроса, если она уже
над ним работает.  Опишите, информация какого вида (образцы и кадры)
включается в историю и как можно проводить проверку. (После того, как
Вы изучите в деталях реализацию запросной системы из 
раздела~\ref{IMPLEMENTING-THE-QUERY-SYSTEM}, Вы можете захотеть
изменить систему и включить в нее свой детектор циклов.)
\end{exercise}

\begin{exercise}{4.68}%
\label{EX4.68}%
Определите правила, с помощью которых реализуется
операция  \index{ru}{reverse|правила|||p|(упр.~4.68)}{\tt reverse} из 
упражнения~\ref{EX2.18}, возвращающая список, элементы которого те же, что 
и в исходном, но идут в обратном порядке.  (Подсказка: используйте
{\tt append-to-form}.)  Могут ли Ваши правила ответить и на
запрос {\tt (reverse (1 2 3) ?x)}, и на {\tt (reverse ?x (1 2
3))}?
\end{exercise}

\begin{exercise}{4.69}%
\label{EX4.69}%
Начав с базы данных и правил, сформулированных Вами в
упражнении~\ref{EX4.63}, постройте правила для добавления
приставок <<пра>> в отношение {\tt внук}.  Система должна уметь
понять, что Ирад~--- правнук Адама, а Иавал и Иувал приходятся Адаму
прапрапрапраправнуками. (Подсказка: представляйте, например,
утверждение об Ираде как {\tt ((пра внук) Адам Ирад)}.
Напишите правила, которые определяют, заканчивается ли список словом
{\tt внук}.  С помощью этого определите правило, которое
позволяет вывести отношение {\tt ((пра . ?rel) ?x ?y)}, где
список {\tt ?rel} оканчивается на {\tt внук}.)
Проверьте свои правила на запросах {\tt ((пра внук) ?g ?ggs)} и
{\tt (?relationship Адам Ирад)}.
\end{exercise}

\subsection{Реализация запросной системы}
\label{IMPLEMENTING-THE-QUERY-SYSTEM}%


В разделе~\ref{HOW-THE-QUERY-SYSTEM-WORKS}
описывалось, как работает запросная система.  Теперь мы представляем
полную реализацию системы во всех деталях.

\subsubsection{Управляющий цикл и конкретизация}
\label{THE-DRIVER-LOOP-AND-INSTANTIATION}%

\index{ru}{управляющий цикл|в  интерпретаторе 
запросов||||}\index{ru}{интерпретатор языка запросов|управляющий цикл||||} 
Управляющий цикл запросной системы читает входные
выражения.  Если выражение является правилом или утверждением, которое
требуется добавить в базу данных, то происходит добавление.  В
противном случае предполагается, что выражение является запросом.
Управляющий цикл передает запрос вычислителю {\tt qeval} вместе
с начальным потоком, состоящим из одного пустого кадра.
Результатом вычисления является поток кадров, порожденных заполнением
переменных запроса значениями, найденными в базе данных.  С помощью
этих кадров порождается новый поток, состоящий из копий исходного
запроса, в которых переменные конкретизированы значениями из потока
кадров.  Этот последний поток печатается на терминале:

\begin{Verbatim}[fontsize=\small]
(define input-prompt ";;; Ввод запроса:") \index{ru}{подсказка|интерпретатор запросов||||}
(define output-prompt ";;; Результаты запроса:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)  \index{ru}{query-driver-loop||||pd|}
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Утверждение добавлено в базу данных.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                            frame
                            (lambda (v f)
                              (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
\end{Verbatim}
Здесь, как и в других интерпретаторах из этой главы, мы пользуемся
абстрактным синтаксисом языка запросов. \index{ru}{абстрактный синтаксис|в 
языке запросов||||}Реализация синтаксиса
выражений, включая предикат {\tt assertion-to-be-added?} и
селектор {\tt add-assertion-body}, дается в 
разделе~\ref{QUERY-SYNTAX-PROCEDURES}. Процедура
{\tt add-rule-or-assertion!} определяется в 
разделе~\ref{MAINTAINING-THE-DATA-BASE}.
\sloppy

Прежде чем обрабатывать входное выражение, управляющий
цикл преобразует его  синтаксис в форму, которая делает обработку
эффективнее.  При этом меняется \index{ru}{переменная 
образца|представление||||} \index{ru}{интерпретатор языка 
запросов|представление  переменной образца||||}представление переменных 
образца.
Когда запрос конкретизируется, то все переменные, которые остались
несвязанными, преобразуются, прежде чем печататься, обратно во входное
представление.  Эти преобразования производятся процедурами
{\tt query-syntax-process} и
{\tt contract-question-mark} 
(раздел~\ref{QUERY-SYNTAX-PROCEDURES}).

Чтобы  \index{ru}{интерпретатор языка 
запросов|конкретизация||||}конкретизировать выражение, мы его копируем,
заменяя при этом все переменные выражения их значениями из данного
кадра.  Значения сами по себе конкретизируются, поскольку и они могут
содержать переменные (например, если {\tt ?x} внутри
{\tt exp} связано в результате унификации со значением
{\tt ?y}, а уже {\tt ?y} связано со значением
5). Действие, которое требуется предпринять, если переменную не
удается конкретизировать, задается процедурным аргументом
{\tt instantiate}.

\begin{Verbatim}[fontsize=\small]
(define (instantiate exp frame unbound-var-handler)\index{ru}{instantiate||||pd|}
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
\end{Verbatim}
Процедуры, управляющие связываниями, определяются в 
разделе~\ref{FRAMES-AND-BINDINGS}.

\subsubsection{Вычислитель}
\label{THE-EVALUATOR}%


Процедура {\tt qeval}, вызываемая из
{\tt query-driver-loop}, является основным \index{ru}{интерпретатор языка 
запросов|вычислитель запросов||||}вычислителем
запросной системы. Она принимает на входе запрос и поток кадров и
возвращает поток расширенных кадров.  \index{ru}{программирование, 
управляемое данными|в интерпретаторе  запросов||||}Особые формы она распознает
через диспетчеризацию, управляемую данными, при помощи {\tt get}
и {\tt put}, в точности так же, как мы реализовывали обобщенные
операции в главе~\ref{BUILDING-ABSTRACTIONS-WITH-DATA}.
Все запросы, которые не распознаются как особая форма, считаются
простыми запросами и обрабатываются процедурой
{\tt simple-query}.

\begin{Verbatim}[fontsize=\small]
(define (qeval query frame-stream)  \index{ru}{qeval||||pd|}
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
\end{Verbatim}
Селекторы {\tt type} и {\tt contents}, определяемые в
разделе~\ref{QUERY-SYNTAX-PROCEDURES}, реализуют
абстрактный синтаксис особых форм.

\paragraph{Простые запросы}

\index{ru}{простой запрос|обработка||||}Процедура {\tt simple-query} 
обрабатывает простые запросы.  В качестве аргументов она принимает простой 
запрос (образец) и поток кадров, а возвращает поток, порожденный путем
расширения каждого кадра всеми результатами успешного сопоставления
записей базы данных с запросом.

\begin{Verbatim}[fontsize=\small]
(define (simple-query query-pattern frame-stream) \index{ru}{simple-query||||pd|}
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
\end{Verbatim}

Для каждого кадра из входного потока мы с помощью
{\tt find-assertions} 
(раздел~\ref{FINDING-ASSERTIONS-BY-PATTERN-MATCHING}) сопоставляем
образец со всеми утверждениями из базы данных, получая при этом поток
расширенных кадров.  Кроме того, с помощью {\tt apply-rules}
(раздел~\ref{RULES-AND-UNIFICATION}) мы применяем все
подходящие правила и получаем при этом еще один поток расширенных
кадров.  Два этих потока сливаются (при помощи
{\tt stream-append-delayed} из 
раздела~\ref{STREAM-OPERATIONS})
и дают на выходе поток, перечисляющий все способы, которыми исходный запрос
можно удовлетворить в соответствии с исходным кадром 
(см.~упражнение~\ref{EX4.71}).  Потоки от отдельных входных кадров
соединяются через {\tt stream-flatmap} 
(раздел~\ref{STREAM-OPERATIONS}) в один большой поток, содержащий
все способы, которыми можно расширить кадры из входного потока и
получить сопоставление с исходным запросом.

\paragraph{Составные запросы}

\index{ru}{составной запрос|обработка||||}Запросы с операцией {\tt and} 
обрабатываются так, как показано на рис.~\ref{P4.5}, процедурой
{\tt conjoin}. {\tt Conjoin} принимает в качестве
аргументов конъюнкты и поток кадров, а возвращает поток расширенных
кадров.  Сначала она обрабатывает поток кадров и получает поток всех
их возможных расширений, удовлетворяющих первому запросу
конъюнкции. Затем, используя этот новый поток кадров, она рекурсивно
применяет {\tt conjoin} к остальным конъюнктам.

\begin{Verbatim}[fontsize=\small]
(define (conjoin conjuncts frame-stream)\index{ru}{conjoin||||pd|}
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
\end{Verbatim}
Выражение

\begin{Verbatim}[fontsize=\small]
(put 'and 'qeval conjoin)
\end{Verbatim}
\index{ru}{and (язык запросов)|обработка|||p|}настраивает процедуру {\tt 
qeval} так, чтобы она при обнаружении формы 
{\tt and} вызывала {\tt conjoin}.

Запросы {\tt or} обрабатываются подобным же
образом, как показано на рис. \ref{P4.6}.  Выходные потоки
отдельных дизъюнктов {\tt or} вычисляются раздельно и
смешиваются при помощи процедуры {\tt interleave-delayed} из
раздела~\ref{STREAM-OPERATIONS}. 
(См.~упражнения~\ref{EX4.71} и \ref{EX4.72}.)

\begin{Verbatim}[fontsize=\small]
(define (disjoin disjuncts frame-stream)\index{ru}{disjoin||||pd|}
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))

(put 'or 'qeval disjoin)
\end{Verbatim}
\index{ru}{or (язык запросов)|обработка|||p|}Предикаты и селекторы для 
синтаксиса конъюнктов и дизъюнктов даны в 
разделе~\ref{QUERY-SYNTAX-PROCEDURES}.

\paragraph{Фильтры}


Запросы {\tt not} обрабатываются так, как
описано в разделе~\ref{HOW-THE-QUERY-SYSTEM-WORKS}. Мы
пытаемся расширить каждый кадр входного потока так, чтобы
удовлетворялся отрицаемый запрос, и включаем данный кадр в
поток-результат только в том случае, если расширить его 
нельзя.\index{ru}{not (язык запросов)|вычисление|||p|}

\begin{Verbatim}[fontsize=\small]
(define (negate operands frame-stream)\index{ru}{negate||||pd|}
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'not 'qeval negate)
\end{Verbatim}

{\tt Lisp-value}\index{ru}{lisp-value (язык запросов)|вычисление|||p|}~--- 
фильтр, подобный 
{\tt not}. Образец расширяется с помощью каждого кадра из
входного потока, применяется указанный предикат, и кадры, для которых
он возвращает ложное значение, исключаются из входного потока.  Если
остаются несвязанные переменные запроса, возникает ошибка.

\begin{Verbatim}[fontsize=\small]
(define (lisp-value call frame-stream)\index{ru}{lisp-value (интерпретатор запросов)||||pd|}
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Неизвестная переменная -- LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'lisp-value 'qeval lisp-value)
\end{Verbatim}

Процедура {\tt execute}, которая применяет
предикат к аргументам, должна вызвать {\tt eval} от
предикатного выражения, чтобы получить применяемую процедуру.  Однако
она не должна вычислять аргументы, поскольку это сами аргументы и
есть, а не выражения, вычисление которых (на Лиспе) даст нам
аргументы.  Обратите внимание, что {\tt execute} реализована с
помощью {\tt eval}\index{ru}{eval (элементарная процедура)|в 
интерпретаторе запросов|||pd|} и {\tt apply} из нижележащей
Лисп-системы.

\begin{Verbatim}[fontsize=\small]
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
\end{Verbatim}

Особая форма {\tt always-true} порождает запрос,
который всегда удовлетворяется.  Она игнорирует свое подвыражение
(обычно пустое) и попросту пропускает через себя все кадры входного
потока. {\tt Always-true} используется в селекторе
{\tt rule-body} (раздел~\ref{QUERY-SYNTAX-PROCEDURES})
чтобы дать тела правилам, для которых  \index{ru}{правило (в языке 
запросов)|применение||||}тела не определены (то есть
правилам, заключения которых всегда удовлетворяются).

\begin{Verbatim}[fontsize=\small]
(define (always-true ignore frame-stream) frame-stream)\index{ru}{always-true||||pd|}

(put 'always-true 'qeval always-true)
\end{Verbatim}
Селекторы, которые определяют синтаксис {\tt not} и
{\tt lisp-value}, определены в 
разделе~\ref{QUERY-SYNTAX-PROCEDURES}.

\subsubsection{Поиск утверждений с помощью сопоставления с
образцом}
\label{FINDING-ASSERTIONS-BY-PATTERN-MATCHING}%

\index{ru}{сопоставление с образцом|реализация||||} 
\index{ru}{интерпретатор языка запросов|сопоставление с 
образцом||||}
Процедура {\tt find-assertions}, вызываемая из
{\tt simple-query} (раз\-дел~\ref{THE-EVALUATOR}),
принимает на входе образец и кадр.  Она возвращает поток кадров,
каждый из которых расширяет исходный кадр сопоставлением данного
образца с записью базы данных.  Она пользуется
{\tt fetch-assertions} (раздел~\ref{MAINTAINING-THE-DATA-BASE}),
чтобы найти поток всех утверждений базы, которые следует проверять на
сопоставление с данными образцом и кадром.  Мы используем
{\tt fetch-assertions} потому, что часто можно с помощью
простых тестов исключить множество записей в базе данных из числа
кандидатов на успешное сопоставление.  Система продолжала бы работать,
если бы мы исключили {\tt fetch-assertions} и попросту
проверяли поток всех утверждений базы, но при этом вычисление было бы
менее эффективным, поскольку пришлось бы делать намного больше вызовов
сопоставителя.
{\sloppy

}
\begin{Verbatim}[fontsize=\small]
(define (find-assertions pattern frame)\index{ru}{find-assertions||||pd|}
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
\end{Verbatim}

Процедура {\tt check-an-assertion} принимает в
качестве аргументов образец, объект данных (утверждение) и кадр, и
возвращает либо одноэлементный поток с расширенным кадром, либо, если
сопоставление неудачно, {\tt the-empty-stream}.

\begin{Verbatim}[fontsize=\small]
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
\end{Verbatim}
Сопоставитель как таковой возвращает либо символ {\tt failed},
либо расширение данного кадра.  Основная идея сопоставителя состоит в
том, чтобы сравнивать образец с данными, элемент за элементом, и
собирать при этом связывания переменных образца.  Если образец и
объект данных совпадают, то сопоставление оказывается
успешным, и мы возвращаем поток собранных связываний.  В противном
случае, если образец является переменной, мы расширяем имеющийся кадр,
связывая переменную с данными, если это не противоречит уже имеющимся
в кадре связываниям.  Если и образец, и данные являются парами, мы
(рекурсивно) сопоставляем {\tt car} образца с {\tt car}
данных и получаем кадр; затем с этим кадром мы сопоставляем
{\tt cdr} образца с {\tt cdr} данных.  Если ни один из
этих случаев не применим, сопоставление терпит неудачу, и мы
возвращаем символ {\tt failed}.

\begin{Verbatim}[fontsize=\small]
(define (pattern-match pat dat frame)\index{ru}{pattern-match||||pd|}
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
\end{Verbatim}

Вот процедура, которая расширяет кадр, добавляя к нему
новое связывание, если это не противоречит уже имеющимся в кадре
связываниям:

\begin{Verbatim}[fontsize=\small]
(define (extend-if-consistent var dat frame)\index{ru}{extend-if-consistent||||pd|}
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
\end{Verbatim}
Если для переменной в кадре нет связывания, мы просто добавляем к нему
новое связывание этой переменной с элементом данных.  В противном случае мы
вызываем сопоставитель в данном кадре от элемента данных и имеющегося значения
переменной в кадре. Если хранимое значение содержит только константы,
(а это всегда так будет, если оно само было создано процедурой
{\tt extend-if-consistent} во время сопоставления с образцом),
то это сопоставление просто проверит, совпадает ли хранимое значение с
новым.  Если да, то кадр вернется неизменным; если нет, вернется
символ неудачи.  Однако если хранимое в кадре значение было создано
при унификации (см.~раздел~\ref{RULES-AND-UNIFICATION}), то
оно может содержать переменные образца.  Рекурсивное сопоставление
хранимого образца с новым элементом данных добавит или проверит
связывания переменных в этом образце.  Предположим, к примеру, что у
нас есть кадр, в котором переменная {\tt ?x} связана с
выражением {\tt (f ?y)}, а {\tt ?y} несвязана, и что
теперь мы хотим расширить этот кадр, связав {\tt ?x} со
значением {\tt (f b)}.  Мы ищем в кадре {\tt ?x} и
видим, что она связана с {\tt (f ?y)}.  Теперь нам нужно
сопоставить {\tt (f ?y)} с предлагаемым новым значением
{\tt (f b)} в том же самом кадре.  В конце концов это
сопоставление расширяет кадр, добавив связывание {\tt ?y} с
{\tt b}.  {\tt ?X} по-прежнему связано с {\tt (f
?y)}.  Мы никогда не изменяем хранимое связывание и никогда не
храним более одного связывания для одной и той же переменной.

Процедуры, при помощи которых
{\tt extend-if-consistent} работает со связываниями, определены
в разделе~\ref{FRAMES-AND-BINDINGS}.

\paragraph{Образцы с точечными хвостами}


\index{ru}{точечная запись|в образцах запросов||||}Если в образце 
содержится точка, за которой следует
переменная образца, то переменная сопоставляется с остатком списка (а
не со следующим его элементом), как и следовало ожидать от точечной
записи, описанной в упражнении~\ref{EX2.20}.  Несмотря на
то, что реализованный нами сопоставитель на занимается специально
поиском точек, работает он в этом случае так, как ему следует. Это
происходит потому, что лисповский примитив {\tt read}, с
помощью которого {\tt query-driver-loop} считывает запрос и
представляет его в виде списковой структуры, обрабатывает точки особым
образом.

\index{ru}{точечная запись|и {\tt read}||||}\index{ru}{read (элементарная 
процедура)|обработка точечной записи|||p|}Когда {\tt read}
встречает точку, вместо 
того, чтобы сделать следующее выражение очередным элементом списка
({\tt car} в ячейке {\tt cons}, {\tt cdr} которой
будет остатком списка), он делает его {\tt cdr}ом списковой
структуры. Например, списковая структура, которую {\tt read}
порождает при чтении образца {\tt (компьютеры ?type)} могла бы
быть построена с помощью выражения {\tt (cons 'компьютеры (cons '?type
'()))}, а та, которая получается при чтении {\tt (компьютеры
. ?type)}, могла бы получиться при вычислении {\tt (cons
'компьютеры '?type)}.

Таким образом, когда {\tt pattern-match}
рекурсивно сравнивает {\tt car}ы и {\tt cdr}ы списка
данных и образца, содержащего точку, он в конце концов сопоставляет
переменную после точки (она служит {\tt cdr} образца) с
подсписком списка данных, и связывает переменную с этим списком.
Например, сопоставление образца {\tt (компьютеры . ?type)} со
списком {\tt (компьютеры программист стажер)} сопоставит
переменную {\tt ?type} с подсписком {\tt (программист стажер)}.

\subsubsection{Правила и унификация}
\label{RULES-AND-UNIFICATION}%

\index{ru}{правило (в языке запросов)|применение||||}Процедура {\tt 
apply-rules}~--- это аналог {\tt find-assertion} 
(раздел~\ref{FINDING-ASSERTIONS-BY-PATTERN-MATCHING}).  Она
принимает на входе образец и кадр, а порождает поток расширенных
кадров, применяя правила из базы данных. {\tt Stream-flatmap}
отображает через {\tt apply-rule} поток возможно применимых правил
(отобранных процедурой {\tt fetch-rules} из 
раздела~\ref{MAINTAINING-THE-DATA-BASE}) и склеивает получившиеся
потоки кадров.

\begin{Verbatim}[fontsize=\small]
(define (apply-rules pattern frame)\index{ru}{apply-rules||||pd|}
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
\end{Verbatim}

Процедура {\tt apply-a-rule} применяет правила
способом, описанным в разделе~\ref{HOW-THE-QUERY-SYSTEM-WORKS}.
Сначала она дополняет кадр-аргумент, унифицируя в его рамках
заключение правила с образцом. Если это удается, она выполняет в
получившемся кадре тело правила.

Однако прежде всего программа переименовывает все
переменные в правиле и дает им уникальные новые имена.  Это делается потому,
что мы не хотим, чтобы переменные из различных
применений правил смешивались друг с другом.  К примеру, если в двух
правилах используется переменная {\tt ?x}, то каждое из них
может добавить связывание этой переменной к кадру, в котором оно
применяется.  Однако эти два {\tt ?x} не имеют друг к другу
никакого отношения, и мы не должны обманываться и считать, что два
связывания этих переменных обязаны соответствовать друг другу.  Вместо
переименования переменных мы могли бы придумать более хитрую
структуру окружений; однако выбранный здесь подход с
переименованиями~--- самый простой, хотя и не самый эффективный.
(См.~упражнение~\ref{EX4.79}.)  Вот процедура
{\tt apply-a-rule}:

\begin{Verbatim}[fontsize=\small]
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
\end{Verbatim}
Селекторы {\tt rule-body} и {\tt conclusion},
извлекающие части правил, описаны в 
разделе~\ref{QUERY-SYNTAX-PROCEDURES}.

Чтобы породить уникальные имена переменных, мы связываем с
каждым применением правила уникальный идентификатор (например, число)
и цепляем его к исходным именам переменных.  Например, если
идентификатор применения правила равен 7, мы можем заменить все
{\tt ?x} в правиле на {\tt ?x-7}, а все {\tt ?y}
на {\tt ?y-7}. (Процедуры {\tt make-new-variable} и
{\tt new-rule-application-id} содержатся среди синтаксических
процедур в разделе~\ref{QUERY-SYNTAX-PROCEDURES}.)

\begin{Verbatim}[fontsize=\small]
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
\end{Verbatim}

\index{ru}{интерпретатор языка 
запросов|унификация||||}\index{ru}{унификация|реализация||||}Алгоритм 
унификации реализуется в виде процедуры, которая
принимает на входе два образца и кадр, а возвращает либо расширенный
кадр, либо символ {\tt failed}.  Унификатор в основном подобен
сопоставителю, но только он симметричен~--- переменные разрешаются с
обеих сторон сопоставления. Процедура {\tt unify-match} подобна
{\tt pattern-match}, за исключением нового отрезка кода
(отмеченного знаком <<{\em ***}>>), где
обрабатывается случай, когда объект на правой стороне сопоставления
является переменной.

\begin{Verbatim}[fontsize=\small]
(define (unify-match p1 p2 frame) \index{ru}{unify-match||||pd|}
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame)) {\em ; ***}
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
\end{Verbatim}

При унификации, как и при одностороннем сопоставлении с
образцом, нам нужно принимать предлагаемое расширение кадра только в
том случае, когда оно не противоречит имеющимся связываниям.
Процедура {\tt extend-if-pos\-sible}, используемая при
унификации, подобна {\tt extend-if-consistent} из
сопоставителя, за исключением двух проверок, отмеченных в программе
значком <<{\em ***}>>.  В первом случае, если переменная,
которую мы пытаемся сопоставить, не найдена, но значение, с которым мы
ее сопоставляем, само является (другой) переменной, требуется
проверить, нет ли у этой второй переменной значения, и если да,
сопоставить его.  Если же обе стороны сопоставления несвязаны, мы любую
из них можем связать с другой.

Вторая проверка связана с попытками связать переменную с
образцом, который ее саму содержит.  Такая ситуация может возникнуть,
когда в обоих образцах повторяются переменные.  Рассмотрим, например,
унификацию образцов {\tt (?x ?x)} и {\tt (?y
\textit{$\langle$выражение, содержащее {\tt ?y}$\rangle$})} в
кадре, где не связаны ни {\tt ?x}, ни {\tt ?y}.  Сначала
{\tt ?x} сопоставляется с {\tt ?y}, и возникает
связывание переменной {\tt ?x} с {\tt ?y}.  Затем
та же переменная {\tt ?x} сопоставляется с данным выражением,
которое включает {\tt ?y}.  Поскольку {\tt ?x} уже
связана со значением {\tt ?y}, это приводит к тому, что с
выражением сопоставляется {\tt ?y}.  Если мы считаем, что
унификатор занят поиском набора значений для переменных, которые делают
образцы одинаковыми, то значит, эти образцы содержат инструкции найти
такое значение {\tt ?y}, чтобы {\tt ?y} был равен
выражению, содержащему {\tt ?y}.  Общего метода для решения
таких задач не существует, так что мы такие связывания отвергаем; эти
случаи распознаются предикатом {\tt 
depends-on?}\footnote{\index{ru}{неподвижная точка|и унификация||||п}В 
общем случае унификация {\tt ?y} с 
выражением, содержащим {\tt ?y}, требует нахождения неподвижной
точки уравнения {\tt ?y $=$ \textit{$\langle$выражение, содержащее
{\tt ?y}$\rangle$}}.  Иногда возможно синтаксическим
образом создать выражение, которое кажется решением уравнения.
Например, кажется, что {\tt ?y $=$ (f y)} имеет неподвижную
точку {\tt (f (f (f ...)))}, которую мы можем получить,
начав с выражения {\tt (f ?y)} и систематически подставляя
{\tt (f ?y)} вместо {\tt ?y}.  К сожалению, не у всякого
такого уравнения имеется осмысленная неподвижная точка.  Вопросы,
возникающие здесь, подобны вопросам работы с 
\index{ru}{бесконечная последовательность||infinite     
series|||п}\index{en}{infinite     series||бесконечная 
последовательность|||п}бесконечными
последовательностями в математике.  Например, мы знаем, что решение
уравнения $y = 1 + y/2$ равно 2.  Если мы начнем с
выражения $1 + y/2$ и будем подставлять $1 + y/2$ вместо
$y$, то получим
$$
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = \cdots,
$$
что ведет к
$$
2 = 1 + 1/2 + 1/4 + 1/8 + \cdots.
$$
Однако если мы попытаемся проделать те же преобразования, использовав
тот факт, что решение уравнения $y = 1 + 2y$ равно -1, то получим
$$
-1 = y = 1 + 2y = 1 = 2(1+2y) = 1 + 2 + 4y = \cdots,
$$
что ведет к
$$
-1 = 1 + 2 + 4 + 8 + \cdots.
$$
Несмотря на то, что формальные преобразования, ведущие к этим двум
уравнениям, одинаковы, первый результат является верным утверждением о
бесконечных последовательностях, а второй нет.  Подобным образом и при
работе с унификациями работа с произвольными синтаксически
правильными выражениями может привести к ошибкам.}.
С другой стороны, нам не хочется отвергать попытки связать переменную
саму с собой. Рассмотрим, например, унификацию 
{\tt (?x ?x)} с {\tt (?y ?y)}.  Вторая попытка связать
{\tt ?x} с {\tt ?y} вызывает сопоставление
{\tt ?y} (старое значение {\tt ?x}) с {\tt ?y}
(новым значением {\tt ?x}).  Этот случай обрабатывается веткой
{\tt equal?} внутри {\tt unify-match}.

\begin{Verbatim}[fontsize=\small]
(define (extend-if-possible var val frame)\index{ru}{extend-if-possible||||pd|}
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                     {\em ; ***}
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)    {\em ; ***}
           'failed)
          (else (extend var val frame)))))
\end{Verbatim}

Процедура {\tt depends-on?}~--- это предикат. Он
проверяет, зависит ли выражение, которое предлагается сделать
значением переменной образца, от этой переменной.  Это нужно делать по
отношению к текущему кадру, поскольку выражение может содержать
вхождения переменной, уже обладающей значением, которое, в свою
очередь, зависит от нашей переменной.  По структуре
{\tt depends-on?} представляет собой простой рекурсивный обход
дерева, во время которого мы по необходимости подставляем значения
переменных.

\begin{Verbatim}[fontsize=\small]
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
\end{Verbatim}

\subsubsection{Ведение базы данных}
\label{MAINTAINING-THE-DATA-BASE}%


\index{ru}{база данных|индексирование||||}\index{ru}{индексирование базы 
данных|||||}\index{ru}{интерпретатор языка запросов|база данных||||}Одна 
из важных задач при разработке логических языков
программирования~--- так организовать работу, чтобы при проверке
каждого образца просматривалось как можно меньше ненужных записей из
базы.  В нашей системе, помимо того, что мы храним все утверждения в
одном большом потоке, мы в отдельных потоках храним утверждения,
{\tt car}ы которых являются константными символами, в
таблице, индексируемой по этим символам.  Чтобы получить утверждения,
которые могут сопоставляться с образцом, мы сначала смотрим, не
является ли {\tt car} образца константным символом.  Если это
так, то мы возвращаем (сопоставителю для проверки) все хранимые
утверждения с тем же {\tt car}.  Если {\tt car} образца
не является константным символом, мы возвращаем все хранимые
утверждения.  Более изысканные методы могли бы использовать еще
информацию из кадра, либо пытаться оптимизировать и тот случай, когда
{\tt car} образца не является константным символом.  Мы
избегаем встраивания критериев для индексации (использование
{\tt car}, обработка только случая с константными символами) в
программу: вместо этого мы вызываем предикаты и селекторы, реализующие
эти критерии.

\begin{Verbatim}[fontsize=\small]
(define THE-ASSERTIONS the-empty-stream)

(define (fetch-assertions pattern frame)\index{ru}{fetch-assertions||||pd|}
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))

(define (get-all-assertions) THE-ASSERTIONS)

(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
\end{Verbatim}

Процедура {\tt get-stream} ищет поток в таблице и,
если ничего там не находит, возвращает пустой поток.

\begin{Verbatim}[fontsize=\small]
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
\end{Verbatim}

Правила хранятся подобным же образом, с использованием
{\tt car} заключения правила.  Однако в заключениях правил могут
стоять произвольные образцы, и таким образом, они отличаются от
утверждений тем, что могут содержать переменные. Образец, в
{\tt car} которого стоит константный символ, может
сопоставляться не только с правилами, у которых {\tt car} заключения
содержит тот же символ, но и с правилами, где в начале заключения стоит
переменная. Таким образом, при поиске правил, которые могут
сопоставляться с образцом, у которого в начале константный символ, мы
возвращаем как правила с этим символом в {\tt car} заключения,
так и правила с переменной в начале заключения.  Ради этого мы храним
правила с переменными в начале заключения в отдельном потоке, который
находится в таблице под индексом~{\tt ?}.

\begin{Verbatim}[fontsize=\small]
(define THE-RULES the-empty-stream)

(define (fetch-rules pattern frame)\index{ru}{fetch-rules||||pd|}
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))

(define (get-all-rules) THE-RULES)

(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
\end{Verbatim}

Процедура {\tt add-rule-or-assertion!} вызывается
из {\tt query-driver-loop}, когда требуется добавить к базе
данных правило или утверждение.  Каждая запись сохраняется в индексе,
если это требуется, а также в общем потоке правил либо утверждений
базы данных.

\begin{Verbatim}[fontsize=\small]
(define (add-rule-or-assertion! assertion)\index{ru}{add-rule-or-assertion!||||pd|}
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))

(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))

(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
\end{Verbatim}

Чтобы вставить в базу утверждение или правило, мы
проверяем, можно ли его проиндексировать. Если да, то мы сохраняем его
в соответствующем потоке.

\begin{Verbatim}[fontsize=\small]
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream assertion
                            current-assertion-stream))))))

(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
\end{Verbatim}

Следующие процедуры определяют, как используется индекс
базы данных. Образец (утверждение или заключение правила) сохраняется
в таблице, если он начинается с переменной или константного символа.

\begin{Verbatim}[fontsize=\small]
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
\end{Verbatim}
Ключ, под которым образец сохраняется в таблице~--- это либо
{\tt ?} (если он начинается с переменной), либо константный
символ из его начала.

\begin{Verbatim}[fontsize=\small]
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
\end{Verbatim}
Для поиска записей, которые могут соответствовать
образцу, используется индекс в том случае, когда образец начинается с
константного символа.

\begin{Verbatim}[fontsize=\small]
(define (use-index? pat)
  (constant-symbol? (car pat)))
\end{Verbatim}

\begin{exercise}{4.70}%
\label{EX4.70}%
Какова цель выражений {\tt let} в процедурах
{\tt add-assertion!} и {\tt add-rule!}?  Что 
неправильно в следующем варианте {\tt add-assertion!}?
Подсказка: вспомните определение бесконечного потока единиц из 
раздела~\ref{INFINITE-STREAMS}: {\tt (define ones (cons-stream 1
ones))}.

\begin{Verbatim}[fontsize=\small]
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
\end{Verbatim}
\end{exercise}

\subsubsection{Операции над потоками}
\label{STREAM-OPERATIONS}%

\index{ru}{интерпретатор языка запросов|операции над потоками||||}В 
запросной системе используется несколько операций над
потоками, помимо представленных в главе~\ref{MODULARITY-OBJECTS-AND-STATE}. 

{Процедуры {\tt stream-append-delayed} и
{\tt interleave-delayed} подобны {\tt stre\-am-append} и
{\tt interleave} 
(раздел~\ref{EXPLOITING-THE-STREAM-PARADIGM}), но только они
принимают задержанный аргумент (как процедура {\tt integral} из
раздела~\ref{STREAMS-AND-DELAYED-EVALUATION}).  В
некоторых случаях это откладывает зацикливание 
(см.~упражнение~\ref{EX4.71}).

\sloppy
} %HERE415
\begin{Verbatim}[fontsize=\small]
(define (stream-append-delayed s1 delayed-s2)\index{ru}{stream-append-delayed||||pd|}
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))

(define (interleave-delayed s1 delayed-s2)\index{ru}{interleave-delayed||||pd|}
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
\end{Verbatim}

Процедура {\tt stream-flatmap}, которая
многократно используется в интерпретаторе, чтобы применить процедуру
ко всем элементам потока кадров и соединить получающиеся потоки
кадров, является потоковым аналогом процедуры {\tt flatmap} для
обычных списков, введенной в 
разделе~\ref{SEQUENCES-AS-CONVENTIONAL-INTERFACES}.  Однако, в
отличие от обычного {\tt flatmap}, потоки мы собираем с помощью
чередующего процесса, а не просто сцепляем их 
(см.~упражнения~\ref{EX4.72} и \ref{EX4.73}).

\begin{Verbatim}[fontsize=\small]
(define (stream-flatmap proc s)\index{ru}{stream-flatmap||||pd|}
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)\index{ru}{flatten-stream||||pd|}
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
\end{Verbatim}

Кроме того, интерпретатор пользуется следующей простой
процедурой для порождения потока, который состоит из одного элемента:

\begin{Verbatim}[fontsize=\small]
(define (singleton-stream x) \index{ru}{singleton-stream||||pd|}
  (cons-stream x the-empty-stream))
\end{Verbatim}

\subsubsection{Процедуры, определяющие синтаксис запросов}
\label{QUERY-SYNTAX-PROCEDURES}%

\index{ru}{интерпретатор языка запросов|синтаксис языка 
запросов||||}Процедуры {\tt type} и {\tt contents},
используемые в {\tt qeval}
(раздел~\ref{THE-EVALUATOR}), указывают, что особая форма
определяется символом в ее {\tt car}.  Это те же процедуры, что
{\tt type-tag} и {\tt contents} из 
раздела~\ref{TAGGED-DATA}, с точностью до сообщения об ошибке.

\begin{Verbatim}[fontsize=\small]
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Неизвестное выражение TYPE" exp)))

(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Неизвестное выражение CONTENTS" exp)))
\end{Verbatim}

Следующие процедуры, вызываемые из
{\tt query-driver-loop} 
(раз\-дел~\ref{THE-DRIVER-LOOP-AND-INSTANTIATION}), указывают, что
утверждения и правила добавляются в базу данных при помощи выражений
вида {\tt (assert! \textit{$\langle$правило-или-утверждение$\rangle$})}:
{\sloppy

}

\begin{Verbatim}[fontsize=\small]
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))

(define (add-assertion-body exp)
  (car (contents exp)))
\end{Verbatim}

Вот синтаксические определения для особых форм
{\tt and}, {\tt or}, {\tt not} и
{\tt lisp\-value} (раздел~\ref{THE-EVALUATOR}):

\begin{Verbatim}[fontsize=\small]
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))

(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))

(define (negated-query exps) (car exps))

(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
\end{Verbatim}

Следующие три процедуры определяют синтаксис правил:

\begin{Verbatim}[fontsize=\small]
(define (rule? statement)
  (tagged-list? statement 'rule))

(define (conclusion rule) (cadr rule))

(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
\end{Verbatim}

\index{ru}{переменная образца|представление||||}{\tt Query-driver-loop} 
(раздел~\ref{THE-DRIVER-LOOP-AND-INSTANTIATION}) вызывает
{\tt query-syntax-process}, чтобы \index{ru}{интерпретатор языка 
запросов|преобразование переменной образца||||}преобразовать переменные
образца в выражении, имеющие форму {\tt ?sym\-bol}, к внутреннему
формату {\tt (? symbol)}.  Это означает, что образец вроде
{\tt (должность ?x ?y)} на самом деле представляется внутри
системы как {\tt (должность (? x) (? y))}.  Это повышает
эффективность обработки запросов, потому что позволяет системе
проверять, является ли выражение переменной, путем проверки {\tt car}
(не является ли {\tt car} символом {\tt ?}), вместо
того, чтобы извлекать
из символа буквы.  Преобразование синтаксиса осуществляется следующей
процедурой\footnote{Большинство Лисп-систем позволяет пользователю
изменять обыкновенную \index{ru}{quote (особая форма)|и 
\texttt{read}|||p|п}процедуру {\tt read} и
осуществлять такие  
преобразования путем определения \index{ru}{read (элементарная 
процедура)|макросимволы ввода|||p|п}\index{ru}{' (одинарная кавычка)|и 
\texttt{read}|||p|п}\index{ru}{макросимволы ввода||reader macro 
characters|||п}\index{en}{reader macro characters||макросимволы 
ввода|||п}{\em макросимволов
ввода} (reader macro characters).  Закавыченные выражения уже 
обрабатываются таким образом:
процедура чтения автоматически переводит {\tt 'expression} в
{\tt (quote expression)}, прежде чем выражение видит
интерпретатор.  Можно было бы устроить преобразование
{\tt ?expression} в {\tt (? expression)} таким же
образом; однако ради большей ясности мы здесь представили процедуру
преобразования явно.

{\tt Expand-question-mark} и
{\tt contract-question-mark} используют несколько 
\index{ru}{строка|элементарные процедуры||||п}процедур, имя 
которых содержит {\tt string}.  Это примитивы языка Scheme.}.

\begin{Verbatim}[fontsize=\small]
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))

(define (map-over-symbols proc exp)\index{ru}{map-over-symbols||||pd|}
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))

(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
\end{Verbatim}

После того, как переменные таким образом преобразованы,
переменные в образцах~--- это списки, начинающиеся с {\tt ?}, а
константные символы (которые требуется распознавать для индексирования
базы данных, раздел~\ref{MAINTAINING-THE-DATA-BASE})~---
это просто символы.

\begin{Verbatim}[fontsize=\small]
(define (var? exp)
  (tagged-list? exp '?))

(define (constant-symbol? exp) (symbol? exp))
\end{Verbatim}

Во время применения правил при помощи следующих процедур
порождаются уникальные переменные 
(раздел~\ref{RULES-AND-UNIFICATION}). Уникальным
идентификатором правила служит число, которое увеличивается при каждом
применении правила:

\begin{Verbatim}[fontsize=\small]
(define rule-counter 0)

(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)

(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
\end{Verbatim}

Когда {\tt query-driver-loop} конкретизирует
запрос для печати ответа, она преобразует все несвязанные переменные
запроса обратно к печатной форме при помощи

\begin{Verbatim}[fontsize=\small]
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?" 
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
\end{Verbatim}

\subsubsection{Кадры и связывания}
\label{FRAMES-AND-BINDINGS}%


Кадры\index{ru}{кадр (в интерпретаторе 
запросов)|представление||||}\index{ru}{интерпретатор языка 
запросов|кадры||||} представляются как списки связываний, которые, в 
свою очередь, являются парами вида <<переменная-значение>>:

\begin{Verbatim}[fontsize=\small]
(define (make-binding variable value)
  (cons variable value))

(define (binding-variable binding)
  (car binding))

(define (binding-value binding)
  (cdr binding))

(define (binding-in-frame variable frame)
  (assoc variable frame))

(define (extend variable value frame)
  (cons (make-binding variable value) frame))
\end{Verbatim}

\begin{exercise}{4.71}%
\label{EX4.71}%
Хьюго Дум не понимает, почему процедуры
{\tt simple-query} и {\tt disjoin} реализованы через
явные операции {\tt delay}, а не следующим образом:

\begin{Verbatim}[fontsize=\small]
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))

(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
\end{Verbatim}
Можете ли Вы дать примеры запросов, с которыми эти простые определения
приведут к нежелательному поведению?
\end{exercise}

\begin{exercise}{4.72}%
\label{EX4.72}%
Почему {\tt adjoin} и {\tt stream-flatmap}
чередуют потоки, а не просто их сцепляют?  Приведите примеры, которые
показывают, что чередование работает лучше.  (Подсказка: зачем мы
пользовались {\tt interleave} в 
разделе~\ref{EXPLOITING-THE-STREAM-PARADIGM}?)
\end{exercise}

\begin{exercise}{4.73}%
\label{EX4.73}%
Почему {\tt flatten-stream} использует
{\tt delay} явно?  Что было бы неправильно в таком определении:

\begin{Verbatim}[fontsize=\small]
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
\end{Verbatim}
\end{exercise}

\begin{exercise}{4.74}%
\label{EX4.74}%
Лиза П.~Хакер предлагает использовать в
{\tt negate}, {\tt lisp-value} и
{\tt find-assertions} упрощенную версию
\index{ru}{stream-flatmap||||p|(упр.~4.74)}{\tt stream-flatmap}. Она 
замечает, что в этих случаях
процедура, которая отображает поток кадров, всегда порождает либо
пустой поток, либо поток из одного элемента, и поэтому при слиянии
этих потоков незачем использовать чередование.

\begin{plainenum}
\item
Заполните пропущенные выражения в программе Лизы.

\begin{Verbatim}[fontsize=\small]
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map \textit{$\langle$??$\rangle$}
              (stream-filter \textit{$\langle$??$\rangle$} stream)))
\end{Verbatim}

\item
Если мы изменяем систему таким образом, меняется ли
ее поведение?
\end{plainenum}
\end{exercise}

\begin{exercise}{4.75}%
\label{EX4.75}%
\index{ru}{язык запросов|расширения||||(упр.~4.75)}\index{ru}{составной 
запрос|обработка||||(упр.~4.75)}Реализуйте в языке запросов новую особую форму
\index{ru}{unique (язык запросов)||||p|(упр.~4.75)}{\tt unique}. Выражение 
{\tt unique} должно быть успешно, 
если в базе данных ровно одна запись, удовлетворяющая указанному
запросу. Например запрос

\begin{Verbatim}[fontsize=\small]
(unique (должность ?x (компьютеры гуру)))
\end{Verbatim}
должен печатать одноэлементный поток

\begin{Verbatim}[fontsize=\small]
(unique (должность (Битобор Бен) (компьютеры гуру)))
\end{Verbatim}
поскольку Бен~--- единственный компьютерный гуру, а

\begin{Verbatim}[fontsize=\small]
(unique (должность ?x (компьютеры программист)))
\end{Verbatim}
должно печатать пустой поток, поскольку программистов больше одного.
Более того,

\begin{Verbatim}[fontsize=\small]
(and (должность ?x ?j) (unique (должность ?anyone ?j)))
\end{Verbatim}
должно перечислять все должности, на которых работает по одному
человеку, а также самих этих людей.

Реализация {\tt unique} состоит из двух частей.
Первая заключается в том, чтобы написать процедуру, которая обрабатывает
эту особую форму, а вторая в том, чтобы заставить {\tt qeval}
распознавать форму и вызывать ее процедуру.  Вторая часть тривиальна,
поскольку {\tt qeval} написана в стиле программирования,
управляемого данными.  Если Ваша процедура называется
{\tt uniquely-asserted}, то нужно только написать

\begin{Verbatim}[fontsize=\small]
(put 'unique 'qeval uniquely-asserted)
\end{Verbatim}
и {\tt qeval} будет передавать управление этой процедуре для
всех запросов, у которых в {\tt type} ({\tt car}) стоит
символ {\tt unique}.

Собственно задача состоит в том, чтобы написать процедуру
{\tt uniquely-asserted}.  В качестве входа она должна принимать
{\tt contents} ({\tt cdr}) запроса {\tt unique} и
поток кадров.  Для каждого кадра в потоке она должна с помощью
{\tt qeval} находить поток всех расширений, удовлетворяющих
данному запросу.  Потоки, в которых число элементов не равно одному,
должны отбрасываться.  Оставшиеся потоки нужно собирать в один большой
поток.  Он и становится результатом запроса {\tt unique}. Эта
процедура подобна реализации особой формы {\tt not}.

Проверьте свою реализацию, сформировав запрос, который
находит всех служащих, которые начальствуют ровно над одним
человеком.
\end{exercise}

\begin{exercise}{4.76}%
\label{EX4.76}%
\index{ru}{составной запрос|обработка||||(упр.~4.76)}%
\index{ru}{интерпретатор языка запросов|улучшения||||(упр.~4.76)}%
Наша реализация {\tt and} в виде 
последовательной\index{ru}{and (язык запросов)|обработка|||p|(упр.~4.76)}
комбинации запросов (рисунок~\ref{P4.5}) изящна, но
неэффективна, поскольку при обработке второго запроса приходится
просматривать базу данных для каждого кадра, порожденного первым
запросом.  Если в базе данных $N$ записей, а типичный
запрос порождает число записей, пропорциональное $N$
(скажем, $N/k$), то проход базы данных для каждого кадра,
порожденного первым запросом, потребует $N^2/k$ вызовов
сопоставителя.  Другой подход может состоять в том, чтобы обрабатывать
два подвыражения запроса {\tt and} по отдельности а затем
искать совместимые пары входных кадров.  Если каждый запрос порождает
$N/k$ кадров, то нам придется проделать
$N^2/k^2$ проверок на совместимость~--- в $k$ раз
меньше, чем число сопоставлений при нашем теперешнем методе.

Постройте реализацию {\tt and} с использованием
этой стратегии.  Вам придется написать процедуру, которая принимает
на входе два кадра, проверяет связывания в этих кадрах на
совместимость и, если они совместимы, порождает кадр, в котором
множества связываний слиты.  Эта операция подобна унификации.
\end{exercise}

\begin{exercise}{4.77}%
\label{EX4.77}%
\index{ru}{интерпретатор языка запросов|улучшения||||(упр.~4.77)}В 
разделе~\ref{IS-LOGIC-PROGRAMMING-MATHEMATICAL-LOGIC} мы видели,
что выражения {\tt not} и {\tt lisp-value}\index{ru}{not (язык 
запросов)|вычисление|||p|(упр.~4.77)}\index{ru}{lisp-value (язык 
запросов)|вычисление|||p|(упр.~4.77)}\index{ru}{составной 
запрос|обработка||||(упр.~4.77)}\index{ru}{интерпретатор языка 
запросов|проблемы с \texttt{not} и \texttt{lisp-value}||||(упр.~4.77)}
могут заставить язык запросов выдавать <<неправильные>> значения, если эти
фильтрующие операции применяются к кадрам с несвязанными переменными.
Придумайте способ избавиться от этого недостатка.  Одна из
возможностей состоит в том, чтобы проводить <<задержанную>>
фильтрацию, цепляя к кадру <<обещание>> провести ее, которое
выполняется только тогда, когда связано достаточно переменных, чтобы
операция стала возможна.  Можно ждать и проводить фильтрацию только
тогда, когда выполнены все остальные операции.  Однако из соображений
эффективности хотелось бы фильтровать как можно раньше, чтобы
уменьшить число порождаемых промежуточных кадров.
\end{exercise}

\begin{exercise}{4.78}%
\label{EX4.78}%
\index{ru}{недетерминистское программирование vs. программирование на Scheme|||||(упр.~4.78)}%
Перестройте язык запросов в виде недетерминистской программы, реализуемой интерпретатором из 
раздела~\ref{VARIATIONS-ON-A-SCHEME-NONDETERMINISTIC-COMPUTING}, а
не в виде процесса обработки потоков.  При таком подходе каждый запрос
будет порождать один ответ (а не поток всех возможных ответов), а
пользователь может ввести {\tt try-again} и получить следующий
ответ.  Вы увидите, что существенная часть механизмов, которые мы
построили в этом разделе, заменяется недетерминистским поиском и
перебором с возвратами.  Однако помимо этого, Вы обнаружите, что новый
язык запросов отличается в тонких деталях поведения от реализованного
нами в этом разделе.  Можете ли Вы привести примеры, показывающие эти
отличия?
\end{exercise}

\begin{exercise}{4.79}%
\label{EX4.79}%
\index{ru}{интерпретатор языка запросов|vs. интерпретатор для 
Лиспа||||(упр.~4.79)}Когда мы реализовывали в
разделе~\ref{THE-METACIRCULAR-EVALUATOR} интерпретатор, 
\index{ru}{окружение|и переименование||||(упр.~4.79)}мы видели,
как можно избежать конфликтов между именами параметров процедур при
помощи локальных окружений.  Например, при вычислении

\begin{Verbatim}[fontsize=\small]
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
\end{Verbatim}
не возникает смешения между {\tt x} из {\tt square} и
{\tt x} из {\tt sum-of-squares}, поскольку тело каждой
процедуры мы вычисляем в окружении, которое специально построено для
связывания локальных переменных.  В запросной системе мы избегаем
конфликтов имен при применении правил с помощью другой стратегии.
Каждый раз при применении правила мы переименовываем переменные и даем
им новые имена, которые обязаны быть уникальными.  Аналогичная
стратегия в интерпретаторе Лиспа заключалась бы в том, чтобы отменить
внутренние окружения и просто переименовывать переменные в теле
процедуры каждый раз, как мы ее вызываем.

\index{ru}{интерпретатор языка запросов|структура 
окружений||||(упр.~4.79)}  \index{ru}{правило (в языке 
запросов)|применение||||(упр.~4.79)}Реализуйте для языка
запросов метод применения правил, 
который использует не переименования, а \index{ru}{окружение|в 
интерпретаторе запросов||||(упр.~4.79)}окружения.  Рассмотрите, можно
ли использовать Вашу систему окружений для построения в языке запросов
конструкций для работы с большими системами, например аналога блочной
структуры процедур для правил.  Можно ли связать это с проблемой ведения
\index{ru}{блочная структура|в языке запросов||||(упр.~4.79)}рассуждений в 
контексте (например: <<Если бы я предположил, что
истинно $P$, то я смог бы доказать $A$ и
$B$>>) в качестве метода решения задач?  (Это упражнение
не имеет однозначного решения.  Хороший ответ, скорее всего, мог бы
служить темой диссертации.)
\end{exercise}
